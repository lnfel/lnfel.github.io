import{s as safe_not_equal,d as action_destroyer,n as noop,r as run_all}from"../chunks/scheduler.Bs-Ydizp.js";import{S as SvelteComponent,i as init,e as element,s as space,c as claim_element,d as children,f as detach,g as claim_space,j as get_svelte_dataset,k as attr,l as insert_hydration,m as append_hydration,q as listen}from"../chunks/index.cVSpFuol.js";import{e as enhance}from"../chunks/forms.Dyxbqwv4.js";import{_ as __vitePreload}from"../chunks/preload-helper.BQ24v_F8.js";import{c as commonjsGlobal}from"../chunks/_commonjsHelpers.C4iS2aBk.js";var ort_min={exports:{}};/*!
* ONNX Runtime Web v1.16.3
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(R,l){module.exports=l()})(self,()=>(()=>{var __webpack_modules__={5716:(R,l,b)=>{l.R=void 0;const m=b(6027),p=b(1723);l.R=new class{async init(){}async createSessionHandler(h,d){const u=new m.Session(d);return await u.loadModel(h),new p.OnnxjsSessionHandler(u)}}},2818:(R,l,b)=>{l.c8=l.rX=void 0;const m=b(2235),p=b(5381),h=b(9544),d=b(6640);l.rX=()=>{if((typeof m.env.wasm.initTimeout!="number"||m.env.wasm.initTimeout<0)&&(m.env.wasm.initTimeout=0),typeof m.env.wasm.simd!="boolean"&&(m.env.wasm.simd=!0),typeof m.env.wasm.proxy!="boolean"&&(m.env.wasm.proxy=!1),typeof m.env.wasm.numThreads!="number"||!Number.isInteger(m.env.wasm.numThreads)||m.env.wasm.numThreads<=0){const u=typeof navigator>"u"?(0,p.cpus)().length:navigator.hardwareConcurrency;m.env.wasm.numThreads=Math.min(4,Math.ceil((u||1)/2))}},l.c8=new class{async init(){(0,l.rX)(),await(0,h.initializeWebAssemblyInstance)()}async createSessionHandler(u,c){const a=new d.OnnxruntimeWebAssemblySessionHandler;return await a.loadModel(u,c),Promise.resolve(a)}}},1057:function(R,l,b){var m=this&&this.__createBinding||(Object.create?function(u,c,a,o){o===void 0&&(o=a);var n=Object.getOwnPropertyDescriptor(c,a);n&&!("get"in n?!c.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return c[a]}}),Object.defineProperty(u,o,n)}:function(u,c,a,o){o===void 0&&(o=a),u[o]=c[a]}),p=this&&this.__exportStar||function(u,c){for(var a in u)a==="default"||Object.prototype.hasOwnProperty.call(c,a)||m(c,u,a)};Object.defineProperty(l,"__esModule",{value:!0}),p(b(2235),l);const h=b(2235),d=b(8408);{const u=b(5716).R;(0,h.registerBackend)("webgl",u,-10)}{const u=b(2818).c8;(0,h.registerBackend)("cpu",u,10),(0,h.registerBackend)("wasm",u,10),(0,h.registerBackend)("xnnpack",u,9),(0,h.registerBackend)("webnn",u,9)}h.env.versions.web=d.version},4910:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createAttributeWithCacheKey=void 0;class b{constructor(p){Object.assign(this,p)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(p=>`${this[p]}`).join(";")),this._cacheKey}}l.createAttributeWithCacheKey=m=>new b(m)},6874:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.Attribute=void 0;const m=b(5127),p=b(2446),h=b(9240),d=b(7273);var u=m.onnxruntime.experimental.fbs;class c{constructor(o){if(this._attributes=new Map,o!=null){for(const n of o)n instanceof p.onnx.AttributeProto?this._attributes.set(n.name,[c.getValue(n),c.getType(n)]):n instanceof u.Attribute&&this._attributes.set(n.name(),[c.getValue(n),c.getType(n)]);if(this._attributes.size<o.length)throw new Error("duplicated attribute names")}}set(o,n,t){this._attributes.set(o,[t,n])}delete(o){this._attributes.delete(o)}getFloat(o,n){return this.get(o,"float",n)}getInt(o,n){return this.get(o,"int",n)}getString(o,n){return this.get(o,"string",n)}getTensor(o,n){return this.get(o,"tensor",n)}getFloats(o,n){return this.get(o,"floats",n)}getInts(o,n){return this.get(o,"ints",n)}getStrings(o,n){return this.get(o,"strings",n)}getTensors(o,n){return this.get(o,"tensors",n)}get(o,n,t){const e=this._attributes.get(o);if(e===void 0){if(t!==void 0)return t;throw new Error(`required attribute not found: ${o}`)}if(e[1]!==n)throw new Error(`type mismatch: expected ${n} but got ${e[1]}`);return e[0]}static getType(o){const n=o instanceof p.onnx.AttributeProto?o.type:o.type();switch(n){case p.onnx.AttributeProto.AttributeType.FLOAT:return"float";case p.onnx.AttributeProto.AttributeType.INT:return"int";case p.onnx.AttributeProto.AttributeType.STRING:return"string";case p.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case p.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case p.onnx.AttributeProto.AttributeType.INTS:return"ints";case p.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case p.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${p.onnx.AttributeProto.AttributeType[n]}`)}}static getValue(o){const n=o instanceof p.onnx.AttributeProto?o.type:o.type();if(n===p.onnx.AttributeProto.AttributeType.GRAPH||n===p.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const t=this.getValueNoCheck(o);if(n===p.onnx.AttributeProto.AttributeType.INT&&d.LongUtil.isLong(t))return d.LongUtil.longToNumber(t);if(n===p.onnx.AttributeProto.AttributeType.INTS){const e=t,r=new Array(e.length);for(let i=0;i<e.length;i++){const s=e[i];r[i]=d.LongUtil.longToNumber(s)}return r}if(n===p.onnx.AttributeProto.AttributeType.TENSOR)return o instanceof p.onnx.AttributeProto?h.Tensor.fromProto(t):h.Tensor.fromOrtTensor(t);if(n===p.onnx.AttributeProto.AttributeType.TENSORS){if(o instanceof p.onnx.AttributeProto)return t.map(e=>h.Tensor.fromProto(e));if(o instanceof u.Attribute)return t.map(e=>h.Tensor.fromOrtTensor(e))}if(n===p.onnx.AttributeProto.AttributeType.STRING&&o instanceof p.onnx.AttributeProto){const e=t;return(0,d.decodeUtf8String)(e)}return n===p.onnx.AttributeProto.AttributeType.STRINGS&&o instanceof p.onnx.AttributeProto?t.map(d.decodeUtf8String):t}static getValueNoCheck(o){return o instanceof p.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(o):this.getValueNoCheckFromOrtFormat(o)}static getValueNoCheckFromOnnxFormat(o){switch(o.type){case p.onnx.AttributeProto.AttributeType.FLOAT:return o.f;case p.onnx.AttributeProto.AttributeType.INT:return o.i;case p.onnx.AttributeProto.AttributeType.STRING:return o.s;case p.onnx.AttributeProto.AttributeType.TENSOR:return o.t;case p.onnx.AttributeProto.AttributeType.GRAPH:return o.g;case p.onnx.AttributeProto.AttributeType.FLOATS:return o.floats;case p.onnx.AttributeProto.AttributeType.INTS:return o.ints;case p.onnx.AttributeProto.AttributeType.STRINGS:return o.strings;case p.onnx.AttributeProto.AttributeType.TENSORS:return o.tensors;case p.onnx.AttributeProto.AttributeType.GRAPHS:return o.graphs;default:throw new Error(`unsupported attribute type: ${p.onnx.AttributeProto.AttributeType[o.type]}`)}}static getValueNoCheckFromOrtFormat(o){switch(o.type()){case u.AttributeType.FLOAT:return o.f();case u.AttributeType.INT:return o.i();case u.AttributeType.STRING:return o.s();case u.AttributeType.TENSOR:return o.t();case u.AttributeType.GRAPH:return o.g();case u.AttributeType.FLOATS:return o.floatsArray();case u.AttributeType.INTS:{const n=[];for(let t=0;t<o.intsLength();t++)n.push(o.ints(t));return n}case u.AttributeType.STRINGS:{const n=[];for(let t=0;t<o.stringsLength();t++)n.push(o.strings(t));return n}case u.AttributeType.TENSORS:{const n=[];for(let t=0;t<o.tensorsLength();t++)n.push(o.tensors(t));return n}default:throw new Error(`unsupported attribute type: ${u.AttributeType[o.type()]}`)}}}l.Attribute=c},1975:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.resolveBackend=l.backend=void 0;const m=b(4418),p=new Map;async function h(d){const u=l.backend;if(u[d]!==void 0&&function(c){const a=c;return"initialize"in a&&typeof a.initialize=="function"&&"createSessionHandler"in a&&typeof a.createSessionHandler=="function"&&"dispose"in a&&typeof a.dispose=="function"}(u[d])){const c=u[d];let a=c.initialize();if(typeof a=="object"&&"then"in a&&(a=await a),a)return p.set(d,c),c}}l.backend={webgl:new m.WebGLBackend},l.resolveBackend=async function d(u){if(!u)return d(["webgl"]);{const c=typeof u=="string"?[u]:u;for(const a of c){const o=p.get(a);if(o)return o;const n=await h(a);if(n)return n}}throw new Error("no available backend to use")}},4418:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.WebGLBackend=void 0;const m=b(2235),p=b(1315),h=b(2171),d=b(3389);l.WebGLBackend=class{get contextId(){return m.env.webgl.contextId}set contextId(u){m.env.webgl.contextId=u}get matmulMaxBatchSize(){return m.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(u){m.env.webgl.matmulMaxBatchSize=u}get textureCacheMode(){return m.env.webgl.textureCacheMode}set textureCacheMode(u){m.env.webgl.textureCacheMode=u}get pack(){return m.env.webgl.pack}set pack(u){m.env.webgl.pack=u}get async(){return m.env.webgl.async}set async(u){m.env.webgl.async=u}initialize(){try{return this.glContext=(0,d.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),p.Logger.setWithEnv(m.env),p.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(u){return p.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${u}`),!1}}createSessionHandler(u){return new h.WebGLSessionHandler(this,u)}dispose(){this.glContext.dispose()}}},6859:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.CoordsGlslLib=void 0;const m=b(7273),p=b(1997),h=b(6757),d=b(7618),u=b(432);class c extends p.GlslLib{constructor(o){super(o)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new p.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new p.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const o=this.context.outputTextureLayout;return o.isPacked?this.getPackedOutputSamplingSnippet(o):this.getUnpackedOutputSamplingSnippet(o)}getPackedOutputSamplingSnippet(o){const n=o.unpackedShape,t=[o.width,o.height],e={},r="getOutputCoords";switch(n.length){case 0:e[r]=this.getOutputScalarCoords();break;case 1:e[r]=this.getOutputPacked1DCoords(n,t);break;case 2:e[r]=this.getOutputPacked2DCoords(n,t);break;case 3:e[r]=this.getOutputPacked3DCoords(n,t);break;default:e[r]=this.getOutputPackedNDCoords(n,t)}const i=`
      void setOutput(vec4 val) {
        ${(0,h.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return e.floatTextureSetRGBA=new p.GlslLibRoutine(i),e}getUnpackedOutputSamplingSnippet(o){const n=o.unpackedShape,t=[o.width,o.height],e={},r="getOutputCoords";switch(n.length){case 0:e[r]=this.getOutputScalarCoords();break;case 1:e[r]=this.getOutputUnpacked1DCoords(n,t);break;case 2:e[r]=this.getOutputUnpacked2DCoords(n,t);break;case 3:e[r]=this.getOutputUnpacked3DCoords(n,t);break;case 4:e[r]=this.getOutputUnpacked4DCoords(n,t);break;case 5:e[r]=this.getOutputUnpacked5DCoords(n,t);break;case 6:e[r]=this.getOutputUnpacked6DCoords(n,t);break;default:throw new Error(`Unsupported output dimensionality: ${n.length}`)}const i=`
        void setOutput(float val) {
          ${(0,h.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return e.floatTextureSetR=new p.GlslLibRoutine(i),e}getOutputScalarCoords(){return new p.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(o,n){const t=n;let e="";return t[0]===1?(e=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${t[1]}.0);
          }
        `,new p.GlslLibRoutine(e)):t[1]===1?(e=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${t[0]}.0);
          }
        `,new p.GlslLibRoutine(e)):(e=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${t[0]}, ${t[1]}));
          return 2 * (resTexRC.y * ${t[0]} + resTexRC.x);
        }
      `,new p.GlslLibRoutine(e))}getOutputPacked2DCoords(o,n){let t="";if(m.ArrayUtil.arraysEqual(o,n))return t=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${n[0]}, ${n[1]}));
        }
      `,new p.GlslLibRoutine(t);const e=n,r=Math.ceil(o[1]/2);return t=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));

          int index = resTexRC.y * ${e[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${r}) * 2;
          int c = 2 * (index / ${r});

          return ivec2(r, c);
        }
      `,new p.GlslLibRoutine(t)}getOutputPacked3DCoords(o,n){const t=[n[0],n[1]],e=Math.ceil(o[2]/2),r=e*Math.ceil(o[1]/2),i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;

          int b = index / ${r};
          index -= b * ${r};

          // reverse r and c order for packed texture
          int r = imod(index, ${e}) * 2;
          int c = 2 * (index / ${e});

          return ivec3(b, r, c);
        }
      `;return new p.GlslLibRoutine(i)}getOutputPackedNDCoords(o,n){const t=[n[0],n[1]],e=Math.ceil(o[o.length-1]/2),r=e*Math.ceil(o[o.length-2]/2);let i=r,s="",f="b, r, c";for(let y=2;y<o.length-1;y++)i*=o[o.length-y-1],s=`
      int b${y} = index / ${i};
      index -= b${y} * ${i};
    `+s,f=`b${y}, `+f;const g=`
      ivec${o.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.y * ${t[0]} + resTexRC.x;

        ${s}

        int b = index / ${r};
        index -= b * ${r};

        // reverse r and c order for packed texture
        int r = imod(index, ${e}) * 2;
        int c = 2 * (index / ${e});

        return ivec${o.length}(${f});
      }
    `;return new p.GlslLibRoutine(g)}getOutputUnpacked1DCoords(o,n){const t=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          return resTexRC.y * ${n[0]} + resTexRC.x;
        }
      `;return new p.GlslLibRoutine(t)}getOutputUnpacked2DCoords(o,n){const t=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          int r = index / ${o[1]};
          int c = index - r * ${o[1]};
          return ivec2(r, c);
        }
      `;return new p.GlslLibRoutine(t)}getOutputUnpacked3DCoords(o,n){let t="";const e=o.length;let r=null;e<2&&(r=[]),r=new Array(e-1),r[e-2]=o[e-1];for(let f=e-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d"],s=r.map((f,g)=>`int ${i[g]} = index / ${f}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${f}`:`index -= ${i[g]} * ${f}`};`).join("");return t=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${s}
          return ivec3(r, c, d);
        }
      `,new p.GlslLibRoutine(t)}getOutputUnpacked4DCoords(o,n){let t="";const e=o.length;let r=null;e<2&&(r=[]),r=new Array(e-1),r[e-2]=o[e-1];for(let f=e-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d","d2"],s=r.map((f,g)=>`int ${i[g]} = index / ${f}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${f}`:`index -= ${i[g]} * ${f}`};`).join("");return t=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${s}
          return ivec4(r, c, d, d2);
        }
      `,new p.GlslLibRoutine(t)}getOutputUnpacked5DCoords(o,n){let t="";const e=o.length;let r=null;e<2&&(r=[]),r=new Array(e-1),r[e-2]=o[e-1];for(let f=e-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d","d2","d3"],s=r.map((f,g)=>`int ${i[g]} = index / ${f}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${f}`:`index -= ${i[g]} * ${f}`};`).join("");return t=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${s}
          return ivec5(r, c, d, d2, d3);
        }
      `,new p.GlslLibRoutine(t)}getOutputUnpacked6DCoords(o,n){let t="";const e=o.length;let r=null;e<2&&(r=[]),r=new Array(e-1),r[e-2]=o[e-1];for(let f=e-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d","d2","d3","d4"],s=r.map((f,g)=>`int ${i[g]} = index / ${f}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${f}`:`index -= ${i[g]} * ${f}`};`).join("");return t=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${n[0]}, ${n[1]}));
         int index = resTexRC.y * ${n[0]} + resTexRC.x;
         ${s}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new p.GlslLibRoutine(t)}getCommonUtilFuncs(){const o={};let n="uvFromFlat";o[n]=new p.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),n="packedUVfrom1D",o[n]=new p.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom2D",o[n]=new p.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom3D",o[n]=new p.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="sampleTexture";const t=(0,h.getGlsl)(this.context.glContext.version);return o[n]=new p.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${t.texture2D}(textureSampler, uv).r;
        }`),o}getInputsSamplingSnippets(){const o={},n=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((t,e)=>{const r=this.context.inputTextureLayouts[e],i=(0,u.generateShaderFuncNameFromInputSamplerName)(t);r.isPacked?o[i]=this.getPackedSamplerFromInput(i,t,r):o[i]=this.getUnpackedSamplerFromInput(i,t,r);const s=(0,u.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(t);r.unpackedShape.length<=n.unpackedShape.length&&(r.isPacked?o[s]=this.getPackedSamplerAtOutputCoords(s,r,n,t):o[s]=this.getUnpackedSamplerAtOutputCoords(s,r,n,t))}),o}getPackedSamplerAtOutputCoords(o,n,t,e){const r=n.unpackedShape,i=t.unpackedShape,s=e,f=(0,u.generateShaderFuncNameFromInputSamplerName)(s),g=r.length,y=i.length,v=m.BroadcastUtil.getBroadcastDims(r,i),w=(0,u.getCoordsDataType)(y),T=y-g;let x;const A=(0,u.getGlChannels)();x=g===0?"":y<2&&v.length>=1?"coords = 0;":v.map(U=>`coords.${A[U+T]} = 0;`).join(`
`);let D="";D=y<2&&g>0?"coords":r.map((U,O)=>`coords.${A[O+T]}`).join(", ");let $="return outputValue;";const j=m.ShapeUtil.size(r)===1,M=m.ShapeUtil.size(i)===1;if(g!==1||j||M){if(j&&!M)$=y===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(v.length){const U=g-2,O=g-1;v.indexOf(U)>-1&&v.indexOf(O)>-1?$="return vec4(outputValue.x);":v.indexOf(U)>-1?$="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":v.indexOf(O)>-1&&($="return vec4(outputValue.xx, outputValue.zz);")}}else $=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const S=`
      vec4 ${o}() {
        ${w} coords = getOutputCoords();
        
        int lastDim = coords.${A[y-1]};
        coords.${A[y-1]} = coords.${A[y-2]};
        coords.${A[y-2]} = lastDim;
      
        ${x}
        vec4 outputValue = ${f}(${D});
        ${$}
      }
    `;return new p.GlslLibRoutine(S,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(o,n,t,e){const r=[t.width,t.height],i=[n.width,n.height],s=n.unpackedShape.length,f=t.unpackedShape.length,g=n.unpackedShape,y=t.unpackedShape,v=(0,u.generateShaderFuncNameFromInputSamplerName)(e);if(s===f&&m.ArrayUtil.arraysEqual(i,r)){const M=`
          float ${o}() {
            return sampleTexture(${e}, TexCoords);
          }
        `;return new p.GlslLibRoutine(M,["coordinates.sampleTexture"])}const w=(0,u.getCoordsDataType)(f),T=m.BroadcastUtil.getBroadcastDims(g,y),x=f-s;let A;const D=(0,u.getGlChannels)();A=s===0?"":f<2&&T.length>=1?"coords = 0;":T.map(M=>`coords.${D[M+x]} = 0;`).join(`
`);let $="";$=f<2&&s>0?"coords":n.unpackedShape.map((M,S)=>`coords.${D[S+x]}`).join(", ");const j=`
        float ${o}() {
          ${w} coords = getOutputCoords();
          ${A}
          return ${v}(${$});
        }
      `;return new p.GlslLibRoutine(j,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(o,n,t){switch(t.unpackedShape.length){case 0:return this.getPackedSamplerScalar(o,n);case 1:return this.getPackedSampler1D(o,n,t);case 2:return this.getPackedSampler2D(o,n,t);case 3:return this.getPackedSampler3D(o,n,t);default:return this.getPackedSamplerND(o,n,t)}}getUnpackedSamplerFromInput(o,n,t){const e=t.unpackedShape;switch(e.length){case 0:return this.getUnpackedSamplerScalar(o,n,t);case 1:return this.getUnpackedSampler1D(o,n,t);case 2:return this.getUnpackedSampler2D(o,n,t);case 3:return this.getUnpackedSampler3D(o,n,t);case 4:return this.getUnpackedSampler4D(o,n,t);case 5:return this.getUnpackedSampler5D(o,n,t);case 6:return this.getUnpackedSampler6D(o,n,t);default:throw new Error(`Unsupported dimension ${e.length}-D`)}}getPackedSamplerScalar(o,n){const t=`
          vec4 ${o}() {
            return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${n}, halfCR);
          }
        `;return new p.GlslLibRoutine(t)}getPackedSampler1D(o,n,t){const e=[t.width,t.height],r=[e[1],e[0]],i=(0,h.getGlsl)(this.context.glContext.version),s=`vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
      ${r[0]}, ${r[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }`;return new p.GlslLibRoutine(s,["coordinates.packedUVfrom1D"])}getPackedSampler2D(o,n,t){const e=t.unpackedShape,r=[t.width,t.height],i=(0,h.getGlsl)(this.context.glContext.version),s=r[0],f=r[1];if(r!=null&&m.ArrayUtil.arraysEqual(e,r)){const w=`vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${s}.0);
        return ${i.texture2D}(${n}, uv);
      }`;return new p.GlslLibRoutine(w)}const g=r,y=Math.ceil(e[1]/2),v=`vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${g[1]}, ${g[0]}, ${y}, row, col);
      return ${i.texture2D}(${n}, uv);
    }`;return new p.GlslLibRoutine(v,["coordinates.packedUVfrom2D"])}getPackedSampler3D(o,n,t){const e=t.unpackedShape,r=[t.width,t.height],i=[r[0],r[1]],s=(0,h.getGlsl)(this.context.glContext.version);if(e[0]===1){const w=e.slice(1),T=[1,2],x=(0,u.squeezeInputShape)(e,w),A=["b","row","col"],D=JSON.parse(JSON.stringify(t));D.unpackedShape=x;const $=this.getPackedSamplerFromInput(o,n,D),j=`${$.routineBody}
      vec4 ${o}(int b, int row, int col) {
        return ${o}(${(0,u.getSqueezedParams)(A,T)});
      } `;return new p.GlslLibRoutine(j,$.dependencies)}const f=i[0],g=i[1],y=Math.ceil(e[2]/2),v=`vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${g}, ${f}, ${y*Math.ceil(e[1]/2)}, ${y}, b, row, col);
      return ${s.texture2D}(${n}, uv);}`;return new p.GlslLibRoutine(v,["coordinates.packedUVfrom3D"])}getPackedSamplerND(o,n,t){const e=t.unpackedShape,r=e.length,i=[t.width,t.height],s=(0,h.getGlsl)(this.context.glContext.version),f=[i[0],i[1]],g=f[1],y=f[0],v=Math.ceil(e[r-1]/2);let w=v*Math.ceil(e[r-2]/2),T="int b, int row, int col",x=`b * ${w} + (row / 2) * ${v} + (col / 2)`;for(let D=2;D<r-1;D++)T=`int b${D}, `+T,w*=e[r-D-1],x=`b${D} * ${w} + `+x;const A=`vec4 ${o}(${T}) {
      int index = ${x};
      int texR = index / ${y};
      int texC = index - texR * ${y};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${y}, ${g});
      return ${s.texture2D}(${n}, uv);
    }`;return new p.GlslLibRoutine(A)}getUnpackedSamplerScalar(o,n,t){const[e,r]=[t.width,t.height];if(e===1&&r===1){const s=`
          float ${o}() {
            return sampleTexture(${n}, halfCR);
          }
        `;return new p.GlslLibRoutine(s,["coordinates.sampleTexture"])}const i=`
        float ${o}() {
          int offset_${n} = coordsToOffset(TexCoords, ${e}, ${r});
          vec2 uv = uvFromFlat(${e}, ${r}, offset_${n});
          return sampleTexture(${n}, uv);
        }
      `;return new p.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(o,n,t){const e=t.width,r=t.height;if(r===1&&e===1){const s=`
        float ${o}(int index) {
          return sampleTexture(${n}, halfCR);
        }
      `;return new p.GlslLibRoutine(s,["coordinates.sampleTexture"])}if(r===1){const s=`
          float ${o}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${e}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new p.GlslLibRoutine(s,["coordinates.sampleTexture"])}if(e===1){const s=`
          float ${o}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${r}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new p.GlslLibRoutine(s,["coordinates.sampleTexture"])}const i=`
        float ${o}(int index) {
          vec2 uv = uvFromFlat(${e}, ${r}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new p.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(o,n,t){const e=t.unpackedShape,r=[t.height,t.width];if(r!=null&&m.ArrayUtil.arraysEqual(e,r)){const w=`
          float ${o}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new p.GlslLibRoutine(w,["coordinates.sampleTexture"])}const{newShape:i,keptDims:s}=(0,d.squeezeShape)(e),f=i;if(f.length<e.length){const w=(0,u.squeezeInputShape)(e,f),T=JSON.parse(JSON.stringify(t));T.unpackedShape=w;const x=["col","row"],A=`
          ${this.getUnpackedSamplerFromInput(o,n,T).routineBody}
          float ${o}(int row, int col) {
            return ${o}(${(0,u.getSqueezedParams)(x,s)});
          }
        `;return new p.GlslLibRoutine(A,["coordinates.sampleTexture"])}const g=r[1],y=r[0];if(y===1){const w=`
          float ${o}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${g}, ${y});
            float index = dot(vec3(row, col, offset_${n}), vec3(${e[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${g}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new p.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(g===1){const w=`
          float ${o}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${g}, ${y});
            float index = dot(vec3(row, col, offset_${n}), vec3(${e[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${y}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new p.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const v=`
        float ${o}(int row, int col) {
          int index = col * ${e[1]} + row;
          vec2 uv = uvFromFlat(${g}, ${y}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new p.GlslLibRoutine(v,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(o,n,t){const e=t.unpackedShape,r=e[1]*e[2],i=e[2],{newShape:s,keptDims:f}=(0,d.squeezeShape)(e),g=s;if(g.length<e.length){const v=(0,u.squeezeInputShape)(e,g),w=["batch","col","row"],T=JSON.parse(JSON.stringify(t));T.unpackedShape=v;const x=this.getUnpackedSamplerFromInput(o,n,T),A=f.reverse(),D=`
          ${x.routineBody}
          float ${o}(int batch, int row, int col) {
            return ${o}(${(0,u.getSqueezedParams)(w,A)});
          }
        `;return new p.GlslLibRoutine(D,x.dependencies)}const y=`
          float ${o}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${r} + col * ${i} + row;
            vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
            return sampleTexture(${n}, uv);
          }
      `;return new p.GlslLibRoutine(y,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(o,n,t){const e=t.unpackedShape,r=e[3],i=e[2]*r,s=`
        float ${o}(int row, int col, int depth, int depth2) {
          int index = row * ${e[1]*i} + col * ${i} +
              depth2 * ${r} + depth;
          vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new p.GlslLibRoutine(s,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(o,n,t){const e=t.unpackedShape,r=e[4],i=e[3]*r,s=e[2]*i,f=e[1]*s,{newShape:g,keptDims:y}=(0,d.squeezeShape)(e);if(g.length<e.length){const w=(0,u.squeezeInputShape)(e,g),T=["row","col","depth","depth2","depth3"],x=JSON.parse(JSON.stringify(t));x.unpackedShape=w;const A=`
          ${this.getUnpackedSamplerFromInput(o,n,x).routineBody}
          float ${o}(int row, int col, int depth, int depth2, int depth3) {
            return ${o}(${(0,u.getSqueezedParams)(T,y)});
          }
        `;return new p.GlslLibRoutine(A,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const v=`
        float ${o}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${f} + col * ${s} + depth * ${i} +
          depth3 * ${r} + depth2;
          vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new p.GlslLibRoutine(v,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(o,n,t){const e=t.unpackedShape,r=e[5],i=e[4]*r,s=e[3]*i,f=e[2]*s,g=e[1]*f,{newShape:y,keptDims:v}=(0,d.squeezeShape)(e);if(y.length<e.length){const T=(0,u.squeezeInputShape)(e,y),x=["row","col","depth","depth2","depth3","depth4"],A=JSON.parse(JSON.stringify(t));A.unpackedShape=T;const D=`
            ${this.getUnpackedSamplerFromInput(o,n,A).routineBody}
            float ${o}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${o}(${(0,u.getSqueezedParams)(x,v)});
            }
          `;return new p.GlslLibRoutine(D,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const w=`
          float ${o}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${g} + col * ${f} + depth * ${s} +
            depth2 * ${i} + depth3 * ${r} + depth4;
            vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
            return sampleTexture(${n}, uv);
          }
        `;return new p.GlslLibRoutine(w,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const o=this.context.outputTextureLayout,n=o.shape.length,t=o.strides,e=o.width,r=o.height,i=[];for(let f=0;f<n-1;++f)i.push(`
        c[${f}] = offset / ${t[f]};`),i.push(`
        offset -= c[${f}] * ${t[f]};`);i.push(`
        c[${n-1}] = offset;`);const s=`
      void toVec(vec2 texCoords, out int c[${n}]) {
        int offset = coordsToOffset(texCoords, ${e}, ${r});
        ${i.join("")}
      }
      void toVec(int offset, out int c[${n}]) {
        ${i.join("")}
      }
    `;return{toVec:new p.GlslLibRoutine(s,["coordinates.coordsToOffset"])}}valueFrom(){const o={};return this.context.programInfo.inputNames.forEach((n,t)=>{const e=this.context.inputTextureLayouts[t],r=(e.unpackedShape.length>0?e.unpackedShape:e.shape).length;let i=`_${n}`;o[i]=new p.GlslLibRoutine(this.getValueFromSingle(n,r,e.width,e.height,!1),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),i+="_T",o[i]=new p.GlslLibRoutine(this.getValueFromSingle(n,r,e.width,e.height,!0),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),o}getValueFromSingle(o,n,t,e,r){let i=`_${o}`;return r&&(i+="_T"),`
        float ${i}(int m[${n}]) {
          int offset = indicesToOffset${i}(m);
          vec2 coords = offsetToCoords(offset, ${t}, ${e});
          float value = getColorAsFloat(${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords));
          return value;
        }
        `}getPackedValueFrom(o,n,t,e,r){let i=`_${o}_Pack`;return r&&(i+="_T"),`
        vec4 ${i}(int m[${n}]) {
          int offset = indicesToOffset_${o}(m);
          vec2 coords = offsetToCoords(offset, ${t}, ${e});
          return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords);
        }
        `}}l.CoordsGlslLib=c},1997:(R,l)=>{var b;Object.defineProperty(l,"__esModule",{value:!0}),l.TopologicalSortGlslRoutines=l.GlslLibRoutineNode=l.GlslLibRoutine=l.GlslLib=l.GlslContext=l.FunctionType=void 0,(b=l.FunctionType||(l.FunctionType={}))[b.ValueBased=0]="ValueBased",b[b.Positional=1]="Positional",l.GlslContext=class{constructor(m,p,h,d){this.glContext=m,this.programInfo=p,this.inputTextureLayouts=h,this.outputTextureLayout=d}},l.GlslLib=class{constructor(m){this.context=m}},l.GlslLibRoutine=class{constructor(m,p){this.routineBody=m,this.dependencies=p}},l.GlslLibRoutineNode=class{constructor(m,p,h){this.name=m,this.dependencies=h||[],p&&(this.routineBody=p)}addDependency(m){m&&this.dependencies.push(m)}},l.TopologicalSortGlslRoutines=class{static returnOrderedNodes(m){if(!m||m.length===0)return[];if(m.length===1)return m;const p=new Set,h=new Set,d=new Array;return this.createOrderedNodes(m,p,h,d),d}static createOrderedNodes(m,p,h,d){for(let u=0;u<m.length;++u)this.dfsTraverse(m[u],p,h,d)}static dfsTraverse(m,p,h,d){if(!m||h.has(m.name))return;if(p.has(m.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");p.add(m.name);const u=m.dependencies;if(u&&u.length>0)for(let c=0;c<u.length;++c)this.dfsTraverse(u[c],p,h,d);d.push(m),h.add(m.name),p.delete(m.name)}}},1371:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.EncodingGlslLib=void 0;const m=b(1997);class p extends m.GlslLib{constructor(d){super(d)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new m.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new m.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const d=p.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new m.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${d}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const d=p.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new m.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${d}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const d=new ArrayBuffer(4),u=new Uint32Array(d),c=new Uint8Array(d);if(u[0]=3735928559,c[0]===239)return!0;if(c[0]===222)return!1;throw new Error("unknown endianness")}}l.EncodingGlslLib=p},2691:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.FragColorGlslLib=void 0;const m=b(1997),p=b(6757);class h extends m.GlslLib{constructor(u){super(u)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const u=(0,p.getGlsl)(this.context.glContext.version);return{setFragColor:new m.GlslLibRoutine(`
        void setFragColor(float value) {
            ${u.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new m.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}l.FragColorGlslLib=h},3878:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.replaceInlines=void 0;const b=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;l.replaceInlines=function(m){const p={};let h;for(;(h=b.exec(m))!==null;){const d=h[3].split(",").map(u=>{const c=u.trim().split(" ");return c&&c.length===2?{type:c[0],name:c[1]}:null}).filter(u=>u!==null);p[h[2]]={params:d,body:h[4]}}for(const d in p){const u="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",d),c=new RegExp(u,"gm");for(;(h=c.exec(m))!==null;){const a=h[1],o=h[2],n=h[3].split(","),t=a?`${a} ${o};`:"";let e=p[d].body,r="";p[d].params.forEach((s,f)=>{s&&(r+=`${s.type} ${s.name} = ${n[f]};
`)}),e=`${r}
 ${e}`,e=e.replace("return",`${o} = `);const i=`
      ${t}
      {
        ${e}
      }
      `;m=m.replace(h[0],i)}}return m.replace(b,"")}},8897:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.GlslPreprocessor=void 0;const m=b(1997),p=b(3878),h=b(1248),d=b(6757);l.GlslPreprocessor=class{constructor(u,c,a,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new m.GlslContext(u,c,a,o),Object.keys(h.glslRegistry).forEach(t=>{const e=new h.glslRegistry[t](this.context);this.libs[t]=e});const n=this.glslLibRoutineDependencyGraph;for(const t in this.libs){const e=this.libs[t].getFunctions();for(const r in e){const i=t+"."+r;let s;n[i]?(s=n[i],s.routineBody=e[r].routineBody):(s=new m.GlslLibRoutineNode(i,e[r].routineBody),n[i]=s);const f=e[r].dependencies;if(f)for(let g=0;g<f.length;++g)if(n[f[g]])s.addDependency(n[f[g]]);else{const y=new m.GlslLibRoutineNode(f[g]);n[f[g]]=y,s.addDependency(y)}}}}preprocess(){const u=this.context.programInfo;let c=u.shaderSource;return this.context.programInfo.hasMain||(c=`${c}
      ${(0,d.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),c=(0,p.replaceInlines)(c),`${(0,d.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(u.inputNames,u.variables)}
    ${this.getImports(c)}
    ${c}`}getImports(u){const c=this.selectGlslLibRoutinesToBeIncluded(u);if(c.length===0)return"";let a="";for(let o=0;o<c.length;++o){if(!c[o].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${c[o].name}`);a+=c[o].routineBody+`
`}return a}selectGlslLibRoutinesToBeIncluded(u){const c=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(a=>{const o=a.split(".")[1];u.indexOf(o)!==-1&&c.push(this.glslLibRoutineDependencyGraph[a])}),m.TopologicalSortGlslRoutines.returnOrderedNodes(c)}getUniforms(u,c){const a=[];if(u)for(const o of u)a.push(`uniform sampler2D ${o};`);if(c)for(const o of c)a.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return a.join(`
`)}}},1248:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.glslRegistry=void 0;const m=b(6859),p=b(1371),h=b(2691),d=b(9183),u=b(9314);l.glslRegistry={encoding:p.EncodingGlslLib,fragcolor:h.FragColorGlslLib,vec:u.VecGlslLib,shapeUtils:d.ShapeUtilsGlslLib,coordinates:m.CoordsGlslLib}},9183:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.ShapeUtilsGlslLib=void 0;const m=b(1997);class p extends m.GlslLib{constructor(d){super(d)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const d=this.context.outputTextureLayout.shape.length,u={};return this.context.programInfo.inputNames.forEach((c,a)=>{const o=this.context.inputTextureLayouts[a].unpackedShape;if(o.length<=d){const n=o.length,t=d-n,e=`bcastIndices_${c}`;let r="";for(let s=0;s<n;++s)r+=`
          realIndices[${s}] = int( mod(float(bcastedIndices[${t+s}]), ${o[s]}.0) );
          `;const i=`
        void ${e} (int bcastedIndices[${d}], out int realIndices[${n}]) {
          ${r}
        }
        `;u[e]=new m.GlslLibRoutine(i)}}),u}bcastMatmulIndex(){const d=this.context.outputTextureLayout.shape.length,u={};return this.context.programInfo.inputNames.forEach((c,a)=>{const o=this.context.inputTextureLayouts[a].shape;if(!(o.length<2||o.length>d)){const n=o.length,t=d-n,e=`bcastMatmulIndices_${c}`;let r="";for(let s=0;s<n-2;++s)r+=`
          realIndices[${s}] = int( mod(float(bcastedIndices[${t+s}]), ${o[s]}.0) );
          `;const i=`
        void ${e}(int bcastedIndices[${d}], out int realIndices[${n}]) {
          ${r}
          realIndices[${n-1}] = bcastedIndices[${d-1}];
          realIndices[${n-2}] = bcastedIndices[${d-2}];
        }
        `;u[e]=new m.GlslLibRoutine(i)}}),u}indicesToOffset(){const d={};return this.context.programInfo.inputNames.forEach((u,c)=>{const a=this.context.inputTextureLayouts[c].shape,o=this.context.inputTextureLayouts[c].strides,n=a.length;let t=`indicesToOffset_${u}`;d[t]=new m.GlslLibRoutine(p.indexToOffsetSingle(t,n,o)),t=`indicesToOffset_${u}_T`,d[t]=new m.GlslLibRoutine(p.indexToOffsetSingle(t,n,o.slice().reverse()))}),d}static indexToOffsetSingle(d,u,c){let a="";for(let o=u-1;o>=0;--o)a+=`
        offset += indices[${o}] * ${c[o]};
        `;return`
      int ${d}(int indices[${u}]) {
        int offset = 0;
        ${a}
        return offset;
      }
      `}offsetToIndices(){const d={};return this.context.programInfo.inputNames.forEach((u,c)=>{const a=this.context.inputTextureLayouts[c].shape,o=this.context.inputTextureLayouts[c].strides,n=a.length;let t=`offsetToIndices_${u}`;d[t]=new m.GlslLibRoutine(p.offsetToIndicesSingle(t,n,o)),t=`offsetToIndices_${u}_T`,d[t]=new m.GlslLibRoutine(p.offsetToIndicesSingle(t,n,o.slice().reverse()))}),d}static offsetToIndicesSingle(d,u,c){const a=[];for(let o=0;o<u-1;++o)a.push(`
      indices[${o}] = offset / ${c[o]};`),a.push(`
        offset -= indices[${o}] * ${c[o]};`);return a.push(`
      indices[${u-1}] = offset;`),`
      void ${d}(int offset, out int indices[${u}]) {
        ${a.join("")}
      }
      `}incrementIndices(){const d={};return this.context.programInfo.inputNames.forEach((u,c)=>{const a=this.context.inputTextureLayouts[c].shape,o=a.length,n=`incrementIndices_${u}`;let t="";for(let r=0;r<o;++r)t+=`
        shape[${r}] = ${a[r]};`;const e=`
        void ${n}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${t};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;d[n]=new m.GlslLibRoutine(e)}),d}}l.ShapeUtilsGlslLib=p},6757:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.getDefaultFragShaderMain=l.getFragShaderPreamble=l.getVertexShaderSource=l.getGlsl=void 0;const b={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},m={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function p(h){return h===1?b:m}l.getGlsl=p,l.getVertexShaderSource=function(h){const d=p(h);return`${d.version}
      precision highp float;
      ${d.attribute} vec3 position;
      ${d.attribute} vec2 textureCoord;

      ${d.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},l.getFragShaderPreamble=function(h){const d=p(h);return`${d.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${d.varyingFrag} vec2 TexCoords;
    ${d.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},l.getDefaultFragShaderMain=function(h,d){return`
  void main() {
    int indices[${d}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${p(h).output} = result;
  }
  `}},9314:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.VecGlslLib=void 0;const m=b(1997);class p extends m.GlslLib{constructor(d){super(d)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const d=this.context.outputTextureLayout.shape.length,u={add:"+=",sub:"-=",mul:"*=",div:"/="},c={};for(const a in u){const o=`${a}Vec`;let n="";for(let e=0;e<d;++e)n+=`
          dest[${e}] ${u[a]} src[${e}];
          `;const t=`
        void ${o}(int src[${d}], out int dest[${d}]) {
          ${n}
        }
        `;c[o]=new m.GlslLibRoutine(t)}return c}copyVec(){const d=this.context.outputTextureLayout.shape.length;let u="";for(let a=0;a<d;++a)u+=`
        dest[${a}] = src[${a}];
        `;const c=`
      void copyVec(int src[${d}], out int dest[${d}]) {
        ${u}
      }
      `;return{copyVec:new m.GlslLibRoutine(c)}}setVecItem(){const d=this.context.outputTextureLayout.shape.length;let u=`
        if(index < 0)
            index =${d} + index;
        if (index == 0)
            m[0] = value;
        `;for(let a=1;a<d-1;++a)u+=`
        else if (index == ${a})
            m[${a}] = value;
            `;u+=`
        else
            m[${d-1}] = value;
        `;const c=`
      void setVecItem(out int m[${d}], int index, int value) {
        ${u}
      }
        `;return{setVecItem:new m.GlslLibRoutine(c)}}getVecItem(){const d=this.context.outputTextureLayout.shape.length;let u=`
        if(index < 0)
            index = ${d} + index;
        if (index == 0)
            return m[0];
      `;for(let a=1;a<d-1;++a)u+=`
        else if (index == ${a})
            return m[${a}];
      `;u+=`
        else
            return m[${d-1}];
        `;const c=`
      int getVecItem(int m[${d}], int index) {
        ${u}
      }
    `;return{getVecItem:new m.GlslLibRoutine(c)}}}l.VecGlslLib=p},7860:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.WebGLInferenceHandler=void 0;const m=b(1315),p=b(9240),h=b(7273),d=b(9),u=b(7379),c=b(2488),a=b(540),o=b(3314),n=b(5639);l.WebGLInferenceHandler=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,e){return(0,o.calculateTextureWidthAndHeight)(this.session.layoutStrategy,t,e)}executeProgram(t,e){if(e.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error("input names size does not match input types");const r=[];for(let v=0;v<t.inputNames.length;++v)r[v]=this.getOrCreateTextureData(e[v],t.inputTypes[v]);const i=((v,w)=>{const T=w.map(A=>`${A.unpackedShape.join(",")};${A.width}x${A.height}`).join("_");let x=v.name;return v.cacheHint&&(x+="["+v.cacheHint+"]"),x+=":"+T,x})(t,r);let s=this.session.programManager.getArtifact(i);const f=s?s.programInfo:typeof t.get=="function"?t.get():t,g=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,f.output.dims,f.output.textureType),y=this.createTextureData(g,f.output.type);return s||(s=this.session.programManager.build(f,r,y),this.session.programManager.setArtifact(i,s)),this.runProgram(s,r,y),y}run(t,e){return this.executeProgram(t,e).tensor}runProgram(t,e,r){for(let i=0;i<e.length;++i)if(!!e[i].isPacked!=(t.programInfo.inputTypes[i]===n.TextureType.packed))throw new Error(`input[${i}] property packed inconsistent`);if(!!r.isPacked!=(t.programInfo.output.textureType===n.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(t,e,r)}getOrCreateTextureData(t,e){let r=this.getTextureData(t.dataId,e===n.TextureType.packed);if(!r&&(r=this.getTextureData(t.dataId,e!==n.TextureType.packed),r))return e===n.TextureType.packed?this.pack(r):this.unpack(r);if(!r){const i=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,t.dims,e);if(e===n.TextureType.packedLastDimension){const g=t.dims;if(g.length===4){const y=[g[0],Math.ceil(g[1]*g[2]*g[3]/4)],v=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,y,e);let w=t.numberData;if(g[1]*g[2]*g[3]%4!=0){const T=g[0],x=g[1]*g[2]*g[3],A=Math.ceil(x*1/4)*4;w=new Float32Array(T*A);for(let D=0;D<T;++D){const $=D*x,j=D*A+D%1*x;w.set(t.numberData.subarray($,$+x),j)}}return this.createTextureData(v,t.type,w,t,1)}}if(e===n.TextureType.packed){const s=(0,o.createTextureLayoutFromShape)(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),f=this.createTextureData(s,t.type,t.numberData,t,1);r=this.pack(f)}else r=this.createTextureData(i,t.type,t.numberData,t,1)}return r}createTextureDataFromLayoutBindTensor(t,e,r,i){return this.createTextureData(t,e,r,i,1)}createTextureData(t,e,r,i,s){m.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(t)}]`);const f=this.session.textureManager.createTextureFromLayout(e,t,r,s);return this.createTextureDataFromTexture(t,e,f,i)}reshapeUnpacked(t,e){const r=this.getOrCreateTextureData(t,n.TextureType.unpacked),i={channels:r.channels,height:r.height,width:r.width,shape:e.length!==0?e:[1],strides:h.ShapeUtil.computeStrides(e),unpackedShape:e};return this.createTextureDataFromTexture(i,t.type,r.texture).tensor}reshapePacked(t,e){const r=this.getOrCreateTextureData(t,n.TextureType.packed);if((0,u.isReshapeCheap)(t.dims,e)){const y={channels:r.channels,height:r.height,width:r.width,shape:e.length!==0?e:[1],strides:h.ShapeUtil.computeStrides(e),unpackedShape:e,isPacked:!0};return this.createTextureDataFromTexture(y,t.type,r.texture).tensor}const i=(0,u.processDims3D)(t.dims),s=(0,u.processDims3D)(e),f=this.reshapePacked(t,i),g=this.run((0,u.createPackedReshape3DProgramInfoLoader)(this,f,s),[f]);return this.reshapePacked(g,e)}cast(t,e){const r=this.getOrCreateTextureData(t,n.TextureType.unpacked);return this.createTextureDataFromTexture(r,e,r.texture).tensor}createTextureDataFromTexture(t,e,r,i,s){const f=Object.assign(Object.assign({},t),{tensor:i||new p.Tensor(t.unpackedShape,e,g=>this.readTexture(f),async g=>this.readTextureAsync(f),void 0,s),texture:r});return this.setTextureData(f.tensor.dataId,f,t.isPacked),f}getTextureData(t,e=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,e):e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,r=!1){this.session.isInitializer(t)?this.session.setTextureData(t,e,r):(r?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,e)}isTextureLayoutCached(t,e=!1){return!!this.getTextureData(t.dataId,e)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,c.encodeAsUint8)(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,c.encodeAsUint8)(this,t))}pack(t){return this.executeProgram((0,d.createPackProgramInfoLoader)(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram((0,a.createUnpackProgramInfoLoader)(this,t.tensor),[t.tensor])}}},4110:function(R,l,b){var m=this&&this.__createBinding||(Object.create?function(K,X,J,tt){tt===void 0&&(tt=J);var nt=Object.getOwnPropertyDescriptor(X,J);nt&&!("get"in nt?!X.__esModule:nt.writable||nt.configurable)||(nt={enumerable:!0,get:function(){return X[J]}}),Object.defineProperty(K,tt,nt)}:function(K,X,J,tt){tt===void 0&&(tt=J),K[tt]=X[J]}),p=this&&this.__setModuleDefault||(Object.create?function(K,X){Object.defineProperty(K,"default",{enumerable:!0,value:X})}:function(K,X){K.default=X}),h=this&&this.__importStar||function(K){if(K&&K.__esModule)return K;var X={};if(K!=null)for(var J in K)J!=="default"&&Object.prototype.hasOwnProperty.call(K,J)&&m(X,K,J);return p(X,K),X};Object.defineProperty(l,"__esModule",{value:!0}),l.WEBGL_OP_RESOLVE_RULES=void 0;const d=b(8817),u=h(b(5194)),c=b(4752),a=b(6668),o=b(9754),n=b(5042),t=b(6742),e=b(4125),r=b(6149),i=b(5378),s=b(6981),f=b(7413),g=b(7006),y=b(8276),v=b(5565),w=b(2834),T=b(1010),x=b(8126),A=b(2801),D=b(565),$=b(2444),j=b(815),M=b(564),S=b(5416),U=b(1240),O=b(5944),E=b(5707),F=h(b(9087)),q=b(7862),H=b(3980);l.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",F.abs],["Acos","","7+",F.acos],["Add","","7+",u.add],["And","","7+",u.and],["Asin","","7+",F.asin],["Atan","","7+",F.atan],["AveragePool","","7+",w.averagePool,w.parseAveragePoolAttributes],["BatchNormalization","","7+",d.batchNormalization,d.parseBatchNormalizationAttributes],["Cast","","6+",c.cast,c.parseCastAttributes],["Ceil","","6+",F.ceil],["Clip","","6-10",F.clip,F.parseClipAttributes],["Clip","","11+",F.clipV11],["Concat","","4+",a.concat,a.parseConcatAttributes],["Conv","","1+",o.conv,o.parseConvAttributes],["ConvTranspose","","1+",n.convTranspose,n.parseConvTransposeAttributes],["Cos","","7+",F.cos],["Div","","7+",u.div],["Dropout","","7+",F.identity],["DepthToSpace","","1+",t.depthToSpace,t.parseDepthToSpaceAttributes],["Equal","","7+",u.equal],["Elu","","6+",F.elu,F.parseEluAttributes],["Exp","","6+",F.exp],["Flatten","","1+",e.flatten,e.parseFlattenAttributes],["Floor","","6+",F.floor],["FusedConv","com.microsoft","1+",o.conv,o.parseConvAttributes],["Gather","","1+",r.gather,r.parseGatherAttributes],["Gemm","","7-10",i.gemm,i.parseGemmAttributesV7],["Gemm","","11+",i.gemm,i.parseGemmAttributesV11],["GlobalAveragePool","","1+",w.globalAveragePool,w.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",w.globalMaxPool],["Greater","","7+",u.greater],["Identity","","1+",F.identity],["ImageScaler","","1+",s.imageScaler,s.parseImageScalerAttributes],["InstanceNormalization","","6+",f.instanceNormalization,f.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",F.leakyRelu,F.parseLeakyReluAttributes],["Less","","7+",u.less],["LRN","","1+",g.lrn,g.parseLrnAttributes],["Log","","6+",F.log],["MatMul","","1+",y.matMul,y.parseMatMulAttributes],["MaxPool","","1+",w.maxPool,w.parseMaxPoolAttributes],["Mul","","7+",u.mul],["Neg","","6+",F.neg],["Not","","1+",F.not],["Or","","7+",u.or],["Pad","","2-10",v.padV2,v.parsePadAttributesV2],["Pad","","11+",v.padV11,v.parsePadAttributesV11],["Pow","","7+",u.pow],["PRelu","","7+",u.pRelu],["ReduceLogSum","","1+",T.reduceLogSum,T.parseReduceAttributes],["ReduceMax","","1+",T.reduceMax,T.parseReduceAttributes],["ReduceMean","","1+",T.reduceMean,T.parseReduceAttributes],["ReduceMin","","1+",T.reduceMin,T.parseReduceAttributes],["ReduceProd","","1+",T.reduceProd,T.parseReduceAttributes],["ReduceSum","","1-12",T.reduceSum,T.parseReduceAttributes],["ReduceSumSquare","","1+",T.reduceLogSumSquare,T.parseReduceAttributes],["Relu","","6+",F.relu],["Reshape","","5+",x.reshape],["Resize","","10",A.resize,A.parseResizeAttributesV10],["Resize","","11+",A.resize,A.parseResizeAttributesV11],["Shape","","1+",D.shape],["Sigmoid","","6+",F.sigmoid],["Sin","","7+",F.sin],["Slice","","10+",$.sliceV10],["Slice","","1-9",$.slice,$.parseSliceAttributes],["Softmax","","1-12",j.softmax,j.parseSoftmaxAttributes],["Softmax","","13+",j.softmaxV13,j.parseSoftmaxAttributesV13],["Split","","2-12",M.split,M.parseSplitAttributes],["Sqrt","","6+",F.sqrt],["Squeeze","","1-12",S.squeeze,S.parseSqueezeAttributes],["Squeeze","","13+",S.squeezeV13],["Sub","","7+",u.sub],["Sum","","6+",U.sum],["Tan","","7+",F.tan],["Tanh","","6+",F.tanh],["Tile","","6+",O.tile],["Transpose","","1+",E.transpose,E.parseTransposeAttributes],["Upsample","","7-8",H.upsample,H.parseUpsampleAttributesV7],["Upsample","","9",H.upsample,H.parseUpsampleAttributesV9],["Unsqueeze","","1-12",q.unsqueeze,q.parseUnsqueezeAttributes],["Unsqueeze","","13+",q.unsqueezeV13],["Xor","","7+",u.xor]]},8817:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseBatchNormalizationAttributes=l.batchNormalization=void 0;const m=b(4910),p=b(6757),h=b(5639),d={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]};l.batchNormalization=(a,o,n)=>(c(o),[a.run(Object.assign(Object.assign({},d),{cacheHint:n.cacheKey,get:()=>u(a,o,n)}),o)]),l.parseBatchNormalizationAttributes=a=>{const o=a.attributes.getFloat("epsilon",1e-5),n=a.attributes.getFloat("momentum",.9),t=a.attributes.getInt("spatial",1);return(0,m.createAttributeWithCacheKey)({epsilon:o,momentum:n,spatial:t})};const u=(a,o,n)=>{const t=(0,p.getGlsl)(a.session.backend.glContext.version),e=o[0].dims.length,[r,i]=a.calculateTextureWidthAndHeight(o[1].dims,h.TextureType.unpacked),s=`
  float process(int[${e}] indices) {
    vec2 position = offsetToCoords(indices[1], ${r}, ${i});
    float scale = getColorAsFloat(${t.texture2D}(Scale, position));
    float mean = getColorAsFloat(${t.texture2D}(Mean, position));
    float variance = getColorAsFloat(${t.texture2D}(Variance, position));
    float b = getColorAsFloat(${t.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},d),{output:{dims:o[0].dims,type:o[0].type,textureType:h.TextureType.unpacked},shaderSource:s})},c=a=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const o=a[0],n=a[1],t=a[2],e=a[3],r=a[4];if(o.dims.length<3||n.dims.length!==1||t.dims.length!==1||e.dims.length!==1||r.dims.length!==1)throw new Error("invalid input shape.");if(n.dims[0]!==o.dims[1]||t.dims[0]!==o.dims[1]||e.dims[0]!==o.dims[1]||r.dims[0]!==o.dims[1])throw new Error("invalid input shape.");if(o.type!=="float32"&&o.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||r.type!=="float32"&&r.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.xor=l.sub=l.pRelu=l.pow=l.or=l.mul=l.less=l.greater=l.equal=l.div=l.and=l.add=l.glslPRelu=l.glslPow=l.glslXor=l.glslOr=l.glslAnd=l.glslLess=l.glslGreater=l.glslEqual=l.glslSub=l.glslMul=l.glslDiv=l.glslAdd=void 0;const m=b(7273),p=b(1997),h=b(6757),d=b(5639);function u(){const w="add_";return{body:`
  float ${w}(float a, float b) {
    return a + b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:w,type:p.FunctionType.ValueBased}}function c(){const w="div_";return{body:`
  float ${w}(float a, float b) {
    return a / b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:w,type:p.FunctionType.ValueBased}}function a(){const w="mul_";return{body:`
  float ${w}(float a, float b) {
    return a * b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:w,type:p.FunctionType.ValueBased}}function o(){const w="sub_";return{body:`
  float ${w}(float a, float b) {
    return a - b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:w,type:p.FunctionType.ValueBased}}function n(){const w="equal_";return{body:`
  float ${w}(float a, float b) {
    return float(a == b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:w,type:p.FunctionType.ValueBased}}function t(){const w="greater_";return{body:`
  float ${w}(float a, float b) {
    return float(a > b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:w,type:p.FunctionType.ValueBased}}function e(){const w="less_";return{body:`
  float ${w}(float a, float b) {
    return float(a < b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:w,type:p.FunctionType.ValueBased}}function r(){const w="and_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:w,type:p.FunctionType.ValueBased}}function i(){const w="or_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:w,type:p.FunctionType.ValueBased}}function s(){const w="xor_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:w,type:p.FunctionType.ValueBased}}function f(){return function(w){const T=`${w}_`;return{body:`
  float ${T}(float a, float b) {
    return ${w}(a, b);
  }
  vec4 ${T}(vec4 v1, vec4 v2) {
    return ${w}(v1, v2);
  }
  `,name:T,type:p.FunctionType.ValueBased}}("pow")}function g(){const w="prelu_";return{body:`
  float ${w}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:w,type:p.FunctionType.ValueBased}}l.glslAdd=u,l.glslDiv=c,l.glslMul=a,l.glslSub=o,l.glslEqual=n,l.glslGreater=t,l.glslLess=e,l.glslAnd=r,l.glslOr=i,l.glslXor=s,l.glslPow=f,l.glslPRelu=g;const y=(w,T,x,A=T[0].type,D)=>{const $=w.session.pack?d.TextureType.packed:d.TextureType.unpacked;return{name:x.name,inputNames:["A","B"],inputTypes:[$,$],cacheHint:D,get:()=>v(w,T,x,A)}},v=(w,T,x,A=T[0].type)=>{const D=w.session.pack?d.TextureType.packed:d.TextureType.unpacked,$=!m.ShapeUtil.areEqual(T[0].dims,T[1].dims);let j=T[0].dims;const M=w.session.pack;if($){const O=m.BroadcastUtil.calcShape(T[0].dims,T[1].dims,!1);if(!O)throw new Error("Can't perform binary op on the given tensors");j=O;const E=j.length,F=T[0].dims.length!==0?T[0].dims.length:1,q=T[1].dims.length!==0?T[1].dims.length:1,H=T[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",K=T[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",X=(0,h.getGlsl)(w.session.backend.glContext.version),J=M?`
      ${x.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${x.name}(a, b);
        ${X.output} = result;
      }`:`
      ${x.body}
      float process(int indices[${E}]) {
        int aindices[${F}];
        int bindices[${q}];
        ${H}
        ${K}
        return ${x.name}(_A(aindices), _B(bindices));
      }`;return{name:x.name,inputNames:["A","B"],inputTypes:[D,D],output:{dims:j,type:A,textureType:D},shaderSource:J,hasMain:M}}const S=(0,h.getGlsl)(w.session.backend.glContext.version),U=`
    ${x.body}
    void main() {
      vec4 v1 = ${S.texture2D}(A, TexCoords);
      vec4 v2 = ${S.texture2D}(B, TexCoords);
      vec4 result = ${x.name}(v1, v2);
      ${S.output} = result;
    }
    `;return{name:x.name,inputNames:["A","B"],inputTypes:[D,D],output:{dims:T[0].dims,type:A,textureType:D},shaderSource:U,hasMain:!0}};l.add=(w,T)=>[w.run(y(w,T,u()),T)],l.and=(w,T)=>[w.run(y(w,T,r(),"bool"),T)],l.div=(w,T)=>[w.run(y(w,T,c()),T)],l.equal=(w,T)=>[w.run(y(w,T,n(),"bool"),T)],l.greater=(w,T)=>[w.run(y(w,T,t(),"bool"),T)],l.less=(w,T)=>[w.run(y(w,T,e(),"bool"),T)],l.mul=(w,T)=>[w.run(y(w,T,a()),T)],l.or=(w,T)=>[w.run(y(w,T,i(),"bool"),T)],l.pow=(w,T)=>[w.run(y(w,T,f()),T)],l.pRelu=(w,T)=>[w.run(y(w,T,g()),T)],l.sub=(w,T)=>[w.run(y(w,T,o()),T)],l.xor=(w,T)=>[w.run(y(w,T,s(),"bool"),T)]},4752:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseCastAttributes=l.cast=void 0;const m=b(7273);l.cast=(h,d,u)=>(p(d),[h.cast(d[0],u)]),l.parseCastAttributes=h=>m.ProtoUtil.tensorDataTypeFromProto(h.attributes.getInt("to"));const p=h=>{if(!h||h.length!==1)throw new Error("Cast requires 1 input.");if(h[0].type==="string")throw new Error("Invalid input type.")}},4595:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createPackedConcatProgramInfoLoader=void 0;const m=b(6757),p=b(5639),h=b(432),d=b(5614);l.createPackedConcatProgramInfoLoader=(c,a,o)=>{const n=(t=a.length,e=o.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:t},(r,i)=>`X${i}`),inputTypes:Array(t).fill(p.TextureType.packed),cacheHint:e});var t,e;return Object.assign(Object.assign({},n),{get:()=>((r,i,s,f)=>{const g=s[0].dims.slice();if(f>=g.length||f<-1*g.length)throw new Error("axis specified for concat doesn't match input dimensionality");f<0&&(f=g.length+f);const y=g.slice(0);for(let H=1;H<s.length;H++){const K=s[H].dims.slice();for(let X=0;X<g.length;X++)if(X===f)y[f]+=K[X];else if(g[X]!==K[X])throw new Error("non concat dimensions must match")}const v=y.length,w=(0,d.getChannels)("coords",v),T=(0,h.getCoordsDataType)(v),x=(0,d.unpackFromChannel)(),A=s.map(H=>H.dims),D=(0,h.getGlChannels)(v),$=new Array(A.length-1);$[0]=A[0][f];for(let H=1;H<$.length;H++)$[H]=$[H-1]+A[H][f];const j=D[f],M=D.slice(-2),S=D.join();let U=`if (${j} < ${$[0]}) {
        return getChannel(
            getX0(${S}), vec2(${M.join()}));
        }`;for(let H=1;H<$.length;H++){const K=$[H-1];U+=`
            if (${j} < ${$[H]}  && ${j} >= ${$[H-1]}) {
              return getChannel(
                getX${H}(${u(D,j,K)}),
                vec2(${u(M,j,K)}));
            }`}const O=$.length,E=$[$.length-1];U+=`
            return getChannel(
              getX${O}(${u(D,j,E)}),
              vec2(${u(M,j,E)}));`;const F=(0,m.getGlsl)(r.session.backend.glContext.version),q=`
          ${x}
          float getValue(${D.map(H=>"int "+H)}) {
            ${U}
          }

          void main() {
            ${T} coords = getOutputCoords();
            int lastDim = coords.${D[v-1]};
            coords.${D[v-1]} = coords.${D[v-2]};
            coords.${D[v-2]} = lastDim;

            vec4 result = vec4(getValue(${w}), 0., 0., 0.);

            ${w[v-1]} = ${w[v-1]} + 1;
            if (${w[v-1]} < ${y[v-1]}) {
              result.g = getValue(${w});
            }

            ${w[v-2]} = ${w[v-2]} + 1;
            if (${w[v-2]} < ${y[v-2]}) {
              result.a = getValue(${w});
            }

            ${w[v-1]} = ${w[v-1]} - 1;
            if (${w[v-2]} < ${y[v-2]} &&
                ${w[v-1]} < ${y[v-1]}) {
              result.b = getValue(${w});
            }
            ${F.output} = result;
          }
        `;return Object.assign(Object.assign({},i),{output:{dims:y,type:s[0].type,textureType:p.TextureType.packed},shaderSource:q,hasMain:!0})})(c,n,a,o.axis)})};const u=(c,a,o)=>{const n=c.indexOf(a);return c.map((t,e)=>e===n?`${t} - ${o}`:t).join()}},6668:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseConcatAttributes=l.concat=void 0;const m=b(4910),p=b(5639),h=b(4595);l.concat=(t,e,r)=>(n(e),t.session.pack&&e[0].dims.length>1?[t.run((0,h.createPackedConcatProgramInfoLoader)(t,e,r),e)]:[t.run(d(t,e,r),e)]);const d=(t,e,r)=>{const i=(s=e.length,f=r.cacheKey,{name:"Concat",inputNames:Array.from({length:s},(g,y)=>`X${y}`),inputTypes:Array(s).fill(p.TextureType.unpacked),cacheHint:f});var s,f;return Object.assign(Object.assign({},i),{get:()=>((g,y,v,w)=>{const T=v[0].dims.slice();if(w>=T.length||w<-1*T.length)throw new Error("axis specified for concat doesn't match input dimensionality");w<0&&(w=T.length+w);const x=T.slice(0);for(let S=1;S<v.length;S++){const U=v[S].dims.slice();for(let O=0;O<T.length;O++)if(O===w)x[w]+=U[O];else if(T[O]!==U[O])throw new Error("non concat dimensions must match")}const A=x.length,D=new Array(v.length);let $=0;for(let S=0;S<D.length;++S)$+=v[S].dims[w],D[S]=$;let j="";j=v.length<5?u(D):c(D);const M=`
        ${a(v.length,A)}
        ${o(D)}
        ${j}
        float process(int indices[${A}]) {
          int textureIndex = getTextureWhereDataResides (indices[${w}]);

          if(textureIndex != 0) {
            indices[${w}] = indices[${w}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},y),{output:{dims:x,type:v[0].type,textureType:p.TextureType.unpacked},shaderSource:M})})(0,i,e,r.axis)})},u=t=>`int getTextureWhereDataResides(int index) {
      ${t.map((e,r)=>`if(index<${e}) {return ${r};}
`).join("")}
    }`,c=t=>u(t),a=(t,e)=>{const r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let i=0;i<t;++i)i===0?r.push(`	if (textureIndex == ${i}) { return _X${i}(indices); }`):i===t-1?r.push(`	else { return _X${i}(indices); }`):r.push(`	else if (textureIndex == ${i}) { return _X${i}(indices); }`);return r.push("	}"),r.join(`
`)},o=t=>{const e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<t.length;++r)r===0?e.push(`	if (index == ${r}) { return ${t[r]}; }`):r===t.length-1?e.push(`	else { return ${t[r]}; }`):e.push(`	else if (index == ${r}) { return ${t[r]}; }`);return e.push("	}"),e.join(`
`)};l.parseConcatAttributes=t=>(0,m.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis")});const n=t=>{if(!t||t.length<1)throw new Error("too few inputs");const e=t[0].type,r=t[0].dims.length;if(e==="string")throw new Error("string tensor is not supported yet");for(const i of t){if(i.type!==e)throw new Error("input tensors should be one type");if(i.dims.length!==r)throw new Error("input tensors should have the same shape")}}},7825:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createUnpackedGroupedConvProgramInfoLoader=void 0;const m=b(1315),p=b(6757),h=b(5639),d=b(9754),u=b(2150);l.createUnpackedGroupedConvProgramInfoLoader=(c,a,o)=>{const n=(t=a.length>2,e=o.cacheKey,{name:"GroupedConv",inputNames:t?["X","W","Bias"]:["X","W"],inputTypes:t?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:e});var t,e;return Object.assign(Object.assign({},n),{get:()=>((r,i,s,f)=>{const g=i.length>2?"value += getBias(output_channel);":"",y=i[0].dims.slice(),v=i[1].dims.slice(),w=v[0]/f.group;m.Logger.verbose("GroupedConv",`autpPad:${f.autoPad}, dilations:${f.dilations}, group:${f.group}, kernelShape:${f.kernelShape}, pads:${f.pads}, strides:${f.strides}`);const T=(0,d.calculateOutputShape)(y,v,f.dilations,f.pads,f.strides),x=(0,p.getGlsl)(r.session.backend.glContext.version),{activationFunction:A,applyActivation:D}=(0,u.getActivationSnippet)(f),$=`
  const ivec2 strides = ivec2(${f.strides[0]}, ${f.strides[1]});
  const ivec2 pads = ivec2(${f.pads[0]}, ${f.pads[1]});
  ${A}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${w};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${v[1]}; wInChannel++) {
      int input_channel = group_id * ${v[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${v[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${f.dilations[0]};

        if (xHeight < 0 || xHeight >= ${y[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${v[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${f.dilations[1]};
          if (xWidth < 0 || xWidth >= ${y[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${g}
    ${D}
    ${x.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},s),{output:{dims:T,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:$,hasMain:!0})})(c,a,n,o)})}},7708:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.conv2DPacked=l.conv2DPackedPointwise=void 0;const m=b(9754),p=b(5950),h=b(5632);l.conv2DPackedPointwise=(d,u,c)=>{const a=u[0].dims,o=u[1].dims,n=(0,m.calculateOutputShape)(a,o,c.dilations,c.pads,c.strides),t=d.reshapePacked(u[0],[a[1],a[2]*a[3]]),e=d.reshapePacked(u[1],[o[0],o[1]]),r=u.length>2?[e,t,u[2]]:[e,t],i=d.run((0,h.createPackedMatmulProgramInfoLoader)(d,r,c),r);return d.reshapePacked(i,n)},l.conv2DPacked=(d,u,c)=>{const a=u[0].dims,o=u[1].dims,n=(0,m.calculateOutputShape)(a,o,c.dilations,c.pads,c.strides),t=d.run((0,p.createPackedIm2ColProgramInfoLoader)(d,u[0],u[1],n,c),[u[0]]),e=d.reshapePacked(u[1],[o[0],o[1]*o[2]*o[3]]),r=u.length===3?[e,t,u[2]]:[e,t],i=d.run((0,h.createPackedMatmulProgramInfoLoader)(d,r,c),r);return d.reshapePacked(i,n)}},5042:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseConvTransposeAttributes=l.convTranspose=void 0;const m=b(4910),p=b(6757),h=b(5639),d=b(2150),u=(e,r,i,s,f,g)=>(e-1)*r+i+(s-1)*f+1-g,c=(e,r,i,s,f)=>{const g=Math.floor(e/2);r==="SAME_UPPER"?(i[s]=g,i[f]=e-g):r==="SAME_LOWER"&&(i[s]=e-g,i[f]=g)};l.convTranspose=(e,r,i)=>(t(r,i),a(e,r,i));const a=(e,r,i)=>{const s=n(i,r);return[o(e,r,s)]},o=(e,r,i)=>e.run(((s,f,g)=>{const y=(v=f.length>2,w=g.cacheKey,{name:"ConvTranspose",inputNames:v?["X","W","B"]:["X","W"],inputTypes:v?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:w});var v,w;return Object.assign(Object.assign({},y),{get:()=>((T,x,A,D)=>{const $=x.length>2?"getB(output_channel)":"0.0",j=x[0].dims,M=x[1].dims,S=M[1],U=M[0]/D.group,O=[x[0].dims[0],x[1].dims[1]*D.group,...D.outputShape],E=(0,p.getGlsl)(T.session.backend.glContext.version),{activationFunction:F,applyActivation:q}=(0,d.getActivationSnippet)(D),H=`
  const ivec2 strides = ivec2(${D.strides[0]}, ${D.strides[1]});
  const ivec2 pads = ivec2(${D.pads[0]}, ${D.pads[1]});
  ${F}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${S};
    int wOutChannel = output_channel - group_id * ${S};

    float value = ${$};
    for (int inChannelOffset = 0; inChannelOffset < ${U}; inChannelOffset++) {
      int input_channel = group_id * ${U} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${M[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${M[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${D.dilations[0]}, wHOff * ${D.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${j[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${j[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${q}
    ${E.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},A),{output:{dims:O,type:x[0].type,textureType:h.TextureType.unpacked},shaderSource:H,hasMain:!0})})(s,f,y,g)})})(e,r,i),r),n=(e,r)=>{const i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let y=2;y<r[1].dims.length;++y)i.push(r[1].dims[y]);const s=e.pads.slice(),f=e.outputShape.slice();((y,v,w,T,x,A,D,$)=>{const j=y.length-2,M=$.length===0;for(let S=0;S<j;++S){const U=M?y[S+2]*A[S]:$[S],O=u(y[S+2],A[S],x[S],v[S],w[S],U);c(O,T,x,S,S+j),M&&$.push(A[S]*(y[S+2]-1)+D[S]+(v[S]-1)*w[S]+1-x[S]-x[S+j])}})(r[0].dims,i,e.dilations,e.autoPad,s,e.strides,e.outputPadding,f);const g=Object.assign({},e);return Object.assign(g,{kernelShape:i,pads:s,outputShape:f,cacheKey:e.cacheKey}),g};l.parseConvTransposeAttributes=e=>{const r=e.attributes,i=(0,d.parseInternalActivationAttributes)(r),s=r.getString("auto_pad","NOTSET"),f=r.getInts("dilations",[1,1]),g=r.getInt("group",1),y=r.getInts("kernel_shape",[]),v=r.getInts("output_padding",[0,0]),w=r.getInts("output_shape",[]),T=r.getInts("pads",[0,0,0,0]),x=r.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:s,dilations:f,group:g,kernelShape:y,outputPadding:v,outputShape:w,pads:T,strides:x},i))};const t=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const i=e[1].dims[1]*r.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");const s=e[0].dims.length-2;if(r.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(r.strides.length!==s)throw new Error(`strides should be ${s}D`);if(r.pads.length!==2*s)throw new Error(`pads should be ${2*s}D`);if(r.outputPadding.length!==s)throw new Error(`output_padding should be ${s}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseConvAttributes=l.conv=l.calculateOutputShape=void 0;const m=b(4910),p=b(7273),h=b(7825),d=b(7708),u=b(3281),c=b(2150),a=b(1625),o=b(8276);l.calculateOutputShape=(s,f,g,y,v)=>{const w=s[0],T=s.slice(2),x=T.length,A=f[0],D=f.slice(2).map((j,M)=>j+(j-1)*(g[M]-1)),$=T.map((j,M)=>j+y[M]+y[M+x]).map((j,M)=>Math.floor((j-D[M]+v[M])/v[M]));return[w,A].concat(...$)},l.conv=(s,f,g)=>(i(f,g),n(s,f,g));const n=(s,f,g)=>{const y=r(g,f),v=s.session.pack,w=y.kernelShape[0]===1&&y.kernelShape[1]===1;return y.group>1?[s.run((0,h.createUnpackedGroupedConvProgramInfoLoader)(s,f,y),f)]:w&&v?[t(s,f,y)]:v&&f[0].dims.length===4&&f[0].dims[0]===1&&!w?[(0,d.conv2DPacked)(s,f,y)]:[e(s,f,y)]},t=(s,f,g)=>{const y=f[0].dims,v=f[1].dims,w=(0,l.calculateOutputShape)(y,v,g.dilations,g.pads,g.strides),T=s.reshapeUnpacked(f[0],[y[1],y[2]*y[3]]),x=s.reshapeUnpacked(f[1],[v[0],v[1]]),A=f.length>2?[x,T,f[2]]:[x,T],D=s.run((0,o.createMatmulProgramInfoLoader)(A,g),A);return s.reshapeUnpacked(D,w)},e=(s,f,g)=>{const y=f[0].dims,v=f[1].dims,w=(0,l.calculateOutputShape)(y,v,g.dilations,g.pads,g.strides),T=s.run((0,a.createIm2ColProgramInfoLoader)(s,f[0],f[1],w,g),[f[0]]),x=f.length===3?[T,f[1],f[2]]:[T,f[1]];return s.run((0,u.createDotProductProgramInfoLoader)(s,f,w,g),x)},r=(s,f)=>{const g=s.kernelShape.slice();if(s.kernelShape.length===0)for(let w=2;w<f[1].dims.length;++w)g.push(f[1].dims[w]);const y=s.pads.slice();p.PoolConvUtil.adjustPadsBasedOnAutoPad(f[0].dims,s.strides,s.dilations,g,y,s.autoPad);const v=Object.assign({},s);return Object.assign(v,{kernelShape:g,pads:y,cacheKey:s.cacheKey}),v};l.parseConvAttributes=s=>{const f=s.attributes,g=(0,c.parseInternalActivationAttributes)(f),y=f.getString("auto_pad","NOTSET"),v=f.getInts("dilations",[1,1]),w=f.getInt("group",1),T=f.getInts("kernel_shape",[]),x=f.getInts("pads",[0,0,0,0]),A=f.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:y,dilations:v,group:w,kernelShape:T,pads:x,strides:A},g))};const i=(s,f)=>{if(!s||s.length!==2&&s.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(s[0].dims.length!==4||s[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(s[0].dims[1]!==s[1].dims[1]*f.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(s.length===3&&(s[2].dims.length!==1||s[1].dims[0]!==s[2].dims[0]))throw new Error("invalid bias");const g=s[0].dims.length-2;if(f.dilations.length!==g)throw new Error(`dilations should be ${g}D`);if(f.strides.length!==g)throw new Error(`strides should be ${g}D`);if(f.pads.length!==2*g)throw new Error(`pads should be ${2*g}D`);if(f.kernelShape.length!==0&&f.kernelShape.length!==s[1].dims.length-2)throw new Error("invalid kernel shape");if(s[0].type!=="float32"||s[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(s.length===3&&s[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseDepthToSpaceAttributes=l.depthToSpace=void 0;const m=b(5707);l.depthToSpace=(h,d,u)=>{p(d);const c=u.blocksize,a=c*c,o=u.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],n=u.mode==="DCR"?[d[0].dims[0],c,c,d[0].dims[1]/a,d[0].dims[2],d[0].dims[3]]:[d[0].dims[0],d[0].dims[1]/a,c,c,d[0].dims[2],d[0].dims[3]],t=h.reshapeUnpacked(d[0],n),e={perm:o,cacheKey:`${o}`},[r]=(0,m.transpose)(h,[t],e),i=[d[0].dims[0],d[0].dims[1]/a,d[0].dims[2]*c,d[0].dims[3]*c];return[h.reshapeUnpacked(r,i)]},l.parseDepthToSpaceAttributes=h=>{const d=h.attributes.getInt("blocksize");if(d<1)throw new Error(`blocksize must be >= 1, but got : ${d} for DepthToSpace`);const u=h.attributes.getString("mode","DCR");if(u!=="DCR"&&u!=="CRD")throw new Error(`unrecognized mode: ${u} for DepthToSpace`);return{mode:u,blocksize:d}};const p=h=>{if(h.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${h.length}`);if(h[0].type==="string"||h[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createDotProductProgramInfoLoader=void 0;const m=b(7273),p=b(6757),h=b(5639),d=b(2150),u=b(1625);l.createDotProductProgramInfoLoader=(c,a,o,n)=>{const t=((e,r)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[h.TextureType.unpacked,h.TextureType.packedLastDimension,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.packedLastDimension],cacheKey:r.activationCacheKey}))(a.length>2,n);return Object.assign(Object.assign({},t),{get:()=>((e,r,i,s,f)=>{const g=i[0].dims,y=i[1].dims,v=[y[0],Math.ceil(g[1]*y[2]*y[3]/4)],w=(0,u.calculateIm2ColDims)(g,y,s),[T,x]=e.calculateTextureWidthAndHeight(v,h.TextureType.packedLastDimension),A=m.ShapeUtil.computeStrides(w),[D,$]=e.calculateTextureWidthAndHeight(w,h.TextureType.packedLastDimension),j=s.length,M=i.length<3?"0.0":"_B(b)",S=Math.ceil(g[1]*y[2]*y[3]/4),{activationFunction:U,applyActivation:O}=(0,d.getActivationSnippet)(f),E=(0,p.getGlsl)(e.session.backend.glContext.version),F=`
${U}
float process(int indices[${j}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${A[0]} + im2col[1] * ${A[1]} + im2col[2] * ${A[2]};
  int kernelOffset = indices[1] * ${v[1]};
  float value = ${M};
  for (int i = 0; i < ${S}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${D}, ${$});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${T}, ${x});
    value += dot(${E.texture2D}(Im2Col, im2colCoords), ${E.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${O}
  return value;
}`;return Object.assign(Object.assign({},r),{output:{dims:s,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:F})})(c,t,a,o,n)})}},4125:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseFlattenAttributes=l.flatten=void 0;const m=b(7273);l.flatten=(h,d,u)=>{p(d,u);const c=m.ShapeUtil.flattenShape(d[0].dims,u);return[h.reshapeUnpacked(d[0],c)]},l.parseFlattenAttributes=h=>h.attributes.getInt("axis",1);const p=(h,d)=>{if(!h||h.length!==1)throw new Error("Flatten requires 1 input.");const u=h[0].dims.length;if(u===0)throw new Error("scalar tensor is not supported.");if(d<-u||d>u)throw new Error("Invalid axis");if(h[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseInternalActivationAttributes=l.getActivationSnippet=void 0;const m=b(7273),p=b(9087);l.getActivationSnippet=function(h){let d;switch(h.activation){case"Relu":d=(0,p.glslRelu)();break;case"Sigmoid":d=(0,p.glslSigmoid)();break;case"Clip":d=(0,p.glslClip)(h.clipMin,h.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const u=d.name;return{activationFunction:d.body,applyActivation:`value = ${u}_(value);`}},l.parseInternalActivationAttributes=h=>{const d=h.getString("activation","");if(d==="Clip"){const[u,c]=h.getFloats("activation_params",[m.MIN_CLIP,m.MAX_CLIP]);return{activation:d,clipMax:c,clipMin:u,activationCacheKey:`${d}:${u},${c}`}}return{activation:d,activationCacheKey:d}}},6149:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseGatherAttributes=l.gather=void 0;const m=b(4910),p=b(6145),h=b(7273),d=b(5639);l.gather=(o,n,t)=>(a(n,t.axis),[o.run(c(o,n,t),n)]),l.parseGatherAttributes=o=>(0,m.createAttributeWithCacheKey)({axis:o.attributes.getInt("axis",0)});const u={name:"Gather",inputNames:["A","B"],inputTypes:[d.TextureType.unpacked,d.TextureType.unpacked]},c=(o,n,t)=>{const e=Object.assign(Object.assign({},u),{cacheHint:t.cacheKey});return Object.assign(Object.assign({},e),{get:()=>((r,i,s,f)=>{const g=s[0].dims.slice(),y=s[1].dims.slice(),v=new Array(g.length+y.length-1);f=h.ShapeUtil.normalizeAxis(f,g.length);const w=[];for(let x=0;x<v.length;x++)x<f?(v[x]=g[x],w.push(`inputIdx[${x}] = outputIdx[${x}];`)):x<f+y.length?(v[x]=y[x-f],w.push(`indexDataIdx[${x-f}] = outputIdx[${x}];`)):(v[x]=g[x-y.length+1],w.push(`inputIdx[${x-y.length+1}] = outputIdx[${x}];`));const T=`
      float process(int outputIdx[${v.length||1}]) {
        int inputIdx[${g.length}];
        int indexDataIdx[${y.length||1}];
        indexDataIdx[0] = 0;
        ${w.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${f}] = idx < 0 ? idx + ${g[f]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},i),{output:{dims:v,type:s[0].type,textureType:d.TextureType.unpacked},shaderSource:T})})(0,e,n,t.axis)})},a=(o,n)=>{if(!o||o.length!==2)throw new Error("Gather requires 2 inputs.");const t=o[0].dims.length;if(t<1)throw new Error("Invalid input shape.");if(n<-t||n>t-1)throw new Error("Invalid axis.");if(p.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invaid input type.");if(o[1].type!=="int32"&&o[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseGemmAttributesV11=l.parseGemmAttributesV7=l.gemm=void 0;const m=b(4910),p=b(7273),h=b(5639);l.gemm=(o,n,t)=>(a(n,t),[o.run(u(n,t),n)]);const d=(o,n)=>{const t=o.attributes.getInt("transA",0)!==0,e=o.attributes.getInt("transB",0)!==0,r=o.attributes.getFloat("alpha",1),i=o.attributes.getFloat("beta",1);return(0,m.createAttributeWithCacheKey)({transA:t,transB:e,alpha:r,beta:i,isOptionalC:n})};l.parseGemmAttributesV7=o=>d(o,!1),l.parseGemmAttributesV11=o=>d(o,!0);const u=(o,n)=>{const t={name:"Gemm",inputNames:o.length===3?["A","B","C"]:["A","B"],inputTypes:o.length===3?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],key:n.cacheKey};return Object.assign(Object.assign({},t),{get:()=>c(t,o,n)})},c=(o,n,t)=>{const e=n[0].dims.slice(),r=n[1].dims.slice(),[i,s]=p.GemmUtil.getShapeOfGemmResult(e,t.transA,r,t.transB,n.length===3?n[2].dims:void 0),f=[i,s];if(!f)throw new Error("Can't use gemm on the given tensors");let g=e[e.length-1],y="";t.transA&&(g=e[0]),t.transA&&t.transB?y="value += _A_T(a) * _B_T(b);":t.transA&&!t.transB?y="value += _A_T(a) * _B(b);":!t.transA&&t.transB?y="value += _A(a) * _B_T(b);":t.transA||t.transB||(y="value += _A(a) * _B(b);");const v=f.length,w=`
      float process(int indices[${v}]) {
          int a[${v}];
          int b[${v}];
          ${n.length===3?`int c[${n[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${n.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${g}; ++k) {
              a[${v-1}] = k;
              b[${v-2}] = k;
              ${y}
          }

          value = value * alpha;
          ${n.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},o),{output:{dims:f,type:n[0].type,textureType:h.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:t.alpha},{name:"beta",type:"float",data:t.beta}],shaderSource:w})},a=(o,n)=>{if(!o)throw new Error("Input is missing");if(n.isOptionalC&&(o.length<2||o.length>3))throw new Error("Invaid input shape.");if(!n.isOptionalC&&o.length!==3)throw new Error("Gemm requires 3 inputs");if(o.length===3&&o[2].dims.length!==1&&o[2].dims.length!==2)throw new Error("Invalid input shape of C");if(o[0].type!=="float32"&&o[0].type!=="float64"||o[1].type!=="float32"&&o[1].type!=="float64"||o.length===3&&o[2].type!=="float32"&&o[2].type!=="float64")throw new Error("Invalid input type.");if(o[0].type!==o[1].type||o.length===3&&o[0].type!==o[2].type)throw new Error("Input types are mismatched")}},5950:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createPackedIm2ColProgramInfoLoader=void 0;const m=b(6757),p=b(5639),h=b(5614);l.createPackedIm2ColProgramInfoLoader=(d,u,c,a,o)=>{const n=(t=o.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[p.TextureType.packed],cacheHint:t});var t;return Object.assign(Object.assign({},n),{get:()=>((e,r,i,s,f,g)=>{const y=i.dims,v=s.dims,w=f.length,T=[v[1]*v[2]*v[3],f[2]*f[3]],x=v[2]*v[3],A=(0,h.unpackFromChannel)(),D=(0,m.getGlsl)(e.session.backend.glContext.version);let $="";for(let M=0;M<=1;M++)for(let S=0;S<=1;S++)$+=`
            blockIndex = rc.x + ${S};
            pos = rc.y + ${M};

            if(blockIndex < ${T[1]} && pos < ${T[0]}) {
              offsetY = int(blockIndex / (${f[w-1]})) * ${g.strides[0]} -
                ${g.pads[0]};
              d0 = offsetY + ${g.dilations[0]} * (imod(pos, ${x}) / ${v[2]});

              if(d0 < ${y[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${f[w-1]}) * ${g.strides[1]} -
                  ${g.pads[1]};
                d1 = offsetX + ${g.dilations[1]} * imod(imod(pos, ${x}), ${v[2]});

                if(d1 < ${y[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${x}.);
                    innerDims = vec2(d0, d1);
                    result[${2*M+S}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const j=`
      ${A}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${$}
          ${D.output} = result;
      }
            `;return Object.assign(Object.assign({},r),{output:{dims:T,type:i.type,textureType:p.TextureType.packed},shaderSource:j,hasMain:!0})})(d,n,u,c,a,o)})}},1625:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.calculateIm2ColDims=l.createIm2ColProgramInfoLoader=void 0;const m=b(5639);l.createIm2ColProgramInfoLoader=(p,h,d,u,c)=>{const a=(o=c.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[m.TextureType.unpacked],cacheHint:o});var o;return Object.assign(Object.assign({},a),{get:()=>((n,t,e,r,i,s)=>{const f=e.dims,g=r.dims,y=i.length,v=(0,l.calculateIm2ColDims)(f,g,i,4),w=`
        const int XC = ${f[1]};
        const int XH = ${f[2]};
        const int XW = ${f[3]};
        const int KH = ${s.kernelShape[0]};
        const int KW = ${s.kernelShape[1]};
        const int dilationH = ${s.dilations[0]};
        const int dilationW = ${s.dilations[1]};
        const int strideH = ${s.strides[0]};
        const int strideW = ${s.strides[1]};
        const int padH = ${s.pads[0]};
        const int padW = ${s.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${y}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${f.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},t),{output:{dims:v,type:e.type,textureType:m.TextureType.packedLastDimension},shaderSource:w})})(0,a,h,d,u,c)})},l.calculateIm2ColDims=(p,h,d,u=4)=>[d[0],d[2],d[3],Math.ceil(p[1]*h[2]*h[3]/u)]},6981:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseImageScalerAttributes=l.imageScaler=void 0;const m=b(4910),p=b(5639);l.imageScaler=(a,o,n)=>(c(o),[a.run(d(a,o,n),o)]),l.parseImageScalerAttributes=a=>{const o=a.attributes.getFloat("scale"),n=a.attributes.getFloats("bias");return(0,m.createAttributeWithCacheKey)({scale:o,bias:n})};const h={name:"ImageScaler",inputNames:["X"],inputTypes:[p.TextureType.unpacked]},d=(a,o,n)=>{const t=Object.assign(Object.assign({},h),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},t),{get:()=>((e,r,i,s)=>{const f=i[0].dims.slice(),g=f.length,y=`
      ${u(s.bias.length)}
      float process(int indices[${g}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},r),{output:{dims:f,type:i[0].type,textureType:p.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:s.bias.length,data:s.bias},{name:"scale",type:"float",data:s.scale}],shaderSource:y})})(0,t,o,n)})},u=a=>{const o=[`float getBias(float bias[${a}], int channel) {`];for(let n=0;n<a;++n)n===0?o.push(`	if (channel == ${n}) { return bias[${n}]; }`):n===a-1?o.push(`	else { return bias[${n}]; }`):o.push(`	else if (channel == ${n}) { return bias[${n}]; }`);return o.push("	}"),o.join(`
`)},c=a=>{if(!a||a.length!==1)throw new Error("ImageScaler requires 1 input.");if(a[0].dims.length!==4)throw new Error("Invalid input shape.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseInstanceNormalizationAttributes=l.instanceNormalization=void 0;const m=b(6757),p=b(5639);l.instanceNormalization=(o,n,t)=>{a(n);const e=o.run(d(n[0]),n);return[o.run(c(o,n[0],t,e.dims),[n[0],e,n[1],n[2]])]},l.parseInstanceNormalizationAttributes=o=>o.attributes.getFloat("epsilon",1e-5);const h={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[p.TextureType.unpacked]},d=o=>Object.assign(Object.assign({},h),{get:()=>((n,t)=>{const e=t.dims.slice(),r=e[1],i=e[2]*e[3],s=[e[0],r],f=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${e[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${e[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i});
        temp = 0.0;
        for(int a2=0; a2<${e[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${e[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i});

        return v;
      }`;return Object.assign(Object.assign({},n),{output:{dims:s,type:t.type,textureType:p.TextureType.packedLastDimension},shaderSource:f})})(h,o)}),u={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[p.TextureType.unpacked,p.TextureType.packedLastDimension,p.TextureType.unpacked,p.TextureType.unpacked]},c=(o,n,t,e)=>{const r=Object.assign(Object.assign({},u),{cacheHint:`${t}`});return Object.assign(Object.assign({},r),{get:()=>((i,s,f,g,y)=>{const v=(0,m.getGlsl)(i.session.backend.glContext.version),[w,T]=i.calculateTextureWidthAndHeight(y,p.TextureType.packedLastDimension),[x,A]=[w/4,T],D=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${x}, ${A});
        return ${v.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},s),{output:{dims:f.dims,type:f.type,textureType:p.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:g}],shaderSource:D})})(o,r,n,t,e)})},a=o=>{if(!o||o.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const n=o[0],t=o[1],e=o[2];if(n.dims.length<3||t.dims.length!==1||e.dims.length!==1)throw new Error("Invalid input shape.");if(t.dims[0]!==n.dims[1]||e.dims[0]!==n.dims[1])throw new Error("Input shapes are mismatched.");if(n.type!=="float32"&&n.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||e.type!=="float32"&&e.type!=="float64")throw new Error("Invalid input type.");if(o[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createLrnProgramInfoLoader=l.parseLrnAttributes=l.lrn=void 0;const m=b(4910),p=b(5639);l.lrn=(c,a,o)=>(u(a),[c.run(d(a,o),a)]),l.parseLrnAttributes=c=>{const a=c.attributes.getFloat("alpha",1e-4),o=c.attributes.getFloat("beta",.75),n=c.attributes.getFloat("bias",1),t=c.attributes.getInt("size");return(0,m.createAttributeWithCacheKey)({alpha:a,beta:o,bias:n,size:t})};const h={name:"LRN",inputNames:["X"],inputTypes:[p.TextureType.unpacked]};function d(c,a){return Object.assign(Object.assign({},h),{cacheHint:a.cacheKey,get:()=>function(o,n){const t=o[0].dims[1],e=o[0].dims.length,r=-Math.floor((n.size-1)/2),i=Math.ceil((n.size-1)/2),s=`float(${n.alpha}) / float(${n.size})`,f=`
    float process(int indices[${e}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${r}; i <= ${i}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${t}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${n.bias}) + ${s} * square_sum, float(${n.beta}));
    }`;return Object.assign(Object.assign({},h),{cacheHint:n.cacheKey,output:{dims:o[0].dims,type:o[0].type,textureType:p.TextureType.unpacked},shaderSource:f})}(c,a)})}l.createLrnProgramInfoLoader=d;const u=c=>{if(!c||c.length!==1)throw new Error("LRN requires 1 input.");if(c[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(c[0].type!=="float32")throw new Error("input should be float type")}},5632:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createPackedMatmulProgramInfoLoader=void 0;const m=b(7273),p=b(6757),h=b(5639),d=b(432),u=b(2150),c=b(8276);l.createPackedMatmulProgramInfoLoader=(a,o,n)=>{const t=(e=o.length>2,r=n.activationCacheKey,{name:"MatMul (packed)",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[h.TextureType.packed,h.TextureType.packed,h.TextureType.packed]:[h.TextureType.packed,h.TextureType.packed],cacheHint:r});var e,r;return Object.assign(Object.assign({},t),{get:()=>((i,s,f,g)=>{const y=f.length>2,v=y?"value += getBiasForMatmul();":"",w=f[0].dims,T=f[1].dims,x=m.BroadcastUtil.calcShape(w,T,!0),A=!m.ShapeUtil.areEqual(f[0].dims,f[1].dims);if(!x)throw new Error("Can't use matmul on the given tensors");const D=w[w.length-1],$=Math.ceil(D/2),j=w.length,M=T.length,S=(0,p.getGlsl)(i.session.backend.glContext.version),U=(0,d.getCoordsDataType)(x.length),O=x.length,E=(0,d.getGlChannels)(),{activationFunction:F,applyActivation:q}=(0,u.getActivationSnippet)(g),H=y?`${(0,c.getBiasForMatmul)(U,E,f[2].dims,x,!0)}`:"",K=A?`${function(nt,rt,it,ut){let gt=[],xt=[];const kt=it[0].dims,mt=it[1].dims,Dt=kt.length,lt=mt.length,bt=ut.length,St=bt-Dt,_t=bt-lt;gt=kt.map((Ot,Ft)=>`coords.${rt[Ft+St]}`),gt[Dt-1]="i*2",gt.join(", "),xt=mt.map((Ot,Ft)=>`coords.${rt[Ft+_t]}`),xt[lt-2]="i*2",xt.join(", ");const At=m.BroadcastUtil.getBroadcastDims(kt,ut),Et=m.BroadcastUtil.getBroadcastDims(mt,ut),Pt=At.map(Ot=>`coords.${rt[Ot+St]} = 0;`).join(`
`),Ct=Et.map(Ot=>`coords.${rt[Ot+_t]} = 0;`).join(`
`),Lt=`int lastDim = coords.${rt[bt-1]};
  coords.${rt[bt-1]} = coords.${rt[bt-2]};
  coords.${rt[bt-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${nt} coords = getOutputCoords();
  ${Lt}
  ${Pt}
  vec4 outputValue = getA(${gt});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${nt} coords = getOutputCoords();
  ${Lt}
  ${Ct}
  vec4 outputValue = getB(${xt});
  return outputValue;
}`}(U,E,f,x)}`:"",X=A?"getAAtOutCoordsMatmul(i)":`getA(${function(nt,rt){let it="";for(let ut=0;ut<rt-2;ut++)it+=`rc.${nt[ut]}, `;return it+=`rc.${nt[rt-2]}, i*2`,it}(E,j)})`,J=A?"getBAtOutCoordsMatmul(i)":`getB(${function(nt,rt){let it="";for(let ut=0;ut<rt-2;ut++)it+=`rc.${nt[ut]}, `;return it+=`i*2, rc.${nt[rt-1]}`,it}(E,M)})`,tt=`
            ${K}
            ${H}
            ${F}
            void main() {
              ${A?"":`${U} rc =
          getOutputCoords(); int lastDim = rc.${E[O-1]}; rc.${E[O-1]} =
          rc.${E[O-2]}; rc.${E[O-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${$}; i++) {
                vec4 a = ${X};
                vec4 b = ${J};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${v}
              ${q}
              ${S.output} = value;
            }`;return Object.assign(Object.assign({},s),{output:{dims:x,type:f[0].type,textureType:h.TextureType.packed},shaderSource:tt,hasMain:!0})})(a,t,o,n)})}},8276:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.getBiasForMatmul=l.createMatmulProgramInfoLoader=l.parseMatMulAttributes=l.matMul=void 0;const m=b(7273),p=b(5639),h=b(432),d=b(2150),u=b(5632);l.matMul=(t,e,r)=>(o(e),t.session.pack?[t.run((0,u.createPackedMatmulProgramInfoLoader)(t,e,r),e)]:[t.run(a(e,r),e)]),l.parseMatMulAttributes=t=>(0,d.parseInternalActivationAttributes)(t.attributes);const c=(t,e)=>({name:"MatMul",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[p.TextureType.unpacked,p.TextureType.unpacked,p.TextureType.unpacked]:[p.TextureType.unpacked,p.TextureType.unpacked],cacheHint:e});function a(t,e){const r=c(t.length>2,e.activationCacheKey);return Object.assign(Object.assign({},r),{get:()=>function(i,s,f){const g=s[0].dims,y=s[1].dims,v=m.BroadcastUtil.calcShape(g,y,!0);if(!v)throw new Error("Can't use matmul on the given tensors");const w=(0,h.getCoordsDataType)(v.length),T=(0,h.getGlChannels)(),{activationFunction:x,applyActivation:A}=(0,d.getActivationSnippet)(f),D=s.length>2,$=D?"value += getBiasForMatmul();":"",j=D?`${n(w,T,s[2].dims,v,!1)}`:"",M=v.length,S=g.length,U=y.length,O=`
    ${x}
    ${j}
    float process(int indices[${M}]) {
        int a[${S}];
        int b[${U}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${g[g.length-1]}; ++k) {
            a[${S-1}] = k;
            b[${U-2}] = k;
            value += _A(a) * _B(b);
        }
        ${$}
        ${A}
        return value;
    }`;return Object.assign(Object.assign({},i),{output:{dims:v,type:s[0].type,textureType:p.TextureType.unpacked},shaderSource:O})}(r,t,e)})}l.createMatmulProgramInfoLoader=a;const o=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.");if(t[0].type!=="float32"&&t[0].type!=="float64"||t[1].type!=="float32"&&t[1].type!=="float64")throw new Error("inputs should be float type");if(t[0].type!==t[1].type)throw new Error("inputs types should match")};function n(t,e,r,i,s){let f="";const g=r.length,y=i.length,v=y-g;f=y<2&&g>0?"coords":r.map((x,A)=>`coords.${e[A+v]}`).join(", ");const w=m.BroadcastUtil.getBroadcastDims(r,i).map(x=>`coords.${e[x+v]} = 0;`).join(`
`);let T="vec4(outputValue.xx, outputValue.yy)";return m.ShapeUtil.size(r)===1&&(T="vec4(outputValue.x)"),s?`
vec4 getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${w}
  vec4 outputValue = getBias(${f});
  return ${T};
}`:`
float getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${w}
  return getBias(coords.x);
}`}l.getBiasForMatmul=n},9:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createPackProgramInfoLoader=void 0;const m=b(6757),p=b(5639),h=b(432),d=b(5614),u={name:"pack",inputNames:["A"],inputTypes:[p.TextureType.unpackedReversed]};l.createPackProgramInfoLoader=(c,a)=>Object.assign(Object.assign({},u),{get:()=>((o,n)=>{const t=(0,m.getGlsl)(o.session.backend.glContext.version),e=n.dims,r=e.length,i=n.dims.length,s=(0,h.getCoordsDataType)(i),f=(0,d.getChannels)("rc",i),g=(y=i,v=f,w=e[e.length-2],T=e[e.length-1],y===0||y===1?"":`
    int r = ${v[y-2]};
    int c = ${v[y-1]};
    int rp1 = ${v[y-2]} + 1;
    int cp1 = ${v[y-1]} + 1;
    bool rEdge = rp1 >= ${T};
    bool cEdge = cp1 >= ${w};
    `);var y,v,w,T;let x;x=r===0?[1,1]:r===1?[e[0],1]:[e[i-1],e[i-2]];const A=function(j,M,S){if(j===0)return"false";if(j===1)return`rc > ${M[0]}`;let U="";for(let O=j-2;O<j;O++)U+=`${S[O]} >= ${M[O-j+2]}`,O<j-1&&(U+="||");return U}(i,x,f),D=function(j,M){const S=j.length;if(S===0)return"getA(), 0, 0, 0";if(S===1)return`getA(rc),
            rc + 1 >= ${j[0]} ? 0. : getA(rc + 1),
            0, 0`;let U="";if(S>2)for(let O=0;O<S-2;++O)U+=`${M[O]},`;return`getA(${U}r, c),
          rEdge ? 0. : getA(${U}rp1, c),
          cEdge ? 0. : getA(${U}r, cp1),
          rEdge || cEdge ? 0. : getA(${U}rp1, cp1)`}(e,f),$=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${A}) {
            ${t.output} = vec4(0);
          } else {
            ${g}

            ${t.output} = vec4(${D});
          }
        }
      `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:n.dims,type:n.type,textureType:p.TextureType.packed},shaderSource:$})})(c,a)})},5614:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.unpackFromChannel=l.getChannels=l.getVecChannels=void 0;const m=b(432);function p(h,d){return(0,m.getGlChannels)(d).map(u=>`${h}.${u}`)}l.getVecChannels=p,l.getChannels=function(h,d){return d===1?[h]:p(h,d)},l.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parsePadAttributesV11=l.padV11=l.parsePadAttributesV2=l.padV2=void 0;const m=b(4910),p=b(7273),h=b(6757),d=b(5639),u={name:"Pad",inputNames:["A"],inputTypes:[d.TextureType.unpacked]};l.padV2=(s,f,g)=>(o(f),[s.run(Object.assign(Object.assign({},u),{cacheHint:g.cacheKey,get:()=>a(s,f[0],g)}),f)]),l.parsePadAttributesV2=s=>{const f=s.attributes.getString("mode","constant"),g=s.attributes.getFloat("value",0),y=s.attributes.getInts("pads");return(0,m.createAttributeWithCacheKey)({mode:f,value:g,pads:y})},l.padV11=(s,f,g)=>{n(f);const y=c(s,f,g);return(0,l.padV2)(s,[f[0]],y)},l.parsePadAttributesV11=s=>s.attributes.getString("mode","constant");const c=(s,f,g)=>{if(!s.session.isInitializer(f[1].dataId)||f.length>=3&&!s.session.isInitializer(f[2].dataId))throw new Error("dynamic pad attributes are not allowed");const y=Array.from(f[1].integerData),v=f.length>=3?f[2].floatData[0]:0;return(0,m.createAttributeWithCacheKey)({mode:g,pads:y,value:v})},a=(s,f,g)=>{const y=p.ShapeUtil.padShape(f.dims.slice(),g.pads),v=y.length,w=`
      ${t(s,f,g)}
      float process(int[${v}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[d.TextureType.unpacked],output:{dims:y,type:f.type,textureType:d.TextureType.unpacked},shaderSource:w}},o=s=>{if(!s||s.length!==1)throw new Error("Pad requires 1 input");if(s[0].type!=="float32"&&s[0].type!=="float64")throw new Error("Invalid input type.")},n=s=>{if(!s||s.length!==2&&s.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(s[1].type!=="int32")throw new Error("Invalid input type.");if(s.length>=3&&s[2].type==="string")throw new Error("Invalid input type.")},t=(s,f,g)=>{const y=(0,h.getGlsl)(s.session.backend.glContext.version),[v,w]=s.calculateTextureWidthAndHeight(f.dims,d.TextureType.unpacked),T=p.ShapeUtil.computeStrides(f.dims);switch(g.mode){case"constant":return e(y,f.dims,T,v,w,g.pads,g.value);case"reflect":return r(y,f.dims,T,v,w,g.pads);case"edge":return i(y,f.dims,T,v,w,g.pads);default:throw new Error("Invalid mode")}},e=(s,f,g,y,v,w,T)=>{const x=f.length;let A="";for(let D=x-1;D>=0;--D)A+=`
        k = m[${D}] - ${w[D]};
        if (k < 0)  return constant;
        if (k >= ${f[D]}) return constant;
        offset += k * ${g[D]};
        `;return`
      float padA(int m[${x}]) {
        const float constant = float(${T});
        int offset = 0;
        int k = 0;
        ${A}
        vec2 coords = offsetToCoords(offset, ${y}, ${v});
        float value = getColorAsFloat(${s.texture2D}(A, coords));
        return value;
      }
      `},r=(s,f,g,y,v,w)=>{const T=f.length;let x="";for(let A=T-1;A>=0;--A)x+=`
        k = m[${A}] - ${w[A]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(f[A]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${f[A]}) { k = _2n_1 - k; }
        }
        offset += k * ${g[A]};
        `;return`
      float padA(int m[${T}]) {
        int offset = 0;
        int k = 0;
        ${x}
        vec2 coords = offsetToCoords(offset, ${y}, ${v});
        float value = getColorAsFloat(${s.texture2D}(A, coords));
        return value;
      }
      `},i=(s,f,g,y,v,w)=>{const T=f.length;let x="";for(let A=T-1;A>=0;--A)x+=`
        k = m[${A}] - ${w[A]};
        if (k < 0)  k = 0;
        if (k >= ${f[A]}) k = ${f[A]-1};
        offset += k * ${g[A]};
      `;return`
      float padA(int m[${T}]) {
        int offset = 0;
        int k = 0;
        ${x}
        vec2 coords = offsetToCoords(offset, ${y}, ${v});
        float value = getColorAsFloat(${s.texture2D}(A, coords));
        return value;
      }
      `}},2834:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.globalMaxPool=l.parseMaxPoolAttributes=l.maxPool=l.parseGlobalAveragePoolAttributes=l.globalAveragePool=l.parseAveragePoolAttributes=l.averagePool=void 0;const m=b(4910),p=b(7273),h=b(5639);l.averagePool=(i,s,f)=>{n(s);const g={name:"AveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:f.cacheKey};return[i.run(Object.assign(Object.assign({},g),{get:()=>d(s,g,!1,f)}),s)]},l.parseAveragePoolAttributes=i=>{const s=i.attributes.getString("auto_pad","NOTSET"),f=i.attributes.getInt("ceil_mode",0),g=i.attributes.getInt("count_include_pad",0)!==0,y=i.attributes.getInts("kernel_shape"),v=i.attributes.getInts("strides",[]),w=i.attributes.getInts("pads",[]);if(f!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,m.createAttributeWithCacheKey)({autoPad:s,ceilMode:f,countIncludePad:g,kernelShape:y,strides:v,pads:w})};const d=(i,s,f,g)=>{const[y,v]=c(i,g,f),w=p.ShapeUtil.size(y.kernelShape);let T="";y.countIncludePad?T+=`value /= float(${w});`:T+=`value /= float(${w} - pad);`;const x=`
        ${t(i[0].dims,y,"value += _X(x);",T,"0.0")}
      `;return Object.assign(Object.assign({},s),{output:{dims:v,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:x})};l.globalAveragePool=(i,s,f)=>{n(s);const g={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:`${f.countIncludePad}`};return[i.run(Object.assign(Object.assign({},g),{get:()=>d(s,g,!0,f)}),s)]},l.parseGlobalAveragePoolAttributes=i=>{const s=i.attributes.getInt("count_include_pad",0)!==0;return(0,m.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:s,kernelShape:[],strides:[],pads:[]})},l.maxPool=(i,s,f)=>{n(s);const g={name:"MaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:f.cacheKey};return[i.run(Object.assign(Object.assign({},g),{get:()=>u(s,g,!1,f)}),s)]},l.parseMaxPoolAttributes=i=>{const s=i.attributes.getString("auto_pad","NOTSET"),f=i.attributes.getInt("ceil_mode",0),g=i.attributes.getInts("kernel_shape"),y=i.attributes.getInts("strides",[]),v=i.attributes.getInts("pads",[]),w=i.attributes.getInt("storage_order",0),T=i.attributes.getInts("dilations",[]);if(w!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(f!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,m.createAttributeWithCacheKey)({autoPad:s,ceilMode:f,countIncludePad:!1,kernelShape:g,strides:y,pads:v,storageOrder:w,dilations:T})};const u=(i,s,f,g)=>{const[y,v]=c(i,g,f),w=`
      ${t(i[0].dims,y,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},s),{output:{dims:v,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:w})},c=(i,s,f)=>{const g=i[0].dims.slice(),y=Object.hasOwnProperty.call(s,"dilations"),v=s.kernelShape.slice(),w=s.strides.slice(),T=y?s.dilations.slice():[],x=s.pads.slice();p.PoolConvUtil.adjustPoolAttributes(f,g,v,w,T,x);const A=p.PoolConvUtil.computePoolOutputShape(f,g,w,T,v,x,s.autoPad),D=Object.assign({},s);return y?Object.assign(D,{kernelShape:v,strides:w,pads:x,dilations:T,cacheKey:s.cacheKey}):Object.assign(D,{kernelShape:v,strides:w,pads:x,cacheKey:s.cacheKey}),[D,A]},a={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},o={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};l.globalMaxPool=(i,s)=>(n(s),[i.run(Object.assign(Object.assign({},o),{get:()=>u(s,o,!0,a)}),s)]);const n=i=>{if(!i||i.length!==1)throw new Error("Pool ops requires 1 input.");if(i[0].type!=="float32"&&i[0].type!=="float64")throw new Error("Invalid input type.")},t=(i,s,f,g,y)=>{const v=i.length;if(s.kernelShape.length<=2){const w=s.kernelShape[s.kernelShape.length-1],T=s.strides[s.strides.length-1],x=s.pads[s.pads.length/2-1],A=s.pads[s.pads.length-1],D=i[v-1];let $="",j="",M="";if($=x+A!==0?`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${T} - ${x} + i;
            if (x[${v} - 1] < 0 || x[${v} - 1] >= ${D}) {
              pad++;
              continue;
            }
            ${f}
          }`:`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${T} - ${x} + i;
            ${f}
          }`,s.kernelShape.length===2){const S=s.kernelShape[s.kernelShape.length-2],U=s.strides[s.strides.length-2],O=s.pads[s.pads.length/2-2],E=s.pads[s.pads.length-2],F=i[v-2];j=O+E!==0?`
            for (int j = 0; j < ${S}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${U} - ${O} + j;
              if (x[${v} - 2] < 0 || x[${v} - 2] >= ${F}) {
                pad+= ${w};
                continue;
              }
          `:`
            for (int j = 0; j < ${S}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${U} - ${O} + j;
            `,M=`
          }
        `}return`
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);

          float value = ${y};
          int pad = 0;
          ${j}
          ${$}
          ${M}
          ${g}
          return value;
        }
      `}{const w=p.ShapeUtil.size(s.kernelShape),T=p.ShapeUtil.computeStrides(s.kernelShape),x=T.length,A=s.pads.length,D=r(x),$=e(i,"inputDims"),j=e(s.pads,"pads"),M=e(T,"kernelStrides"),S=e(s.strides,"strides");let U="";return U=s.pads.reduce((O,E)=>O+E)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${f}
          }`:`
          }
          ${f}
        `,`
        ${D}
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);
          int offset[${x}];
          int pads[${A}];
          int inputDims[${v}];
          int kernelStrides[${x}];
          int strides[${x}];
          ${j}
          ${$}
          ${S}
          ${M}

          float value = ${y};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${w}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${v} - ${x}; j < ${v}; j++) {
              x[j] = indices[j] * strides[j - ${v} + ${x}]
                + offset[j - ${v} + ${x}] - pads[j - 2];
              ${U}
          }
          ${g}

          return value;
        }
      `}},e=(i,s)=>{let f="";for(let g=0;g<i.length;g++)f+=`
      ${s}[${g}] = ${i[g]};
    `;return f},r=i=>`
  void offsetToIndices(int offset, int[${i}] strides, out int[${i}] indices) {
    if (${i} == 0) {
      return;
    }
    for (int i = 0; i < ${i} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${i} - 1] = offset;
  }`},1010:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.reduceLogSumSquare=l.reduceLogSum=l.reduceProd=l.reduceMin=l.reduceMax=l.reduceMean=l.reduceSum=l.parseReduceAttributes=void 0;const m=b(4910),p=b(6145),h=b(7273),d=b(5639),u=(o,n,t,e,r)=>{a(n);const i={name:e,inputNames:["A"],inputTypes:[d.TextureType.unpacked]};return[o.run(Object.assign(Object.assign({},i),{cacheHint:t.cacheKey,get:()=>c(o,n,t,e,r,i)}),n)]};l.parseReduceAttributes=o=>{const n=o.attributes.getInts("axes",[]),t=o.attributes.getInt("keepdims",1)===1;return(0,m.createAttributeWithCacheKey)({axes:n,keepDims:t})};const c=(o,n,t,e,r,i)=>{const s=[],f=n[0].dims.length||1,g=[],y=h.ShapeUtil.normalizeAxes(t.axes,n[0].dims.length),v=r(n,y);let w=v[1];for(let x=0;x<n[0].dims.length;x++)y.indexOf(x)>=0||y.length===0?(t.keepDims&&s.push(1),w=`
          for(int j${x} = 0; j${x} < ${n[0].dims[x]}; j${x}++) {
            inputIdx[${x}] = j${x};
            ${w}
          }`):(g.push(`inputIdx[${x}] = outputIdx[${s.length}];`),s.push(n[0].dims[x]));const T=`
      float process(int outputIdx[${s.length||1}]) {
        float value;                 // final result
        int inputIdx[${f}];      // addressing input data
        ${g.join(`
`)}
        ${v[0]}       // init ops for reduce max/min
        ${w}
        ${v[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},i),{output:{dims:s,type:n[0].type,textureType:d.TextureType.unpacked},shaderSource:T})},a=o=>{if(!o||o.length!==1)throw new Error("Reduce op requires 1 input.");if(p.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invalid input type.")};l.reduceSum=(o,n,t)=>u(o,n,t,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),l.reduceMean=(o,n,t)=>u(o,n,t,"ReduceMean",(e,r)=>{let i=1;for(let s=0;s<e[0].dims.length;s++)(r.indexOf(s)>=0||r.length===0)&&(i*=e[0].dims[s]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${i}.;`]}),l.reduceMax=(o,n,t)=>u(o,n,t,"ReduceMax",(e,r)=>{const i=[];for(let s=0;s<e[0].dims.length;s++)(r.indexOf(s)>=0||r.length===0)&&i.push(`inputIdx[${s}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),l.reduceMin=(o,n,t)=>u(o,n,t,"ReduceMin",(e,r)=>{const i=[];for(let s=0;s<e[0].dims.length;s++)(r.indexOf(s)>=0||r.length===0)&&i.push(`inputIdx[${s}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),l.reduceProd=(o,n,t)=>u(o,n,t,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),l.reduceLogSum=(o,n,t)=>u(o,n,t,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),l.reduceLogSumSquare=(o,n,t)=>u(o,n,t,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.isReshapeCheap=l.processDims3D=l.createPackedReshape3DProgramInfoLoader=void 0;const m=b(7273),p=b(6757),h=b(5639),d=b(5614);l.createPackedReshape3DProgramInfoLoader=(u,c,a)=>{const o=(n=>({name:"Reshape (packed)",inputTypes:[h.TextureType.packed],inputNames:["A"],cacheHint:`${n}`}))(a);return Object.assign(Object.assign({},o),{get:()=>((n,t,e,r)=>{const i=t.dims,s=r;let f="";for(let v=0;v<4;v++){let w="";switch(v){case 0:w="outputCoords = rc;";break;case 1:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:w="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}f+=`
        ${w}
        ${v>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${v}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${v>0?"}":""}
      `}const g=(0,p.getGlsl)(n.session.backend.glContext.version),y=`
      ${function(v){const w=m.ShapeUtil.computeStrides(v),T=["b","r","c"],x="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${w.map((A,D)=>`int ${T[D]} = ${x} / ${A}; ${D===w.length-1?`int ${T[D+1]} = ${x} - ${T[D]} * ${A}`:`index -= ${T[D]} * ${A}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(i)}
      ${function(v){const w=m.ShapeUtil.computeStrides(v);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${w[0]} + coords.z * ${w[1]} + coords.y;
  }
`}(s)}
      ${(0,d.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${s[2]};
        int cols = ${s[1]};

        ${f}
        ${g.output} = result;
      }
    `;return Object.assign(Object.assign({},e),{output:{dims:s,type:t.type,textureType:h.TextureType.packed},shaderSource:y,hasMain:!0})})(u,c,o,a)})},l.processDims3D=function(u){if(u.length===0)return[1,1,1];let c=1;for(let a=0;a<u.length-2;++a)c*=u[a];return[c,u.length>1?u[u.length-2]:1,u[u.length-1]]},l.isReshapeCheap=function(u,c){let a=!1;return a=u.length===0||c.length===0||(u.length<2||c.length<2?u[u.length-1]===c[c.length-1]:u[u.length-1]===c[c.length-1]&&u[u.length-2]===c[c.length-2]),a}},8126:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.reshape=void 0;const m=b(7273);l.reshape=(p,h)=>{const d=m.ShapeUtil.calculateReshapedDims(h[0].dims,h[1].integerData);return p.session.pack?[p.reshapePacked(h[0],d)]:[p.reshapeUnpacked(h[0],d)]}},2801:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseResizeAttributesV11=l.parseResizeAttributesV10=l.resize=void 0;const m=b(6757),p=b(5639),h=b(432),d=b(5614),u=b(3980),c={name:"Resize",inputNames:["A"],inputTypes:[p.TextureType.packed]};l.resize=(e,r,i)=>((0,u.validateInputs)(r,i),[e.run(Object.assign(Object.assign({},c),{cacheHint:i.cacheKey,get:()=>a(e,r,i)}),r)]),l.parseResizeAttributesV10=e=>(0,u.parseUpsampleAttributes)(e,10),l.parseResizeAttributesV11=e=>(0,u.parseUpsampleAttributes)(e,11);const a=(e,r,i)=>{const s=(0,m.getGlsl)(e.session.backend.glContext.version),[f,g]=o(r,i);if(f.every(U=>U===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},c),{output:{dims:g,type:r[0].type,textureType:p.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${s.texture2D}(X, TexCoords);
                    ${s.output} = v;
                }`});const y=g.length;if(y<2)throw new Error(`output dimension should be at least 2, but got ${y}`);const v=g[y-2],w=g[y-1],T=r[0].dims;if(y!==T.length)throw new Error(`output dimension should match input ${T.length}, but got ${y}`);const x=T[y-2],A=T[y-1],D=f[y-2],$=f[y-1];let j="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":j=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":j=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":j=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${w}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${w}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":j=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${w}.0 - 1.0, ${v}.0 - 1.0, ${w}.0 - 1.0,
                            ${v}.0 - 1.0);
                        vec4 original = vec4(${A}.0 - 1.0, ${x}.0 - 1.0, ${A}.0 - 1.0,
                            ${x}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}const M=(0,h.getCoordsDataType)(y),S=`
            const vec2 inputWH = vec2(${x}.0, ${A}.0);
            const vec4 scaleWHWH = vec4(float(${D}), float(${$}), float(${D}), float(${$}));
            ${(0,d.unpackFromChannel)()}
            ${j}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${M} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${v-1};
                bool hasNextCol = rc.z < ${w-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},c),{output:{dims:g,type:r[0].type,textureType:p.TextureType.packed},hasMain:!0,shaderSource:S})},o=(e,r)=>{const i=e[0].dims;let s,f=r.scales;if(f.length===0){const y=e[r.scalesInputIdx];if(y&&y.size!==0){if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");f=n(y,r.mode,r.isResize)}else{const v=e[r.sizesInputIdx];if(!v||v.size===0)throw new Error("Either scales or sizes MUST be provided as input.");s=Array.from(v.integerData),f=t(s,i,r.mode,r.isResize)}}else if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const g=s||i.map((y,v)=>Math.floor(y*f[v]));return[f,g]},n=(e,r,i)=>{const s=Array.from(e.floatData);return(0,u.scalesValidation)(s,r,i),s},t=(e,r,i,s)=>{const f=r.length,g=new Array(f);for(let y=0,v=f;y<v;y++)if(r[y]===0){if(e[y]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");g[y]=1}else g[y]=e[y]/r[y];return(0,u.scalesValidation)(g,i,s),g}},565:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.shape=void 0;const m=b(9240);l.shape=(h,d)=>(p(d),[new m.Tensor([d[0].dims.length],"int32",void 0,void 0,new Int32Array(d[0].dims))]);const p=h=>{if(!h||h.length!==1)throw new Error("Shape requires 1 input.")}},2444:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.sliceV10=l.parseSliceAttributes=l.slice=void 0;const m=b(4910),p=b(6145),h=b(7273),d=b(5639),u={name:"Slice",inputNames:["A"],inputTypes:[d.TextureType.unpacked]};l.slice=(t,e,r)=>(a(e),[t.run(Object.assign(Object.assign({},u),{cacheHint:r.cacheKey,get:()=>c(t,e[0],r)}),e)]),l.parseSliceAttributes=t=>{const e=t.attributes.getInts("starts"),r=t.attributes.getInts("ends"),i=t.attributes.getInts("axes",[]);return(0,m.createAttributeWithCacheKey)({starts:e,ends:r,axes:i})};const c=(t,e,r)=>{const i=r.axes.length===0?e.dims.slice(0).map((T,x)=>x):r.axes,s=h.ShapeUtil.normalizeAxes(i,e.dims.length),f=r.starts.map((T,x)=>T>e.dims[s[x]]-1?e.dims[s[x]]:h.ShapeUtil.normalizeAxis(T,e.dims[s[x]])),g=r.ends.map((T,x)=>T>e.dims[s[x]]-1?e.dims[s[x]]:h.ShapeUtil.normalizeAxis(T,e.dims[s[x]])),y=e.dims.slice(),v=[];for(let T=0;T<s.length;T++)y[s[T]]=g[T]-f[T],f[T]>0&&v.push(`outputIdx[${s[T]}] += ${f[T]};`);const w=`
      float process(int outputIdx[${y.length}]) {
        ${v.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},u),{output:{dims:y,type:e.type,textureType:d.TextureType.unpacked},shaderSource:w})},a=t=>{if(!t||t.length!==1)throw new Error("Slice requires 1 input.");if(p.NUMBER_TYPES.indexOf(t[0].type)===-1)throw new Error("Invalid input type.")};l.sliceV10=(t,e)=>{n(e);const r=o(t,e);return[t.run(Object.assign(Object.assign({},u),{cacheHint:r.cacheKey,get:()=>c(t,e[0],r)}),[e[0]])]};const o=(t,e)=>{if(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)||e.length>=4&&!t.session.isInitializer(e[3].dataId)||e.length>=5&&!t.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some(f=>f!==1))throw new Error("currently non-1 steps is not supported for Slice");const r=Array.from(e[1].integerData),i=Array.from(e[2].integerData),s=e.length>=4?Array.from(e[3].integerData):[];return{starts:r,ends:i,axes:s,cacheKey:`${s};${r};${i}`}},n=t=>{if(!t||t.length<3||t.length>5)throw new Error("Invalid input number.");if(t[1].type!=="int32"||t[1].dims.length!==1)throw new Error("Invalid input type.");if(t[2].type!=="int32"||t[2].dims.length!==1)throw new Error("Invalid input type.");if(t.length>=4&&(t[3].type!=="int32"||t[3].dims.length!==1))throw new Error("Invalid input type.");if(t.length>=5&&(t[4].type!=="int32"||t[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.softmaxV13=l.parseSoftmaxAttributesV13=l.parseSoftmaxAttributes=l.softmax=void 0;const m=b(4910),p=b(7273),h=b(6757),d=b(5639),u=b(5707),c={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[d.TextureType.unpacked]},a={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[d.TextureType.unpacked,d.TextureType.unpacked]},o={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[d.TextureType.unpacked,d.TextureType.unpacked,d.TextureType.unpacked]};l.softmax=(s,f,g)=>{i(f);const y=f[0].dims.slice(),v=p.ShapeUtil.normalizeAxis(g.axis,y.length),w=p.ShapeUtil.sizeToDimension(y,v),T=p.ShapeUtil.sizeFromDimension(y,v);return n(s,f,g,w,T)},l.parseSoftmaxAttributes=s=>(0,m.createAttributeWithCacheKey)({axis:s.attributes.getInt("axis",1)}),l.parseSoftmaxAttributesV13=s=>(0,m.createAttributeWithCacheKey)({axis:s.attributes.getInt("axis",-1)}),l.softmaxV13=(s,f,g)=>{i(f);const y=f[0].dims.slice(),v=p.ShapeUtil.normalizeAxis(g.axis,y.length),w=y.length,T=v!==w-1,x=[];let A,D=[],$=[];T&&(D=Array.from({length:w}).map((U,O)=>O),D[v]=w-1,D[w-1]=v,D.map(U=>x.push(y[U])),A=(0,m.createAttributeWithCacheKey)({perm:D}),$=(0,u.transpose)(s,f,A));const j=T?p.ShapeUtil.sizeToDimension(x,w-1):p.ShapeUtil.sizeToDimension(y,w-1),M=T?p.ShapeUtil.sizeFromDimension(x,w-1):p.ShapeUtil.sizeFromDimension(y,w-1),S=n(s,T?$:f,g,j,M);return T?(0,u.transpose)(s,S,A):S};const n=(s,f,g,y,v)=>{const w=t(s,f[0],y,v,[y]),T=s.run(Object.assign(Object.assign({},c),{cacheHint:g.cacheKey,get:()=>w}),f),x=e(s,f[0],y,v,w.output.dims,[y]),A=s.run(Object.assign(Object.assign({},a),{cacheHint:g.cacheKey,get:()=>x}),[f[0],T]),D=r(s,f[0],y,v,w.output.dims,x.output.dims);return[s.run(Object.assign(Object.assign({},o),{cacheHint:g.cacheKey,get:()=>D}),[f[0],T,A])]},t=(s,f,g,y,v)=>{const[w,T]=s.calculateTextureWidthAndHeight(f.dims,d.TextureType.unpacked),x=v.length;if(g<1||y<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1)throw new Error("Dimensionality of the output should be 1");if(v[0]!==g)throw new Error("Shape of the output should be equal to logical row count");const A=(0,h.getGlsl)(s.session.backend.glContext.version),D=`
      float process(int[${x}] indices) {
        int logical_row_start_offset = indices[0] * ${y};

        float max = getColorAsFloat(${A.texture2D}(A, offsetToCoords(logical_row_start_offset, ${w},
        ${T} )));
        for(int i=1; i<${y}; ++i)
        {
          float current = getColorAsFloat(${A.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${w}, ${T})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},c),{output:{dims:v,type:f.type,textureType:d.TextureType.unpacked},shaderSource:D})},e=(s,f,g,y,v,w)=>{const[T,x]=s.calculateTextureWidthAndHeight(f.dims,d.TextureType.unpacked),A=w.length;if(g<1||y<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(w.length!==1)throw new Error("Dimensionality of the output should be 1");if(w[0]!==g)throw new Error("Shape of the output should be equal to logical row count");if(v.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");const D=`
      float process(int[${A}] indices) {
        int logical_row_start_offset = indices[0] * ${y};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${y}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,h.getGlsl)(s.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${T}, ${x}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},a),{output:{dims:w,type:f.type,textureType:d.TextureType.unpacked},shaderSource:D})},r=(s,f,g,y,v,w)=>{const[T,x]=s.calculateTextureWidthAndHeight(f.dims,d.TextureType.unpacked),A=f.dims.length;if(g<1||y<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1||w.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g||w[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");const D=`
      float process(int[${A}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${T}, ${x});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${y};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},o),{output:{dims:f.dims,type:f.type,textureType:d.TextureType.unpacked},shaderSource:D})},i=s=>{if(!s||s.length!==1)throw new Error("Softmax requires 1 input.");if(s[0].type!=="float32"&&s[0].type!=="float64")throw new Error("Invalid input type")}},564:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseSplitAttributes=l.split=void 0;const m=b(4910),p=b(7273),h=b(5639),d={name:"Split",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};l.split=(o,n,t)=>{a(n);const e=p.ShapeUtil.normalizeAxis(t.axis,n[0].dims.length),r=u(o,n,e,t),i=[];for(let s=0;s<r;++s)i.push(o.run(Object.assign(Object.assign({},d),{cacheHint:`${t.cacheKey};${s}`,get:()=>c(o,n[0],t,e,s)}),n));return i},l.parseSplitAttributes=o=>{const n=o.attributes.getInt("axis",0),t=o.attributes.getInts("split",[]),e=o.outputs.length;return(0,m.createAttributeWithCacheKey)({axis:n,split:t,numOutputs:e})};const u=(o,n,t,e)=>{const[,r]=p.SplitUtil.splitShape(n[0].dims,t,e.split,e.numOutputs);return r.length},c=(o,n,t,e,r)=>{const[i,s]=p.SplitUtil.splitShape(n.dims,e,t.split,t.numOutputs),f=s[r],g=i[r],y=`
      float process(int indices[${g.length}]) {
        indices[${e}] += ${f};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},d),{cacheHint:`${t.cacheKey}:${r}`,output:{dims:g,type:n.type,textureType:h.TextureType.unpacked},shaderSource:y})},a=o=>{if(!o||o.length!==1)throw new Error("Split requires one input.");if(o[0].type!=="int8"&&o[0].type!=="uint8"&&o[0].type!=="int16"&&o[0].type!=="uint16"&&o[0].type!=="int32"&&o[0].type!=="uint32"&&o[0].type!=="float32"&&o[0].type!=="float64"&&o[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseSqueezeAttributes=l.squeezeV13=l.squeeze=void 0;const m=b(7273);l.squeeze=(d,u,c)=>{p(u);const a=m.ShapeUtil.squeezeShape(u[0].dims,c);return[d.reshapeUnpacked(u[0],a)]},l.squeezeV13=(d,u)=>(h(u),(0,l.squeeze)(d,[u[0]],Array.from(u[1].integerData))),l.parseSqueezeAttributes=d=>d.attributes.getInts("axes");const p=d=>{if(!d||d.length!==1)throw new Error("Squeeze requires 1 input.");if(d[0].type==="string")throw new Error("invalid input tensor types.")},h=d=>{if(!d||d.length!==2)throw new Error("Squeeze requires 2 inputs.");if(d[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.sum=void 0;const m=b(6757),p=b(5639);l.sum=(u,c)=>{d(c);const a={name:"Sum",inputNames:c.map((o,n)=>`X${n}`),inputTypes:new Array(c.length).fill(p.TextureType.unpacked)};return[u.run(Object.assign(Object.assign({},a),{get:()=>h(u,c,a)}),c)]};const h=(u,c,a)=>{const o=(0,m.getGlsl)(u.session.backend.glContext.version),n=c[0].dims.slice(),t=`
      void main() {
        vec4 result = ${c.map((e,r)=>`${o.texture2D}(X${r},TexCoords)`).join(" + ")};
        ${o.output} = result;
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:n,type:c[0].type,textureType:p.TextureType.unpacked},hasMain:!0,shaderSource:t})},d=u=>{if(!u||u.length===0)throw new Error("Sum requires inputs.");const c=u[0].dims.length;for(let a=1;a<u.length;a++){if(c!==u[a].dims.length)throw new Error("Input shapes are mismatched.");for(let o=0;o<c;o++)if(u[0].dims[o]!==u[a].dims[o])throw new Error("Input shapes are not matched.")}if(u[0].type!=="float32"&&u[0].type!=="float64")throw new Error("Invalid input type.");for(let a=1;a<u.length;a++)if(u[0].type!==u[a].type)throw new Error("Input types are not matched.")}},5944:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.tile=void 0;const m=b(6145),p=b(5639);l.tile=(u,c)=>{d(c);const a={name:"Tile",inputNames:["A"],inputTypes:[p.TextureType.unpacked]};return[u.run(Object.assign(Object.assign({},a),{get:()=>h(u,c,a)}),c)]};const h=(u,c,a)=>{const o=c[0].dims.slice(),n=new Array(o.length),t=[];for(let i=0;i<o.length;i++)n[i]=o[i]*c[1].numberData[i],t.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${o[i]}.));`);const e=n.length,r=`
      float process(int outputIdx[${e}]) {
        int inputIdx[${e}];
        ${t.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:n,type:c[0].type,textureType:p.TextureType.unpacked},shaderSource:r})},d=u=>{if(!u||u.length!==2)throw new Error("Tile requires 2 input.");if(u[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(u[1].dims[0]!==u[0].dims.length)throw new Error("Invalid input shape.");if(m.NUMBER_TYPES.indexOf(u[0].type)===-1)throw new Error("Invalid input type.");if(u[1].type!=="int32"&&u[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseTransposeAttributes=l.transpose=void 0;const m=b(4910),p=b(7273),h=b(5639),d={name:"Transpose",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};l.transpose=(t,e,r)=>(n(e),[t.run(Object.assign(Object.assign({},d),{cacheHint:r.cacheKey,get:()=>u(t,e[0],r.perm)}),e)]),l.parseTransposeAttributes=t=>(0,m.createAttributeWithCacheKey)({perm:t.attributes.getInts("perm",[])});const u=(t,e,r)=>{const i=e.dims;r=c(i,r);const s=a(i,r),f=i.length,g=`
      ${o("perm",r,f)}
      float process(int indices[${f}]) {
        int a[${f}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},d),{output:{dims:s,type:e.type,textureType:h.TextureType.unpacked},shaderSource:g})},c=(t,e)=>(e&&e.length!==t.length&&(e=[...t.keys()].reverse()),e),a=(t,e)=>(e=c(t,e),p.ShapeUtil.sortBasedOnPerm(t,e)),o=(t,e,r)=>{const i=[];i.push(`void ${t}(out int a[${r}], int src[${r}]) {`);for(let s=0;s<r;++s)i.push(`	a[${e[s]}]=src[${s}];`);return i.push("	}"),i.join(`
`)},n=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.encodeAsUint8=void 0;const m=b(6757),p=b(5639);l.encodeAsUint8=(h,d)=>{const u=d.shape,c=(0,m.getGlsl)(h.session.backend.glContext.version),a=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${c.texture2D}(X,TexCoords).r;
      ${c.output} = encodeAsUint8(value);
    }`,o={name:"Uint8Encode",inputTypes:[p.TextureType.unpacked],inputNames:["X"],output:{dims:u,type:d.tensor.type,textureType:p.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return h.executeProgram(o,[d.tensor])}},9087:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.tanh=l.tan=l.sqrt=l.sin=l.sigmoid=l.relu=l.not=l.neg=l.log=l.parseLeakyReluAttributes=l.leakyRelu=l.identity=l.floor=l.exp=l.parseEluAttributes=l.elu=l.cos=l.ceil=l.clipV11=l.parseClipAttributes=l.clip=l.atan=l.asin=l.acos=l.abs=l.glslTanh=l.glslTan=l.glslSqrt=l.glslSigmoid=l.glslRelu=l.glslSin=l.glslNot=l.glslNeg=l.glslLog=l.glslLeakyRelu=l.glslIdentity=l.glslClip=l.glslFloor=l.glslExp=l.glslElu=l.glslCos=l.glslCeil=l.glslAtan=l.glslAsin=l.glslAcos=l.glslAbs=void 0;const m=b(4910),p=b(7273),h=b(1997),d=b(6757),u=b(5639);function c(){return S("abs")}function a(){return S("acos")}function o(){return S("asin")}function n(){return S("atan")}function t(){return S("ceil")}function e(){return S("cos")}function r(E){const F="elu";return{body:`
  const float alpha = float(${E});

  float ${F}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${F}_(vec4 v) {
    return vec4(${F}_(v.x), ${F}_(v.y), ${F}_(v.z), ${F}_(v.w));
  }
  `,name:F,type:h.FunctionType.ValueBased}}function i(){return S("exp")}function s(){return S("floor")}function f(E,F){const q="clip";return{body:`
  const float min = float(${E});
  const float max = float(${F});

  float ${q}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${q}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:q,type:h.FunctionType.ValueBased}}function g(){const E="indentity";return{body:`
  float ${E}_(float a) {
    return a;
  }
  vec4 ${E}_(vec4 v) {
    return v;
  }
  `,name:E,type:h.FunctionType.ValueBased}}function y(E){const F="leakyRelu";return{body:`
  const float alpha = float(${E});

  float ${F}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${F}_(vec4 v) {
    return vec4(${F}_(v.x), ${F}_(v.y), ${F}_(v.z), ${F}_(v.w));
  }
  `,name:F,type:h.FunctionType.ValueBased}}function v(){return S("log")}function w(){const E="neg";return{body:`
  float ${E}_(float a) {
    return -a;
  }
  vec4 ${E}_(vec4 v) {
    return -v;
  }
  `,name:E,type:h.FunctionType.ValueBased}}function T(){const E="not";return{body:`
  float ${E}_(float a) {
    return float( ! bool(a) );
  }
  bool ${E}_(bool a) {
    return !a;
  }
  vec4 ${E}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${E}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:E,type:h.FunctionType.ValueBased}}function x(){return S("sin")}function A(){const E="relu";return{body:`
  float ${E}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${E}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:E,type:h.FunctionType.ValueBased}}function D(){const E="sigmoid";return{body:`
  float ${E}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${E}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:E,type:h.FunctionType.ValueBased}}function $(){return S("sqrt")}function j(){return S("tan")}function M(){const E="tanh";return{body:`
  float ${E}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${E}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:E,type:h.FunctionType.ValueBased}}function S(E){return{body:`
  float ${E}_(float a) {
    return ${E}(a);
  }
  vec4 ${E}_(vec4 v) {
    return ${E}(v);
  }
  `,name:E,type:h.FunctionType.ValueBased}}l.glslAbs=c,l.glslAcos=a,l.glslAsin=o,l.glslAtan=n,l.glslCeil=t,l.glslCos=e,l.glslElu=r,l.glslExp=i,l.glslFloor=s,l.glslClip=f,l.glslIdentity=g,l.glslLeakyRelu=y,l.glslLog=v,l.glslNeg=w,l.glslNot=T,l.glslSin=x,l.glslRelu=A,l.glslSigmoid=D,l.glslSqrt=$,l.glslTan=j,l.glslTanh=M;const U=(E,F,q,H)=>{const K=E.session.pack?u.TextureType.packed:u.TextureType.unpacked,X={name:q.name,inputTypes:[K],inputNames:["A"],cacheHint:H};return Object.assign(Object.assign({},X),{get:()=>((J,tt,nt,rt)=>{const it=J.session.pack?u.TextureType.packed:u.TextureType.unpacked,ut=(0,d.getGlsl)(J.session.backend.glContext.version);return Object.assign(Object.assign({},tt),{output:{dims:nt.dims,type:nt.type,textureType:it},shaderSource:`
     ${rt.body}
     void main() {
       vec4 v = ${ut.texture2D}(A, TexCoords);
       v = ${rt.name}_(v);
       ${ut.output} = v;
     }
     `,hasMain:!0})})(E,X,F,q)})};l.abs=(E,F)=>[E.run(U(E,F[0],c()),F)],l.acos=(E,F)=>[E.run(U(E,F[0],a()),F)],l.asin=(E,F)=>[E.run(U(E,F[0],o()),F)],l.atan=(E,F)=>[E.run(U(E,F[0],n()),F)],l.clip=(E,F,q)=>[E.run(U(E,F[0],f(q.min,q.max),q.cacheKey),F)],l.parseClipAttributes=E=>(0,m.createAttributeWithCacheKey)({min:E.attributes.getFloat("min",p.MIN_CLIP),max:E.attributes.getFloat("max",p.MAX_CLIP)}),l.clipV11=(E,F)=>{const q=O(E,F);return(0,l.clip)(E,[F[0]],q)};const O=(E,F)=>{if(F.length>=3&&(!E.session.isInitializer(F[1].dataId)||!E.session.isInitializer(F[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const q=F.length>=3?F[1].numberData[0]:p.MIN_CLIP,H=F.length>=3?F[2].numberData[0]:p.MAX_CLIP;return(0,m.createAttributeWithCacheKey)({min:q,max:H})};l.ceil=(E,F)=>[E.run(U(E,F[0],t()),F)],l.cos=(E,F)=>[E.run(U(E,F[0],e()),F)],l.elu=(E,F,q)=>[E.run(U(E,F[0],r(q.alpha),q.cacheKey),F)],l.parseEluAttributes=E=>(0,m.createAttributeWithCacheKey)({alpha:E.attributes.getFloat("alpha",1)}),l.exp=(E,F)=>[E.run(U(E,F[0],i()),F)],l.floor=(E,F)=>[E.run(U(E,F[0],s()),F)],l.identity=(E,F)=>[E.run(U(E,F[0],g()),F)],l.leakyRelu=(E,F,q)=>[E.run(U(E,F[0],y(q.alpha),q.cacheKey),F)],l.parseLeakyReluAttributes=E=>(0,m.createAttributeWithCacheKey)({alpha:E.attributes.getFloat("alpha",.01)}),l.log=(E,F)=>[E.run(U(E,F[0],v()),F)],l.neg=(E,F)=>[E.run(U(E,F[0],w()),F)],l.not=(E,F)=>[E.run(U(E,F[0],T()),F)],l.relu=(E,F)=>[E.run(U(E,F[0],A()),F)],l.sigmoid=(E,F)=>[E.run(U(E,F[0],D()),F)],l.sin=(E,F)=>[E.run(U(E,F[0],x()),F)],l.sqrt=(E,F)=>[E.run(U(E,F[0],$()),F)],l.tan=(E,F)=>[E.run(U(E,F[0],j()),F)],l.tanh=(E,F)=>[E.run(U(E,F[0],M()),F)]},540:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createUnpackProgramInfoLoader=l.createUnpackProgramInfo=void 0;const m=b(6757),p=b(5639),h=b(432),d=b(5614),u={name:"unpack",inputNames:["A"],inputTypes:[p.TextureType.packed]};l.createUnpackProgramInfo=(c,a)=>{const o=a.dims.length,n=(0,d.getChannels)("rc",o),t=n.slice(-2),e=(0,h.getCoordsDataType)(o),r=(0,d.unpackFromChannel)(),i=a.dims.length===0?"":function(g,y){if(g===1)return"rc";let v="";for(let w=0;w<g;w++)v+=y[w],w<g-1&&(v+=",");return v}(o,n),s=o<=1?"rc":`vec2(${t.join(",")})`,f=`
    ${r}
    void main() {
      ${e} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${i});

       ${(0,m.getGlsl)(c.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${s}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:a.dims,type:a.type,textureType:p.TextureType.unpacked},shaderSource:f})},l.createUnpackProgramInfoLoader=(c,a)=>Object.assign(Object.assign({},u),{get:()=>(0,l.createUnpackProgramInfo)(c,a)})},7862:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.parseUnsqueezeAttributes=l.unsqueezeV13=l.unsqueeze=void 0;const m=b(7273);l.unsqueeze=(d,u,c)=>{p(u);const a=m.ShapeUtil.unsqueezeShape(u[0].dims,c);return[d.reshapeUnpacked(u[0],a)]},l.unsqueezeV13=(d,u)=>(h(u),(0,l.unsqueeze)(d,[u[0]],Array.from(u[1].integerData))),l.parseUnsqueezeAttributes=d=>d.attributes.getInts("axes");const p=d=>{if(!d||d.length!==1)throw new Error("Unsqueeze requires 1 input.");if(d[0].type==="string")throw new Error("invalid input tensor types.")},h=d=>{if(!d||d.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(d[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.scalesValidation=l.validateInputs=l.parseUpsampleAttributes=l.parseUpsampleAttributesV9=l.parseUpsampleAttributesV7=l.upsample=void 0;const m=b(4910),p=b(6757),h=b(5639),d={name:"Upsample",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};l.upsample=(c,a,o)=>((0,l.validateInputs)(a,o),[c.run(Object.assign(Object.assign({},d),{cacheHint:o.cacheKey,get:()=>u(c,a,o)}),a)]),l.parseUpsampleAttributesV7=c=>(0,l.parseUpsampleAttributes)(c,7),l.parseUpsampleAttributesV9=c=>(0,l.parseUpsampleAttributes)(c,9),l.parseUpsampleAttributes=(c,a)=>{const o=a>=10,n=c.attributes.getString("mode","nearest");if(n!=="nearest"&&n!=="linear"&&(a<11||n!=="cubic"))throw new Error(`unrecognized mode: ${n}`);let t=[];a<9&&(t=c.attributes.getFloats("scales"),(0,l.scalesValidation)(t,n,o));const e=c.attributes.getFloat("extrapolation_value",0),r=a>10?c.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(r)===-1)throw new Error(`coordinate_transform_mode '${r}' is not supported`);const i=r==="tf_crop_and_resize",s=i,f=n==="nearest"&&a>=11?c.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(f)===-1)throw new Error(`nearest_mode '${f}' is not supported`);const g=c.attributes.getFloat("cubic_coeff_a",-.75),y=c.attributes.getInt("exclude_outside",0)!==0;if(y&&n!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const v=a<11||n==="nearest"&&r==="asymmetric"&&f==="floor";let w=0,T=0,x=0;return a>10?c.inputs.length>2?(w=1,T=2,x=3):(T=1,x=2):a===9&&(T=1),(0,m.createAttributeWithCacheKey)({opset:a,isResize:o,mode:n,scales:t,extrapolationValue:e,coordinateTransformMode:r,useExtrapolation:s,needRoiInput:i,nearestMode:f,cubicCoefficientA:g,excludeOutside:y,useNearest2xOptimization:v,roiInputIdx:w,scalesInputIdx:T,sizesInputIdx:x})};const u=(c,a,o)=>{const n=(0,p.getGlsl)(c.session.backend.glContext.version),[t,e]=c.calculateTextureWidthAndHeight(a[0].dims,h.TextureType.unpacked),r=a[0].dims.map((x,A)=>Math.floor(x*o.scales[A])),[i,s]=c.calculateTextureWidthAndHeight(r,h.TextureType.unpacked),f=r.length,g=new Array(f),y=new Array(f);let v=`
      int output_pitches[${f}];
      int input_pitches[${f}];
      `;for(let x=f-1;x>=0;x--)g[x]=x===f-1?1:g[x+1]*r[x+1],y[x]=x===f-1?1:y[x+1]*a[0].dims[x+1],v+=`
        output_pitches[${x}] = ${g[x]};
        input_pitches[${x}] = ${y[x]};
        `;const w=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${t}, ${e});
        float value = getColorAsFloat(${n.texture2D}(X, coords));
        return value;
      }
      `,T=o.mode==="nearest"?`
    ${w}
    float process(int indices[${f}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${s});

      ${v}

      int d, m;
      for (int dim = 0; dim < ${f}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:f===4?`
    ${w}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${s});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${a[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${w}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${s});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${a[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},d),{output:{dims:r,type:a[0].type,textureType:h.TextureType.unpacked},shaderSource:T,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(x=>Math.ceil(x))}]})};l.validateInputs=(c,a)=>{if(!c||a.opset<9&&c.length!==1||a.opset>=9&&a.opset<11&&c.length!==2||a.opset>=11&&c.length<2)throw new Error("invalid inputs.");if(a.scales.length>0&&c[0].dims.length!==a.scales.length)throw new Error("Invalid input shape.");if(c[0].type==="string")throw new Error("Invalid input tensor types.")},l.scalesValidation=(c,a,o)=>{if(o){for(const n of c)if(n<=0)throw new Error("Scale value should be greater than 0.")}else for(const n of c)if(n<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(a!=="linear"&&a!=="cubic"||c.length===2||c.length===4&&c[0]===1&&c[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}},2757:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.ProgramManager=void 0;const m=b(2235),p=b(1315),h=b(8897),d=b(6757);l.ProgramManager=class{constructor(u,c,a){this.profiler=u,this.glContext=c,this.textureLayoutStrategy=a,this.repo=new Map,this.attributesBound=!1}getArtifact(u){return this.repo.get(u)}setArtifact(u,c){this.repo.set(u,c)}run(u,c,a){var o;this.profiler.event("op",`ProgramManager.run ${(o=u.programInfo.name)!==null&&o!==void 0?o:"unknown kernel"}`,()=>{var n;const t=this.glContext.gl,e=u.program;t.useProgram(e);try{this.bindOutput(a),this.attributesBound||this.bindAttributes(u.attribLocations),this.bindUniforms(u.uniformLocations,(n=u.programInfo.variables)!==null&&n!==void 0?n:[],c)}catch(r){throw p.Logger.error("ProgramManager",u.programInfo.shaderSource),r}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(u=>this.glContext.deleteProgram(u.program))}build(u,c,a){return this.profiler.event("backend","ProgramManager.build",()=>{const o=new h.GlslPreprocessor(this.glContext,u,c,a),n=o.preprocess(),t=this.compile(n);return{programInfo:u,program:t,uniformLocations:this.getUniformLocations(t,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(t)}})}compile(u){if(!this.vertexShader){p.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const o=(0,d.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}m.env.debug&&p.Logger.verbose("ProrgramManager",`FragShader:
${u}
`);const c=this.glContext.compileShader(u,this.glContext.gl.FRAGMENT_SHADER),a=this.glContext.createProgram(this.vertexShader,c);return this.glContext.deleteShader(c),a}bindOutput(u){const c=u.width,a=u.height;p.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${c}/${a}, shape=${u.shape}, type=${u.tensor.type}`),this.glContext.attachFramebuffer(u.texture,c,a)}bindAttributes(u){const c=u.position,a=u.textureCoord;this.glContext.setVertexAttributes(c,a),this.attributesBound=!0}bindUniforms(u,c,a){var o;const n=this.glContext.gl;let t=0;for(const{name:e,type:r,location:i,arrayLength:s}of u){const f=(o=c.find(g=>g.name===e))===null||o===void 0?void 0:o.data;if(r!=="sampler2D"&&!f)throw new Error(`variable '${e}' does not have data defined in program info`);switch(r){case"sampler2D":this.bindTexture(a[t],i,t),t++;break;case"float":s?n.uniform1fv(i,f):n.uniform1f(i,f);break;case"int":s?n.uniform1iv(i,f):n.uniform1i(i,f);break;default:throw new Error(`Uniform not implemented: ${r}`)}}}bindTexture(u,c,a){this.glContext.bindTextureToUniform(u.texture,a,c)}getAttribLocations(u){return{position:this.getAttribLocation(u,"position"),textureCoord:this.getAttribLocation(u,"textureCoord")}}getUniformLocations(u,c,a){const o=[];if(c)for(const n of c)o.push({name:n,type:"sampler2D",location:this.getUniformLocation(u,n)});if(a)for(const n of a)o.push(Object.assign(Object.assign({},n),{location:this.getUniformLocation(u,n.name)}));return o}getUniformLocation(u,c){const a=this.glContext.gl.getUniformLocation(u,c);if(a===null)throw new Error(`Uniform ${c} not found.`);return a}getAttribLocation(u,c){return this.glContext.gl.getAttribLocation(u,c)}}},2171:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.WebGLSessionHandler=void 0;const m=b(1315),p=b(5881),h=b(7860),d=b(4110),u=b(2757),c=b(7618),a=b(5243);l.WebGLSessionHandler=class{constructor(o,n){this.backend=o,this.context=n,this.layoutStrategy=new c.PreferLogicalStrategy(o.glContext.maxTextureSize),this.programManager=new u.ProgramManager(this.context.profiler,o.glContext,this.layoutStrategy),this.textureManager=new a.TextureManager(o.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:o.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=o.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new h.WebGLInferenceHandler(this)}onGraphInitialized(o){const n=o.getValues().filter(t=>t.from===-1&&t.tensor).map(t=>t.tensor.dataId);this.initializers=new Set(n)}isInitializer(o){return!!this.initializers&&this.initializers.has(o)}addInitializer(o){this.initializers.add(o)}getTextureData(o,n){return n?this.packedTextureDataCache.get(o):this.unpackedTextureDataCache.get(o)}setTextureData(o,n,t=!1){m.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),t?this.packedTextureDataCache.set(o,n):this.unpackedTextureDataCache.set(o,n)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.unpackedTextureDataCache=new Map}resolve(o,n,t){const e=(0,p.resolveOperator)(o,n,d.WEBGL_OP_RESOLVE_RULES);return{impl:e.opImpl,context:e.opInit?e.opInit(o,t):o}}}},9622:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.Uint8DataEncoder=l.RGBAFloatDataEncoder=l.RedFloat32DataEncoder=void 0;const m=b(1315);l.RedFloat32DataEncoder=class{constructor(p,h=1){if(h===1)this.internalFormat=p.R32F,this.format=p.RED,this.textureType=p.FLOAT,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=p.RGBA32F,this.format=p.RGBA,this.textureType=p.FLOAT,this.channelSize=h}}encode(p,h){let d,u;return p.constructor!==Float32Array&&(m.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),u=new Float32Array(p)),h*this.channelSize>p.length?(m.Logger.warning("Encoder","Source data too small. Allocating larger array"),u=p,d=this.allocate(h*this.channelSize),u.forEach((c,a)=>d[a]=c)):(u=p,d=u),d}allocate(p){return new Float32Array(4*p)}decode(p,h){return this.channelSize===1?p.filter((d,u)=>u%4==0).subarray(0,h):p.subarray(0,h)}},l.RGBAFloatDataEncoder=class{constructor(p,h=1,d){if(h!==1&&h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=p.RGBA,this.format=p.RGBA,this.channelSize=h,this.textureType=d||p.FLOAT}encode(p,h){let d=p;return this.channelSize===1&&(m.Logger.verbose("Encoder","Exploding into a larger array"),d=this.allocate(h),p.forEach((u,c)=>d[4*c]=u)),d}allocate(p){return new Float32Array(4*p)}decode(p,h){return this.channelSize===1?p.filter((d,u)=>u%4==0).subarray(0,h):p.subarray(0,h)}},l.Uint8DataEncoder=class{constructor(p,h=1){if(this.channelSize=4,h===1)this.internalFormat=p.ALPHA,this.format=p.ALPHA,this.textureType=p.UNSIGNED_BYTE,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=p.RGBA,this.format=p.RGBA,this.textureType=p.UNSIGNED_BYTE,this.channelSize=h}}encode(p,h){return new Uint8Array(p.buffer,p.byteOffset,p.byteLength)}allocate(p){return new Uint8Array(p*this.channelSize)}decode(p,h){if(p instanceof Uint8Array)return p.subarray(0,h);throw new Error(`Invalid array type: ${p.constructor}`)}}},7618:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.getBatchDim=l.sizeToSquarishShape=l.getRowsCols=l.sizeFromShape=l.isInt=l.parseAxisParam=l.squeezeShape=l.PreferLogicalStrategy=l.AlwaysKeepOriginalSizeStrategy=void 0;const m=b(1315),p=b(7273);function h(o,n){const t=[],e=[],r=n!=null&&Array.isArray(n)&&n.length===0,i=n==null||r?null:d(n,o).sort();let s=0;for(let f=0;f<o.length;++f){if(i!=null){if(i[s]===f&&o[f]!==1)throw new Error(`Can't squeeze axis ${f} since its dim '${o[f]}' is not 1`);(i[s]==null||i[s]>f)&&o[f]===1&&(t.push(o[f]),e.push(f)),i[s]<=f&&s++}o[f]!==1&&(t.push(o[f]),e.push(f))}return{newShape:t,keptDims:e}}function d(o,n){const t=n.length;return o=o==null?n.map((e,r)=>r):[].concat(o),(0,p.assert)(o.every(e=>e>=-t&&e<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${o}`),(0,p.assert)(o.every(u),()=>`All values in axis param must be integers but got axis ${o}`),o.map(e=>e<0?t+e:e)}function u(o){return o%1==0}function c(o){if(o.length===0)return 1;let n=o[0];for(let t=1;t<o.length;t++)n*=o[t];return n}function a(o){const n=Math.ceil(Math.sqrt(o));return[n,Math.ceil(o/n)]}l.AlwaysKeepOriginalSizeStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,n){if(o.length===0)return[1,1];const t=this.maxTextureSize;if(n&&n.breakAxis!==void 0){const i=n.breakAxis>=o.length?1:o.slice(n.breakAxis).reduce((f,g)=>f*g),s=n.breakAxis<=0?1:o.slice(0,n.breakAxis).reduce((f,g)=>f*g);if(!(i>t||s>t))return[i,s];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${n.breakAxis}`)}const e=o.reduce((i,s)=>i*s);let r=Math.floor(Math.sqrt(e));for(;r<t&&r<e&&e%r!=0;r++);if(r>=t||e%r!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${o}`);return[r,e/r]}},l.PreferLogicalStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,n){const t=this.computeTexture(o,n);return n&&n.isPacked&&(t[0]/=2,t[1]/=2),n&&n.reverseWH?[t[1],t[0]]:t}computeTexture(o,n){const t=n&&n.isPacked;if(o.length===0)return t?[2,2]:[1,1];let e=this.maxTextureSize;if(n&&n.breakAxis!==void 0){const s=n.breakAxis>=o.length?1:o.slice(n.breakAxis).reduce((g,y)=>g*y),f=n.breakAxis<=0?1:o.slice(0,n.breakAxis).reduce((g,y)=>g*y);if(!(s>e||f>e))return[s,f];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${n.breakAxis}`)}let r=o.slice(0);t&&(e*=2,r=r.map((s,f)=>f>=r.length-2?r[f]%2==0?r[f]:r[f]+1:r[f]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=h(r).newShape);const i=c(r);return r.length<=1&&i<=e?[1,i]:r.length===2&&r[0]<=e&&r[1]<=e?r:r.length===3&&r[0]*r[1]<=e&&r[2]<=e?[r[0]*r[1],r[2]]:r.length===3&&r[0]<=e&&r[1]*r[2]<=e?[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e?[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e?[r[0],r[1]*r[2]*r[3]]:t?a(i/4).map(s=>2*s):a(i)}},l.squeezeShape=h,l.parseAxisParam=d,l.isInt=u,l.sizeFromShape=c,l.getRowsCols=function(o){if(o.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[o.length>1?o[o.length-2]:1,o[o.length-1]]},l.sizeToSquarishShape=a,l.getBatchDim=function(o,n=2){return c(o.slice(0,o.length-n))}},3314:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createTextureLayoutFromShape=l.calculateTextureWidthAndHeight=l.createTextureLayoutFromTextureType=void 0;const m=b(7273),p=b(5639);l.createTextureLayoutFromTextureType=(h,d,u)=>{const c=u===p.TextureType.unpacked||u===p.TextureType.unpackedReversed?1:4,a=u===p.TextureType.packed,o=u===p.TextureType.unpackedReversed||u===p.TextureType.packed,n=u===p.TextureType.packedLastDimension?d.length-1:void 0,t=u===p.TextureType.packedLastDimension?d.map((e,r)=>r===d.length-1?4*e:e):void 0;return(0,l.createTextureLayoutFromShape)(h,d,c,t,{isPacked:a,reverseWH:o,breakAxis:n})},l.calculateTextureWidthAndHeight=(h,d,u)=>{const c=(0,l.createTextureLayoutFromTextureType)(h,d,u);return[c.width,c.height]},l.createTextureLayoutFromShape=(h,d,u=1,c,a)=>{const o=!(!a||!a.isPacked),[n,t]=h.computeTextureWH(o&&c||d,a),e=d.length;let r=d.slice(0);if(e===0&&(r=[1]),u===1)c=d;else if(o){if(u!==4)throw new Error("a packed texture must be 4-channel");c=d,e>0&&(r[e-1]=Math.ceil(r[e-1]/2)),e>1&&(r[e-2]=Math.ceil(r[e-2]/2))}else if(!c)throw new Error("Unpacked shape is needed when using channels > 1");return{width:n,height:t,channels:u,isPacked:o,shape:r,strides:m.ShapeUtil.computeStrides(r),unpackedShape:c,reversedWH:a&&a.reverseWH}}},5243:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.TextureManager=void 0;const m=b(1315);l.TextureManager=class{constructor(p,h,d,u){this.glContext=p,this.layoutStrategy=h,this.profiler=d,this.config=u,this.pendingRead=new Map,u.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(p,h,d,u){const c=this.toEncoderType(p),a=this.glContext.getEncoder(c,h.channels||1,u);if(h.isPacked&&u===1)throw new Error("not implemented");const o=h.width,n=h.height;let t,e;if(this.config.reuseTextures){t=`${o}x${n}_${a.format}_${a.internalFormat}_${a.textureType}`,e=this.inUseTextures.get(t),e||(e=[],this.inUseTextures.set(t,e));const i=this.idleTextures.get(t);if(i&&i.length>0){const s=i.pop();return e.push(s),u===1&&this.glContext.updateTexture(s,o,n,a,this.toTextureData(p,d)),s}}m.Logger.verbose("TextureManager",`Creating new texture of size ${h.width}x${h.height}`);const r=this.glContext.allocateTexture(o,n,a,this.toTextureData(p,d));return this.config.reuseTextures&&(e.push(r),this.textureLookup.set(r,t)),r}readTexture(p,h,d){return d||(d=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const u=p.shape.reduce((a,o)=>a*o)*d,c=this.glContext.readTexture(p.texture,p.width,p.height,u,this.toEncoderType(h),d);return this.toTensorData(h,c)})}async readTextureAsync(p,h,d){const u=p.tensor.dataId;if(d||(d=1),this.pendingRead.has(u)){const c=this.pendingRead.get(u);return new Promise(a=>c==null?void 0:c.push(a))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(u,[]);const c=p.shape.reduce((t,e)=>t*e)*d;await this.glContext.createAndWaitForFence();const a=this.glContext.readTexture(p.texture,p.width,p.height,c,this.toEncoderType(h),d),o=this.toTensorData(h,a),n=this.pendingRead.get(u);return this.pendingRead.delete(u),n==null||n.forEach(t=>t(o)),o})}readUint8TextureAsFloat(p){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const h=p.shape.reduce((u,c)=>u*c),d=this.glContext.readTexture(p.texture,p.width,p.height,4*h,"byte",4);return new Float32Array(d.buffer,d.byteOffset,h)})}releaseTexture(p,h){let d;if(this.config.reuseTextures&&(d=this.textureLookup.get(p.texture),d)){h&&this.textureLookup.delete(d);const u=this.inUseTextures.get(d);if(u){const c=u.indexOf(p.texture);if(c!==-1){u.splice(c,1);let a=this.idleTextures.get(d);a||(a=[],this.idleTextures.set(d,a)),a.push(p.texture)}}}d&&!h||(m.Logger.verbose("TextureManager",`Deleting texture of size ${p.width}x${p.height}`),this.glContext.deleteTexture(p.texture))}toTensorData(p,h){switch(p){case"int16":return h instanceof Int16Array?h:Int16Array.from(h);case"int32":return h instanceof Int32Array?h:Int32Array.from(h);case"int8":return h instanceof Int8Array?h:Int8Array.from(h);case"uint16":return h instanceof Uint16Array?h:Uint16Array.from(h);case"uint32":return h instanceof Uint32Array?h:Uint32Array.from(h);case"uint8":case"bool":return h instanceof Uint8Array?h:Uint8Array.from(h);case"float32":return h instanceof Float32Array?h:Float32Array.from(h);case"float64":return h instanceof Float64Array?h:Float64Array.from(h);default:throw new Error(`TensorData type ${p} is not supported`)}}toTextureData(p,h){if(h)return h instanceof Float32Array?h:new Float32Array(h)}toEncoderType(p){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(R,l)=>{var b;Object.defineProperty(l,"__esModule",{value:!0}),l.TextureType=void 0,(b=l.TextureType||(l.TextureType={}))[b.unpacked=0]="unpacked",b[b.unpackedReversed=1]="unpackedReversed",b[b.packed=2]="packed",b[b.downloadUint8AsFloat=3]="downloadUint8AsFloat",b[b.packedLastDimension=4]="packedLastDimension"},432:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.getGlChannels=l.getCoordsDataType=l.getSqueezedParams=l.squeezeInputShape=l.generateShaderFuncNameFromInputSamplerNameAtOutCoords=l.generateShaderFuncNameFromInputSamplerName=l.repeatedTry=l.getPackedShape=void 0;const m=b(7273);l.getPackedShape=function(p){const h=p.length;return p.slice(0,h-1).concat(p[h-1]/4)},l.repeatedTry=async function(p,h=u=>0,d){return new Promise((u,c)=>{let a=0;const o=()=>{if(p())return void u();a++;const n=h(a);d!=null&&a>=d?c():setTimeout(o,n)};o()})},l.generateShaderFuncNameFromInputSamplerName=function(p){return(0,m.assert)(p!==void 0&&p.length!==0,()=>"empty string found for sampler name"),"get"+p.charAt(0).toUpperCase()+p.slice(1)},l.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(p){return(0,m.assert)(p!==void 0&&p.length!==0,()=>"empty string found for sampler name"),"get"+p.charAt(0).toUpperCase()+p.slice(1)+"AtOutCoords"},l.squeezeInputShape=function(p,h){let d=JSON.parse(JSON.stringify(p));return d=h,d},l.getSqueezedParams=function(p,h){return h.map(d=>p[d]).join(", ")},l.getCoordsDataType=function(p){if(p<=1)return"int";if(p===2)return"ivec2";if(p===3)return"ivec3";if(p===4)return"ivec4";if(p===5)return"ivec5";if(p===6)return"ivec6";throw Error(`GPU for rank ${p} is not yet supported`)},l.getGlChannels=function(p=6){return["x","y","z","w","u","v"].slice(0,p)}},3389:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.createNewWebGLContext=l.createWebGLContext=void 0;const m=b(1315),p=b(3524),h={};function d(u,c){let a;const o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!c||c==="webgl2")&&(a=u.getContext("webgl2",o),a))try{return new p.WebGLContext(a,2)}catch(n){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!c||c==="webgl")&&(a=u.getContext("webgl",o)||u.getContext("experimental-webgl",o),a))try{return new p.WebGLContext(a,1)}catch(n){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error("WebGL is not supported")}l.createWebGLContext=function u(c){let a;if(c&&c!=="webgl2"||!("webgl2"in h)?c&&c!=="webgl"||!("webgl"in h)||(a=h.webgl):a=h.webgl2,!a)try{a=d(function(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}(),c)}catch{a=d(function(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");const t=document.createElement("canvas");return t.width=1,t.height=1,t}(),c)}c=c||a.version===1?"webgl":"webgl2";const o=a.gl;return h[c]=a,o.isContextLost()?(delete h[c],u(c)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),a)},l.createNewWebGLContext=d},3524:function(R,l,b){var m=this&&this.__createBinding||(Object.create?function(o,n,t,e){e===void 0&&(e=t);var r=Object.getOwnPropertyDescriptor(n,t);r&&!("get"in r?!n.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return n[t]}}),Object.defineProperty(o,e,r)}:function(o,n,t,e){e===void 0&&(e=t),o[e]=n[t]}),p=this&&this.__setModuleDefault||(Object.create?function(o,n){Object.defineProperty(o,"default",{enumerable:!0,value:n})}:function(o,n){o.default=n}),h=this&&this.__importStar||function(o){if(o&&o.__esModule)return o;var n={};if(o!=null)for(var t in o)t!=="default"&&Object.prototype.hasOwnProperty.call(o,t)&&m(n,o,t);return p(n,o),n};Object.defineProperty(l,"__esModule",{value:!0}),l.WebGLContext=l.linearSearchLastTrue=void 0;const d=b(2235),u=h(b(9622)),c=b(432);function a(o){let n=0;for(;n<o.length&&o[n]();++n);return n-1}l.linearSearchLastTrue=a,l.WebGLContext=class{constructor(o,n){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=o,this.version=n,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(o,n,t,e){const r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE);const s=e?t.encode(e,o*n):null;return r.texImage2D(r.TEXTURE_2D,0,t.internalFormat,o,n,0,t.format,t.textureType,s),this.checkError(),i}updateTexture(o,n,t,e,r){const i=this.gl;i.bindTexture(i.TEXTURE_2D,o);const s=e.encode(r,n*t);i.texSubImage2D(i.TEXTURE_2D,0,0,0,n,t,e.format,e.textureType,s),this.checkError()}attachFramebuffer(o,n,t){const e=this.gl;e.bindTexture(e.TEXTURE_2D,o),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0),this.checkError(),e.viewport(0,0,n,t),e.scissor(0,0,n,t)}readTexture(o,n,t,e,r,i){const s=this.gl;i||(i=1),this.frameBufferBound||this.attachFramebuffer(o,n,t);const f=this.getEncoder(r,i),g=f.allocate(n*t);return s.bindTexture(s.TEXTURE_2D,o),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,o,0),s.readPixels(0,0,n,t,s.RGBA,f.textureType,g),this.checkError(),f.decode(g,e)}isFramebufferReady(){return!0}getActiveTexture(){const o=this.gl;return"TEXTURE"+(o.getParameter(this.gl.ACTIVE_TEXTURE)-o.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(o,n){const t=this.gl;t.vertexAttribPointer(o,3,t.FLOAT,!1,20,0),t.enableVertexAttribArray(o),n!==-1&&(t.vertexAttribPointer(n,2,t.FLOAT,!1,20,12),t.enableVertexAttribArray(n)),this.checkError()}createProgram(o,n){const t=this.gl,e=t.createProgram();return t.attachShader(e,o),t.attachShader(e,n),t.linkProgram(e),e}compileShader(o,n){const t=this.gl,e=t.createShader(n);if(!e)throw new Error(`createShader() returned null with type ${n}`);if(t.shaderSource(e,o),t.compileShader(e),t.getShaderParameter(e,t.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(e)}
Shader source:
${o}`);return e}deleteShader(o){this.gl.deleteShader(o)}bindTextureToUniform(o,n,t){const e=this.gl;e.activeTexture(e.TEXTURE0+n),this.checkError(),e.bindTexture(e.TEXTURE_2D,o),this.checkError(),e.uniform1i(t,n),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(d.env.debug){const o=this.gl,n=o.getError();let t="";switch(n){case o.NO_ERROR:return;case o.INVALID_ENUM:t="INVALID_ENUM";break;case o.INVALID_VALUE:t="INVALID_VALUE";break;case o.INVALID_OPERATION:t="INVALID_OPERATION";break;case o.INVALID_FRAMEBUFFER_OPERATION:t="INVALID_FRAMEBUFFER_OPERATION";break;case o.OUT_OF_MEMORY:t="OUT_OF_MEMORY";break;case o.CONTEXT_LOST_WEBGL:t="CONTEXT_LOST_WEBGL";break;default:t=`Unknown WebGL Error: ${n.toString(16)}`}throw new Error(t)}}deleteTexture(o){this.gl.deleteTexture(o)}deleteProgram(o){this.gl.deleteProgram(o)}getEncoder(o,n,t=0){if(this.version===2)return new u.RedFloat32DataEncoder(this.gl,n);switch(o){case"float":return t===1||this.isRenderFloat32Supported?new u.RGBAFloatDataEncoder(this.gl,n):new u.RGBAFloatDataEncoder(this.gl,n,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new u.Uint8DataEncoder(this.gl,n);default:throw new Error(`Invalid dataType: ${o}`)}}clearActiveTextures(){const o=this.gl;for(let n=0;n<this.maxTextureImageUnits;++n)o.activeTexture(o.TEXTURE0+n),o.bindTexture(o.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const o=this.gl;o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(this.framebuffer),o.bindBuffer(o.ARRAY_BUFFER,null),o.deleteBuffer(this.vertexbuffer),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null),o.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const o=this.gl,n=o.createBuffer();if(!n)throw new Error("createBuffer() returned null");const t=this.createDefaultGeometry();return o.bindBuffer(o.ARRAY_BUFFER,n),o.bufferData(o.ARRAY_BUFFER,t,o.STATIC_DRAW),this.checkError(),n}createFramebuffer(){const o=this.gl.createFramebuffer();if(!o)throw new Error("createFramebuffer returned null");return o}queryVitalParameters(){const o=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=o.getParameter(o.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=o.getParameter(o.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const o=this.gl,n=o.createTexture();o.bindTexture(o.TEXTURE_2D,n);const t=this.version===2?o.RGBA32F:o.RGBA;o.texImage2D(o.TEXTURE_2D,0,t,1,1,0,o.RGBA,o.FLOAT,null);const e=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,e),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,n,0);const r=o.checkFramebufferStatus(o.FRAMEBUFFER)===o.FRAMEBUFFER_COMPLETE;return o.bindTexture(o.TEXTURE_2D,null),o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteTexture(n),o.deleteFramebuffer(e),r}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const o=this.gl;let n,t,e,r,i;try{n=o.createTexture(),t=o.createFramebuffer(),o.bindTexture(o.TEXTURE_2D,n);const s=this.version===2?o.RGBA32F:o.RGBA;return o.texImage2D(o.TEXTURE_2D,0,s,1,1,0,o.RGBA,o.FLOAT,null),o.bindFramebuffer(o.FRAMEBUFFER,t),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,n,0),o.enable(o.BLEND),e=o.createShader(o.VERTEX_SHADER),!!e&&(o.shaderSource(e,"void main(){}"),o.compileShader(e),r=o.createShader(o.FRAGMENT_SHADER),!!r&&(o.shaderSource(r,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),o.compileShader(r),i=o.createProgram(),!!i&&(o.attachShader(i,e),o.attachShader(i,r),o.linkProgram(i),o.useProgram(i),o.drawArrays(o.POINTS,0,1),o.getError()===o.NO_ERROR)))}finally{o.disable(o.BLEND),i&&o.deleteProgram(i),e&&o.deleteShader(e),r&&o.deleteShader(r),t&&(o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(t)),n&&(o.bindTexture(o.TEXTURE_2D,null),o.deleteTexture(n))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const o=this.gl,n=this.disjointTimerQueryWebgl2Extension,t=o.createQuery();return o.beginQuery(n.TIME_ELAPSED_EXT,t),t}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const o=this.gl,n=this.disjointTimerQueryWebgl2Extension;o.endQuery(n.TIME_ELAPSED_EXT)}}isTimerResultAvailable(o){let n=!1,t=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl,r=this.disjointTimerQueryWebgl2Extension;n=e.getQueryParameter(o,e.QUERY_RESULT_AVAILABLE),t=e.getParameter(r.GPU_DISJOINT_EXT)}return n&&!t}getTimerResult(o){let n=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const t=this.gl;n=t.getQueryParameter(o,t.QUERY_RESULT),t.deleteQuery(o)}return n/1e6}async waitForQueryAndGetTime(o){return await(0,c.repeatedTry)(()=>this.isTimerResultAvailable(o)),this.getTimerResult(o)}async createAndWaitForFence(){const o=this.createFence(this.gl);return this.pollFence(o)}createFence(o){let n;const t=o,e=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return o.flush(),n=e===null?()=>!0:()=>{const r=t.clientWaitSync(e,0,0);return r===t.ALREADY_SIGNALED||r===t.CONDITION_SATISFIED},{query:e,isFencePassed:n}}async pollFence(o){return new Promise(n=>{this.addItemToPoll(()=>o.isFencePassed(),()=>n())})}pollItems(){const o=a(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=o;++n){const{resolveFn:t}=this.itemsToPoll[n];t()}this.itemsToPoll=this.itemsToPoll.slice(o+1)}async addItemToPoll(o,n){this.itemsToPoll.push({isDoneFn:o,resolveFn:n}),this.itemsToPoll.length>1||await(0,c.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.ExecutionPlan=void 0;const m=b(1315);class p{constructor(d,u){this.op=d,this.node=u}}l.ExecutionPlan=class{constructor(h,d,u){this.graph=h,this.profiler=u,this.initialize(d)}initialize(h){this.profiler.event("session","ExecutionPlan.initialize",()=>{const d=this.graph.getNodes();if(d.length!==h.length)throw new Error("The size of nodes and OPs do not match.");this._ops=h.map((u,c)=>new p(u,d[c])),this.reset(),this._starter=[],this._ops.forEach((u,c)=>{let a=!0;for(const o of u.node.inputs)if(!this._values[o]&&this.graph.getInputIndices().indexOf(o)===-1){a=!1;break}a&&this._starter.push(c)})})}reset(){this._values=this.graph.getValues().map(h=>h.tensor)}async execute(h,d){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const u=h.createInferenceHandler(),c=this.graph.getInputIndices();if(d.length!==c.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${d.length} expected: ${c.length}`);d.forEach((r,i)=>{const s=c[i];this._values[s]=r});const a=this._starter.slice(0),o=this.graph.getValues(),n=this.graph.getNodes();let t=0;for(;t<a.length;){const r=a[t++],i=this._ops[r],s=i.node.inputs.map(v=>this._values[v]);if(s.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${i.node}`);const f=s;m.Logger.verbose("ExecPlan",`Runing op:${i.node.name} (${f.map((v,w)=>`'${i.node.inputs[w]}': ${v.type}[${v.dims.join(",")}]`).join(", ")})`);const g=await this.profiler.event("node",i.node.name,async()=>i.op.impl(u,f,i.op.context));if(g.length!==i.node.outputs.length)throw new Error("the size of output does not match model definition.");g.forEach((v,w)=>{const T=i.node.outputs[w];if(this._values[T])throw new Error(`output [${T}] already has value: op:${i.node.name}`);this._values[T]=v});const y=new Set;g.forEach((v,w)=>{const T=i.node.outputs[w];for(const x of o[T].to){const A=n[x];let D=!0;for(const $ of A.inputs)if(!this._values[$]){D=!1;break}D&&y.add(x)}}),a.push(...y)}const e=[];for(let r=0;r<this.graph.getOutputIndices().length;r++){const i=this.graph.getOutputIndices()[r],s=this._values[i];if(s===void 0)throw new Error(`required output [${i}] does not have value`);i===0?await s.getData():s.data,e.push(s)}return m.Logger.verbose("ExecPlan","disposing of inferenceHandler"),u.dispose(),e})}}},4662:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.Graph=void 0;const m=b(6874),p=b(5127),h=b(2446),d=b(9240),u=b(7273);var c=p.onnxruntime.experimental.fbs;l.Graph={from:(t,e)=>new n(t,e)};class a{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=u.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}}class o{constructor(e,r){e instanceof h.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new m.Attribute(e.attribute)):e instanceof c.Node&&(this.name=r??e.name(),this.opType=e.opType(),this.attributes=new m.Attribute(u.ProtoUtil.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class n{constructor(e,r){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof h.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else{if(!(e instanceof c.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(e)}}buildGraphFromOnnxFormat(e){const r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const i=new Map;if(!e.input)throw new Error("missing information in graph: input");const s=[];for(const f of e.input){if(r.has(f.name))throw new Error(`duplicated input name: ${f.name}`);const g=this._allData.push(new a(f))-1;r.set(f.name,g),s.push(f.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(const f of e.initializer){let g=r.get(f.name);if(g===void 0){const y=new a;y.type={shape:{dims:u.ProtoUtil.tensorDimsFromProto(f.dims)},tensorType:u.ProtoUtil.tensorDataTypeFromProto(f.dataType)},g=this._allData.push(y)-1,r.set(f.name,g)}this._allData[g]._from=-1,this._allData[g].tensor=d.Tensor.fromProto(f)}for(let f=0;f<this._allData.length;f++)this._allData[f].tensor||(this._allInputIndices.push(f),this._allInputNames.push(s[f]));if(!e.output)throw new Error("missing information in graph: output");for(const f of e.output){if(r.has(f.name))throw new Error(`duplicated output name: ${f.name}`);const g=this._allData.push(new a(f))-1;r.set(f.name,g),this._allOutputIndices.push(g),this._allOutputNames.push(f.name)}if(!e.node)throw new Error("missing information in graph: node");for(const f of e.node){if(!f.name)for(let y=0;;y++){const v=`unnamed_${f.opType}_${y}`;if(!i.has(v)){f.name=v;break}}if(i.has(f.name))throw new Error(`duplicated node name: ${f.name}`);const g=this._nodes.push(new o(f))-1;i.set(f.name,g)}for(let f=0;f<this._nodes.length;f++){const g=this._nodes[f],y=e.node[f];if(!y.output)throw new Error(`missing output for node: ${y.name}`);for(const v of y.output){let w=r.get(v);if(w===void 0&&(w=this._allData.push(new a)-1,r.set(v,w)),g.outputs.push(w),this._allData[w]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${w}`);if(this._allData[w]._from=f,y.opType==="Constant"){if(!y.attribute||y.attribute.length!==1||!y.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!y.output||y.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");g.outputs.pop(),g.executeNode=!1,this._allData[w]._from=-1,this._allData[w].tensor=d.Tensor.fromProto(y.attribute[0].t)}}}for(let f=0;f<this._nodes.length;f++){const g=this._nodes[f],y=e.node[f];if(!y.input)throw new Error(`missing input for node: ${y.name}`);for(const v of y.input){const w=r.get(v);if(w===void 0){if(v===""&&(y.input.length===3||y.input.length===4)&&y.opType==="Resize")continue;throw new Error(`unrecognized input '${v}' for node: ${y.name}`)}g.inputs.push(w),this._allData[w]._to.push(f)}}return!0}buildGraphFromOrtFormat(e){var r,i,s;const f=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const g=new Map,y=[];for(let v=0;v<e.inputsLength();v++){const w=e.inputs(v);if(f.has(w))throw new Error(`duplicated input name: ${w}`);for(let T=0;T<e.nodeArgsLength();T++)if(((r=e.nodeArgs(T))===null||r===void 0?void 0:r.name())===w){const x=new a;if(((s=(i=e.nodeArgs(T))===null||i===void 0?void 0:i.type())===null||s===void 0?void 0:s.valueType())!==c.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const A=e.nodeArgs(T).type().value(new c.TensorTypeAndShape),D=u.ProtoUtil.tensorDataTypeFromProto(A.elemType()),$=A.shape(),j=[];for(let S=0;S<$.dimLength();S++)j.push(u.LongUtil.longToNumber($.dim(S).value().dimValue()));x.type={shape:{dims:j},tensorType:D};const M=this._allData.push(x)-1;f.set(w,M),y.push(w)}}for(let v=0;v<e.initializersLength();v++){const w=e.initializers(v);let T=f.get(w.name());if(T===void 0){const x=new a,A=u.ProtoUtil.tensorDimsFromORTFormat(w),D=u.ProtoUtil.tensorDataTypeFromProto(w.dataType());x.type={shape:{dims:A},tensorType:D},T=this._allData.push(x)-1,f.set(w.name(),T)}this._allData[T]._from=-1,this._allData[T].tensor=d.Tensor.fromOrtTensor(w)}for(let v=0;v<this._allData.length;v++)this._allData[v].tensor||(this._allInputIndices.push(v),this._allInputNames.push(y[v]));for(let v=0;v<e.outputsLength();v++){const w=e.outputs(v);if(f.has(w))throw new Error(`duplicated output name: ${w}`);const T=this._allData.push(new a)-1;f.set(w,T),this._allOutputIndices.push(T),this._allOutputNames.push(w)}if(!e.nodes)throw new Error("missing information in graph: node");for(let v=0;v<e.nodesLength();v++){const w=e.nodes(v);let T=w.name();if(!T)for(let A=0;T=`unnamed_${w.opType()}_${A}`,g.has(T);A++);if(g.has(T))throw new Error(`duplicated node name: ${T}`);const x=this._nodes.push(new o(w,T))-1;g.set(T,x)}for(let v=0;v<this._nodes.length;v++){const w=this._nodes[v],T=e.nodes(v);if(T==null)throw new Error(`No node exists at index ${v}`);if((T==null?void 0:T.outputsLength())===0)throw new Error(`missing output for node: ${T.name}`);for(let x=0;x<(T==null?void 0:T.outputsLength());x++){const A=T==null?void 0:T.outputs(x);let D=f.get(A);if(D===void 0&&(D=this._allData.push(new a)-1,f.set(A,D)),w.outputs.push(D),this._allData[D]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${D}`);if(this._allData[D]._from=v,T.opType()==="Constant"){if(T.attributesLength()!==1||!T.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(T.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");w.outputs.pop(),w.executeNode=!1,this._allData[D]._from=-1,this._allData[D].tensor=d.Tensor.fromOrtTensor(T.attributes(0).t())}}}for(let v=0;v<this._nodes.length;v++){const w=this._nodes[v],T=e.nodes(v);if(T.inputsLength()===0)throw new Error(`missing input for node: ${T.name}`);for(let x=0;x<T.inputsLength();x++){const A=T.inputs(x),D=f.get(A);if(D===void 0)throw new Error(`unrecognized input '${A}' for node: ${T.name()}`);w.inputs.push(D),this._allData[D]._to.push(v)}}}checkIsAcyclic(){const e=new Set;this._allInputIndices.forEach(s=>{this._allData[s]._to.forEach(f=>{e.add(f)})});const r=Array.from(e),i=new Array(this._nodes.length).fill("white");for(;r.length>0;){const s=r.pop();i[s]==="gray"?i[s]="black":(r.push(s),i[s]="gray",this._nodes[s].outputs.forEach(f=>{const g=this._allData[f];if(g.tensor!==void 0)throw new Error("node outputs should not be initialized");if(g._from!==s)throw new Error("from property of the Value object doesn't match index of Node being processed");g._to.forEach(y=>{if(i[y]==="gray")throw new Error("model graph is cyclic");i[y]==="white"&&r.push(y)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0;const r=new Array(this._nodes.length,0);let i=0;for(let s=0;s<this._nodes.length;s++)r[s]=i,this._nodes[s].executeNode?(i!==s&&(this._nodes[i]=this._nodes[s]),i++):this._nodes[s].outputs.forEach(f=>{this._allData[f]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let s=0;s<this._allData.length;s++){const f=this._allData[s];f._from!==void 0&&f._from!==-1&&f._from!==-2&&(f._from=r[f._from]);for(let g=0;g<f._to.length;g++){if(!(f._to[g]>=0))throw new Error("Trying to update a removed node");f._to[g]=r[f._to[g]]}}e=0;for(let s=0;s<this._allData.length;s++)if(this._allData[s].from!==-2||this._allOutputIndices.indexOf(s+e)!==-1){if(e>0){let f=-1;this._allData[s].from!==void 0&&this._allData[s].from!==-1?(f=this._nodes[this._allData[s].from].outputs.indexOf(s+e),f!==-1&&(this._nodes[this._allData[s].from].outputs[f]=s)):(f=this._allInputIndices.indexOf(s+e),f!==-1&&(this._allInputIndices[f]=s)),this._allData[s].to.forEach(g=>{f=this._nodes[g].inputs.indexOf(s+e),f!==-1&&(this._nodes[g].inputs[f]=s)}),this._allData[s].to.length===0&&(f=this._allOutputIndices.indexOf(s+e),f!==-1&&(this._allOutputIndices[f]=s))}}else e++,this._allData.splice(s,1),s--}deleteNode(e){const r=this._nodes[e];if(r.outputs.length>1){for(let y=1;y<r.outputs.length;y++)if(this._allData[r.outputs[y]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;const i=r.inputs[0],s=r.outputs[0],f=this._allData[s].to;for(let y=0;y<r.inputs.length;y++){const v=this._allData[r.inputs[y]].to.indexOf(e);if(v===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[y]].to.splice(v,1)}this._allData[s]._to=[];const g=this._allOutputIndices.indexOf(s);if(g!==-1&&(this._allOutputIndices[g]=i),f&&f.length>0)for(const y of f){const v=this._nodes[y].inputs.indexOf(s);if(v===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[y].inputs[v]=i,this._allData[i].to.push(y)}}removeAllDropoutNodes(){let e=0;for(const r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(const r of this._nodes)r.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const e of this._nodes)if(e.opType==="Conv"){const r=this._allData[e.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){const i=this._nodes[r[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{e.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[u.MIN_CLIP,u.MAX_CLIP])}else{if(!(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0))continue;e.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]])}e.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}},1315:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.now=l.Profiler=l.Logger=void 0;const b={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},m={none:new class{log(o,n,t){}},console:new class{log(o,n,t){console.log(`${this.color(o)} ${t?"\x1B[35m"+t+"\x1B[0m ":""}${n}`)}color(o){switch(o){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${o}`)}}}},p={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let h={"":p};function d(o,n,t,e){if(n===void 0)return r=o,{verbose:d.verbose.bind(null,r),info:d.info.bind(null,r),warning:d.warning.bind(null,r),error:d.error.bind(null,r),fatal:d.fatal.bind(null,r)};if(t===void 0)u(o,n);else if(typeof t=="number"&&e===void 0)u(o,n);else if(typeof t=="string"&&e===void 0)u(o,t,0,n);else{if(typeof t!="string"||typeof e!="number")throw new TypeError("input is valid");u(o,t,0,n)}var r}function u(o,n,t,e){const r=h[e||""]||h[""];b[o]<b[r.minimalSeverity]||(r.logDateTime&&(n=`${new Date().toISOString()}|${n}`),r.logSourceLocation,m[r.provider].log(o,n,e))}(function(o){function n(e){h={},t("",e||{})}function t(e,r){if(e==="*")n(r);else{const i=h[e]||p;h[e]={provider:r.provider||i.provider,minimalSeverity:r.minimalSeverity||i.minimalSeverity,logDateTime:r.logDateTime===void 0?i.logDateTime:r.logDateTime,logSourceLocation:r.logSourceLocation===void 0?i.logSourceLocation:r.logSourceLocation}}}o.verbose=function(e,r){o("verbose",e,r)},o.info=function(e,r){o("info",e,r)},o.warning=function(e,r){o("warning",e,r)},o.error=function(e,r){o("error",e,r)},o.fatal=function(e,r){o("fatal",e,r)},o.reset=n,o.set=t,o.setWithEnv=function(e){const r={};e.logLevel&&(r.minimalSeverity=e.logLevel),t("",r)}})(d||(d={})),l.Logger=d;class c{constructor(n,t,e,r,i,s){this.category=n,this.name=t,this.startTime=e,this.endCallback=r,this.timer=i,this.ctx=s}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class a{constructor(n,t,e,r){this.category=n,this.name=t,this.startTime=e,this.endTime=r}}l.Profiler=class{static create(o){return o===void 0?new this:new this(o.maxNumberEvents,o.flushBatchSize,o.flushIntervalInMilliseconds)}constructor(o,n,t){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=o===void 0?1e4:o,this._flushBatchSize=n===void 0?10:n,this._flushIntervalInMilliseconds=t===void 0?5e3:t}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,l.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(o,n,t,e){const r=this._started?this.begin(o,n,e):void 0;let i=!1;const s=t();if(s&&typeof s.then=="function")return i=!0,new Promise((f,g)=>{s.then(async y=>{r&&await r.end(),f(y)},async y=>{r&&await r.end(),g(y)})});if(!i&&r){const f=r.end();if(f&&typeof f.then=="function")return new Promise((g,y)=>{f.then(()=>{g(s)},v=>{y(v)})})}return s}begin(o,n,t){if(!this._started)throw new Error("profiler is not started yet");if(t===void 0){const e=(0,l.now)();return this.flush(e),new c(o,n,e,r=>this.endSync(r))}{const e=t.beginTimer();return new c(o,n,0,async r=>this.end(r),e,t)}}async end(o){const n=await o.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,n)),this.flush(n))}endSync(o){const n=(0,l.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,n)),this.flush(n))}logOneEvent(o){l.Logger.verbose(`Profiler.${o.category}`,`${(o.endTime-o.startTime).toFixed(2)}ms on event '${o.name}' at ${o.endTime.toFixed(2)}`)}flush(o){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||o-this._flushTime>=this._flushIntervalInMilliseconds){for(const n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,l.now)()}}get started(){return this._started}},l.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.Model=void 0;const m=b(5686),p=b(4662),h=b(5127),d=b(2446),u=b(7273);var c=h.onnxruntime.experimental.fbs;l.Model=class{constructor(){}load(a,o,n){if(!n)try{return void this.loadFromOnnxFormat(a,o)}catch(t){if(n!==void 0)throw t}this.loadFromOrtFormat(a,o)}loadFromOnnxFormat(a,o){const n=d.onnx.ModelProto.decode(a);if(u.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map(t=>({domain:t.domain,version:u.LongUtil.longToNumber(t.version)})),this._graph=p.Graph.from(n.graph,o)}loadFromOrtFormat(a,o){const n=new m.flatbuffers.ByteBuffer(a),t=c.InferenceSession.getRootAsInferenceSession(n).model();if(u.LongUtil.longToNumber(t.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let e=0;e<t.opsetImportLength();e++){const r=t.opsetImport(e);this._opsets.push({domain:r==null?void 0:r.domain(),version:u.LongUtil.longToNumber(r.version())})}this._graph=p.Graph.from(t.graph(),o)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.FLOAT_TYPES=l.INT_TYPES=l.NUMBER_TYPES=void 0,l.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],l.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],l.FLOAT_TYPES=["float32","float64"]},5881:(R,l)=>{function b(m,p){if(p.endsWith("+")){const h=Number.parseInt(p.substring(0,p.length-1),10);return!isNaN(h)&&h<=m}if(p.split("-").length===2){const h=p.split("-"),d=Number.parseInt(h[0],10),u=Number.parseInt(h[1],10);return!isNaN(d)&&!isNaN(u)&&d<=m&&m<=u}return Number.parseInt(p,10)===m}Object.defineProperty(l,"__esModule",{value:!0}),l.resolveOperator=void 0,l.resolveOperator=function(m,p,h){for(const d of h){const u=d[0],c=d[1],a=d[2],o=d[3],n=d[4];if(m.opType===u){for(const t of p)if((t.domain===c||t.domain==="ai.onnx"&&c==="")&&b(t.version,a))return{opImpl:o,opInit:n}}}throw new TypeError(`cannot resolve operator '${m.opType}' with opsets: ${p.map(d=>`${d.domain||"ai.onnx"} v${d.version}`).join(", ")}`)}},5127:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.onnxruntime=void 0;const m=b(5686);var p,h;p=l.onnxruntime||(l.onnxruntime={}),function(d){(function(u){u[u.UNDEFINED=0]="UNDEFINED",u[u.FLOAT=1]="FLOAT",u[u.INT=2]="INT",u[u.STRING=3]="STRING",u[u.TENSOR=4]="TENSOR",u[u.GRAPH=5]="GRAPH",u[u.FLOATS=6]="FLOATS",u[u.INTS=7]="INTS",u[u.STRINGS=8]="STRINGS",u[u.TENSORS=9]="TENSORS",u[u.GRAPHS=10]="GRAPHS",u[u.SPARSE_TENSOR=11]="SPARSE_TENSOR",u[u.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(d.AttributeType||(d.AttributeType={}))}((h=p.experimental||(p.experimental={})).fbs||(h.fbs={})),function(d){(function(u){(function(c){(function(a){a[a.UNKNOWN=0]="UNKNOWN",a[a.VALUE=1]="VALUE",a[a.PARAM=2]="PARAM"})(c.DimensionValueType||(c.DimensionValueType={}))})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){(function(a){a[a.UNDEFINED=0]="UNDEFINED",a[a.FLOAT=1]="FLOAT",a[a.UINT8=2]="UINT8",a[a.INT8=3]="INT8",a[a.UINT16=4]="UINT16",a[a.INT16=5]="INT16",a[a.INT32=6]="INT32",a[a.INT64=7]="INT64",a[a.STRING=8]="STRING",a[a.BOOL=9]="BOOL",a[a.FLOAT16=10]="FLOAT16",a[a.DOUBLE=11]="DOUBLE",a[a.UINT32=12]="UINT32",a[a.UINT64=13]="UINT64",a[a.COMPLEX64=14]="COMPLEX64",a[a.COMPLEX128=15]="COMPLEX128",a[a.BFLOAT16=16]="BFLOAT16",a[a.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",a[a.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",a[a.FLOAT8E5M2=19]="FLOAT8E5M2",a[a.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"})(c.TensorDataType||(c.TensorDataType={}))})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){(function(a){a[a.Primitive=0]="Primitive",a[a.Fused=1]="Fused"})(c.NodeType||(c.NodeType={}))})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){(function(a){a[a.NONE=0]="NONE",a[a.tensor_type=1]="tensor_type",a[a.sequence_type=2]="sequence_type",a[a.map_type=3]="map_type"})(c.TypeInfoValue||(c.TypeInfoValue={}))})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsShape(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}dim(n,t){let e=this.bb.__offset(this.bb_pos,4);return e?(t||new d.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,t){n.addFieldOffset(0,t,0)}static createDimVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startDimVector(n,t){n.startVector(4,t,4)}static endShape(n){return n.endObject()}static createShape(n,t){return a.startShape(n),a.addDim(n,t),a.endShape(n)}}c.Shape=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsDimension(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}value(n){let t=this.bb.__offset(this.bb_pos,4);return t?(n||new d.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}denotation(n){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,n):null}static startDimension(n){n.startObject(2)}static addValue(n,t){n.addFieldOffset(0,t,0)}static addDenotation(n,t){n.addFieldOffset(1,t,0)}static endDimension(n){return n.endObject()}static createDimension(n,t,e){return a.startDimension(n),a.addValue(n,t),a.addDenotation(n,e),a.endDimension(n)}}c.Dimension=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsDimensionValue(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):d.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,t){n.addFieldInt8(0,t,d.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(n,t){n.addFieldInt64(1,t,n.createLong(0,0))}static addDimParam(n,t){n.addFieldOffset(2,t,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,t,e,r){return a.startDimensionValue(n),a.addDimType(n,t),a.addDimValue(n,e),a.addDimParam(n,r),a.endDimensionValue(n)}}c.DimensionValue=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsTensorTypeAndShape(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):d.experimental.fbs.TensorDataType.UNDEFINED}shape(n){let t=this.bb.__offset(this.bb_pos,6);return t?(n||new d.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,t){n.addFieldInt32(0,t,d.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(n,t){n.addFieldOffset(1,t,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,t,e){return a.startTensorTypeAndShape(n),a.addElemType(n,t),a.addShape(n,e),a.endTensorTypeAndShape(n)}}c.TensorTypeAndShape=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsMapType(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):d.experimental.fbs.TensorDataType.UNDEFINED}valueType(n){let t=this.bb.__offset(this.bb_pos,6);return t?(n||new d.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,t){n.addFieldInt32(0,t,d.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(n,t){n.addFieldOffset(1,t,0)}static endMapType(n){return n.endObject()}static createMapType(n,t,e){return a.startMapType(n),a.addKeyType(n,t),a.addValueType(n,e),a.endMapType(n)}}c.MapType=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsSequenceType(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let t=this.bb.__offset(this.bb_pos,4);return t?(n||new d.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,t){n.addFieldOffset(0,t,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,t){return a.startSequenceType(n),a.addElemType(n,t),a.endSequenceType(n)}}c.SequenceType=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(u.fbs||(u.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(c,a){return this.bb_pos=c,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(c,a,o,n){return c.prep(4,12),c.writeInt32(n),c.writeInt32(o),c.writeInt32(a),c.offset()}}})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsNodeEdge(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new d.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+e)+12*n,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,t){let e=this.bb.__offset(this.bb_pos,8);return e?(t||new d.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+e)+12*n,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,t){n.addFieldInt32(0,t,0)}static addInputEdges(n,t){n.addFieldOffset(1,t,0)}static startInputEdgesVector(n,t){n.startVector(12,t,4)}static addOutputEdges(n,t){n.addFieldOffset(2,t,0)}static startOutputEdgesVector(n,t){n.startVector(12,t,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,t,e,r){return a.startNodeEdge(n),a.addNodeIndex(n,t),a.addInputEdges(n,e),a.addOutputEdges(n,r),a.endNodeEdge(n)}}c.NodeEdge=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsNode(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}docString(n){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,n):null}domain(n){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):d.experimental.fbs.NodeType.Primitive}executionProviderType(n){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__string(this.bb_pos+t,n):null}inputs(n,t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+4*n,t):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,t){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+4*n,t):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,t){let e=this.bb.__offset(this.bb_pos,24);return e?(t||new d.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readInt32(this.bb.__vector(this.bb_pos+t)+4*n):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,t){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+4*n,t):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,t){n.addFieldOffset(0,t,0)}static addDocString(n,t){n.addFieldOffset(1,t,0)}static addDomain(n,t){n.addFieldOffset(2,t,0)}static addSinceVersion(n,t){n.addFieldInt32(3,t,0)}static addIndex(n,t){n.addFieldInt32(4,t,0)}static addOpType(n,t){n.addFieldOffset(5,t,0)}static addType(n,t){n.addFieldInt32(6,t,d.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(n,t){n.addFieldOffset(7,t,0)}static addInputs(n,t){n.addFieldOffset(8,t,0)}static createInputsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startInputsVector(n,t){n.startVector(4,t,4)}static addOutputs(n,t){n.addFieldOffset(9,t,0)}static createOutputsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startOutputsVector(n,t){n.startVector(4,t,4)}static addAttributes(n,t){n.addFieldOffset(10,t,0)}static createAttributesVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startAttributesVector(n,t){n.startVector(4,t,4)}static addInputArgCounts(n,t){n.addFieldOffset(11,t,0)}static createInputArgCountsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addInt32(t[e]);return n.endVector()}static startInputArgCountsVector(n,t){n.startVector(4,t,4)}static addImplicitInputs(n,t){n.addFieldOffset(12,t,0)}static createImplicitInputsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startImplicitInputsVector(n,t){n.startVector(4,t,4)}static endNode(n){return n.endObject()}static createNode(n,t,e,r,i,s,f,g,y,v,w,T,x,A){return a.startNode(n),a.addName(n,t),a.addDocString(n,e),a.addDomain(n,r),a.addSinceVersion(n,i),a.addIndex(n,s),a.addOpType(n,f),a.addType(n,g),a.addExecutionProviderType(n,y),a.addInputs(n,v),a.addOutputs(n,w),a.addAttributes(n,T),a.addInputArgCounts(n,x),a.addImplicitInputs(n,A),a.endNode(n)}}c.Node=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsValueInfo(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}docString(n){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,n):null}type(n){let t=this.bb.__offset(this.bb_pos,8);return t?(n||new d.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,t){n.addFieldOffset(0,t,0)}static addDocString(n,t){n.addFieldOffset(1,t,0)}static addType(n,t){n.addFieldOffset(2,t,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,t,e,r){return a.startValueInfo(n),a.addName(n,t),a.addDocString(n,e),a.addType(n,r),a.endValueInfo(n)}}c.ValueInfo=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsTypeInfo(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):d.experimental.fbs.TypeInfoValue.NONE}value(n){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__union(n,this.bb_pos+t):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,t){n.addFieldOffset(0,t,0)}static addValueType(n,t){n.addFieldInt8(1,t,d.experimental.fbs.TypeInfoValue.NONE)}static addValue(n,t){n.addFieldOffset(2,t,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,t,e,r){return a.startTypeInfo(n),a.addDenotation(n,t),a.addValueType(n,e),a.addValue(n,r),a.endTypeInfo(n)}}c.TypeInfo=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsOperatorSetId(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,t){n.addFieldOffset(0,t,0)}static addVersion(n,t){n.addFieldInt64(1,t,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,t,e){return a.startOperatorSetId(n),a.addDomain(n,t),a.addVersion(n,e),a.endOperatorSetId(n)}}c.OperatorSetId=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsTensor(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}docString(n){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,n):null}dims(n){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):d.experimental.fbs.TensorDataType.UNDEFINED}rawData(n){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint8(this.bb.__vector(this.bb_pos+t)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+4*n,t):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,t){n.addFieldOffset(0,t,0)}static addDocString(n,t){n.addFieldOffset(1,t,0)}static addDims(n,t){n.addFieldOffset(2,t,0)}static createDimsVector(n,t){n.startVector(8,t.length,8);for(let e=t.length-1;e>=0;e--)n.addInt64(t[e]);return n.endVector()}static startDimsVector(n,t){n.startVector(8,t,8)}static addDataType(n,t){n.addFieldInt32(3,t,d.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(n,t){n.addFieldOffset(4,t,0)}static createRawDataVector(n,t){n.startVector(1,t.length,1);for(let e=t.length-1;e>=0;e--)n.addInt8(t[e]);return n.endVector()}static startRawDataVector(n,t){n.startVector(1,t,1)}static addStringData(n,t){n.addFieldOffset(5,t,0)}static createStringDataVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startStringDataVector(n,t){n.startVector(4,t,4)}static endTensor(n){return n.endObject()}static createTensor(n,t,e,r,i,s,f){return a.startTensor(n),a.addName(n,t),a.addDocString(n,e),a.addDims(n,r),a.addDataType(n,i),a.addRawData(n,s),a.addStringData(n,f),a.endTensor(n)}}c.Tensor=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsSparseTensor(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}values(n){let t=this.bb.__offset(this.bb_pos,4);return t?(n||new d.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}indices(n){let t=this.bb.__offset(this.bb_pos,6);return t?(n||new d.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}dims(n){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,t){n.addFieldOffset(0,t,0)}static addIndices(n,t){n.addFieldOffset(1,t,0)}static addDims(n,t){n.addFieldOffset(2,t,0)}static createDimsVector(n,t){n.startVector(8,t.length,8);for(let e=t.length-1;e>=0;e--)n.addInt64(t[e]);return n.endVector()}static startDimsVector(n,t){n.startVector(8,t,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,t,e,r){return a.startSparseTensor(n),a.addValues(n,t),a.addIndices(n,e),a.addDims(n,r),a.endSparseTensor(n)}}c.SparseTensor=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsAttribute(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}docString(n){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):d.experimental.fbs.AttributeType.UNDEFINED}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,n):null}t(n){let t=this.bb.__offset(this.bb_pos,16);return t?(n||new d.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}g(n){let t=this.bb.__offset(this.bb_pos,18);return t?(n||new d.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}floats(n){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.readFloat32(this.bb.__vector(this.bb_pos+t)+4*n):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*n):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,t){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+4*n,t):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,t){let e=this.bb.__offset(this.bb_pos,26);return e?(t||new d.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,t){let e=this.bb.__offset(this.bb_pos,28);return e?(t||new d.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,t){n.addFieldOffset(0,t,0)}static addDocString(n,t){n.addFieldOffset(1,t,0)}static addType(n,t){n.addFieldInt32(2,t,d.experimental.fbs.AttributeType.UNDEFINED)}static addF(n,t){n.addFieldFloat32(3,t,0)}static addI(n,t){n.addFieldInt64(4,t,n.createLong(0,0))}static addS(n,t){n.addFieldOffset(5,t,0)}static addT(n,t){n.addFieldOffset(6,t,0)}static addG(n,t){n.addFieldOffset(7,t,0)}static addFloats(n,t){n.addFieldOffset(8,t,0)}static createFloatsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addFloat32(t[e]);return n.endVector()}static startFloatsVector(n,t){n.startVector(4,t,4)}static addInts(n,t){n.addFieldOffset(9,t,0)}static createIntsVector(n,t){n.startVector(8,t.length,8);for(let e=t.length-1;e>=0;e--)n.addInt64(t[e]);return n.endVector()}static startIntsVector(n,t){n.startVector(8,t,8)}static addStrings(n,t){n.addFieldOffset(10,t,0)}static createStringsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startStringsVector(n,t){n.startVector(4,t,4)}static addTensors(n,t){n.addFieldOffset(11,t,0)}static createTensorsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startTensorsVector(n,t){n.startVector(4,t,4)}static addGraphs(n,t){n.addFieldOffset(12,t,0)}static createGraphsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startGraphsVector(n,t){n.startVector(4,t,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,t,e,r,i,s,f,g,y,v,w,T,x,A){return a.startAttribute(n),a.addName(n,t),a.addDocString(n,e),a.addType(n,r),a.addF(n,i),a.addI(n,s),a.addS(n,f),a.addT(n,g),a.addG(n,y),a.addFloats(n,v),a.addInts(n,w),a.addStrings(n,T),a.addTensors(n,x),a.addGraphs(n,A),a.endAttribute(n)}}c.Attribute=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsGraph(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,t){let e=this.bb.__offset(this.bb_pos,4);return e?(t||new d.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new d.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,t){let e=this.bb.__offset(this.bb_pos,8);return e?(t||new d.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,t){let e=this.bb.__offset(this.bb_pos,12);return e?(t||new d.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+4*n,t):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,t){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb.__vector(this.bb_pos+e)+4*n,t):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,t){let e=this.bb.__offset(this.bb_pos,18);return e?(t||new d.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,t){n.addFieldOffset(0,t,0)}static createInitializersVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startInitializersVector(n,t){n.startVector(4,t,4)}static addNodeArgs(n,t){n.addFieldOffset(1,t,0)}static createNodeArgsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startNodeArgsVector(n,t){n.startVector(4,t,4)}static addNodes(n,t){n.addFieldOffset(2,t,0)}static createNodesVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startNodesVector(n,t){n.startVector(4,t,4)}static addMaxNodeIndex(n,t){n.addFieldInt32(3,t,0)}static addNodeEdges(n,t){n.addFieldOffset(4,t,0)}static createNodeEdgesVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startNodeEdgesVector(n,t){n.startVector(4,t,4)}static addInputs(n,t){n.addFieldOffset(5,t,0)}static createInputsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startInputsVector(n,t){n.startVector(4,t,4)}static addOutputs(n,t){n.addFieldOffset(6,t,0)}static createOutputsVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startOutputsVector(n,t){n.startVector(4,t,4)}static addSparseInitializers(n,t){n.addFieldOffset(7,t,0)}static createSparseInitializersVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startSparseInitializersVector(n,t){n.startVector(4,t,4)}static endGraph(n){return n.endObject()}static createGraph(n,t,e,r,i,s,f,g,y){return a.startGraph(n),a.addInitializers(n,t),a.addNodeArgs(n,e),a.addNodes(n,r),a.addMaxNodeIndex(n,i),a.addNodeEdges(n,s),a.addInputs(n,f),a.addOutputs(n,g),a.addSparseInitializers(n,y),a.endGraph(n)}}c.Graph=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsModel(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new d.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,n):null}producerVersion(n){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__string(this.bb_pos+t,n):null}domain(n){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__string(this.bb_pos+t,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb_pos+t,n):null}graph(n){let t=this.bb.__offset(this.bb_pos,18);return t?(n||new d.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}graphDocString(n){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb_pos+t,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,t){n.addFieldInt64(0,t,n.createLong(0,0))}static addOpsetImport(n,t){n.addFieldOffset(1,t,0)}static createOpsetImportVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startOpsetImportVector(n,t){n.startVector(4,t,4)}static addProducerName(n,t){n.addFieldOffset(2,t,0)}static addProducerVersion(n,t){n.addFieldOffset(3,t,0)}static addDomain(n,t){n.addFieldOffset(4,t,0)}static addModelVersion(n,t){n.addFieldInt64(5,t,n.createLong(0,0))}static addDocString(n,t){n.addFieldOffset(6,t,0)}static addGraph(n,t){n.addFieldOffset(7,t,0)}static addGraphDocString(n,t){n.addFieldOffset(8,t,0)}static endModel(n){return n.endObject()}static createModel(n,t,e,r,i,s,f,g,y,v){return a.startModel(n),a.addIrVersion(n,t),a.addOpsetImport(n,e),a.addProducerName(n,r),a.addProducerVersion(n,i),a.addDomain(n,s),a.addModelVersion(n,f),a.addDocString(n,g),a.addGraph(n,y),a.addGraphDocString(n,v),a.endModel(n)}}c.Model=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsKernelCreateInfos(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb.__vector(this.bb_pos+t)+4*n):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint64(this.bb.__vector(this.bb_pos+t)+8*n):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,t){n.addFieldOffset(0,t,0)}static createNodeIndicesVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addInt32(t[e]);return n.endVector()}static startNodeIndicesVector(n,t){n.startVector(4,t,4)}static addKernelDefHashes(n,t){n.addFieldOffset(1,t,0)}static createKernelDefHashesVector(n,t){n.startVector(8,t.length,8);for(let e=t.length-1;e>=0;e--)n.addInt64(t[e]);return n.endVector()}static startKernelDefHashesVector(n,t){n.startVector(8,t,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,t,e){return a.startKernelCreateInfos(n),a.addNodeIndices(n,t),a.addKernelDefHashes(n,e),a.endKernelCreateInfos(n)}}c.KernelCreateInfos=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsSubGraphSessionState(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}sessionState(n){let t=this.bb.__offset(this.bb_pos,6);return t?(n||new d.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,t){n.addFieldOffset(0,t,0)}static addSessionState(n,t){n.addFieldOffset(1,t,0)}static endSubGraphSessionState(n){let t=n.endObject();return n.requiredField(t,4),t}static createSubGraphSessionState(n,t,e){return a.startSubGraphSessionState(n),a.addGraphId(n,t),a.addSessionState(n,e),a.endSubGraphSessionState(n)}}c.SubGraphSessionState=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsSessionState(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let t=this.bb.__offset(this.bb_pos,4);return t?(n||new d.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}subGraphSessionStates(n,t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new d.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+4*n),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,t){n.addFieldOffset(0,t,0)}static addSubGraphSessionStates(n,t){n.addFieldOffset(1,t,0)}static createSubGraphSessionStatesVector(n,t){n.startVector(4,t.length,4);for(let e=t.length-1;e>=0;e--)n.addOffset(t[e]);return n.endVector()}static startSubGraphSessionStatesVector(n,t){n.startVector(4,t,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,t,e){return a.startSessionState(n),a.addKernels(n,t),a.addSubGraphSessionStates(n,e),a.endSessionState(n)}}c.SessionState=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={})),function(d){(function(u){(function(c){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,t){return this.bb_pos=n,this.bb=t,this}static getRootAsInferenceSession(n,t){return(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,t){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,n):null}model(n){let t=this.bb.__offset(this.bb_pos,6);return t?(n||new d.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}sessionState(n){let t=this.bb.__offset(this.bb_pos,8);return t?(n||new d.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,t){n.addFieldOffset(0,t,0)}static addModel(n,t){n.addFieldOffset(1,t,0)}static addSessionState(n,t){n.addFieldOffset(2,t,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,t){n.finish(t,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,t){n.finish(t,"ORTM",!0)}static createInferenceSession(n,t,e,r){return a.startInferenceSession(n),a.addOrtVersion(n,t),a.addModel(n,e),a.addSessionState(n,r),a.endInferenceSession(n)}}c.InferenceSession=a})(u.fbs||(u.fbs={}))})(d.experimental||(d.experimental={}))}(l.onnxruntime||(l.onnxruntime={}))},1723:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.OnnxjsSessionHandler=void 0;const m=b(2235),p=b(9240);l.OnnxjsSessionHandler=class{constructor(h){this.session=h,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(h,d,u){const c=new Map;for(const n in h)if(Object.hasOwnProperty.call(h,n)){const t=h[n];c.set(n,new p.Tensor(t.dims,t.type,void 0,void 0,t.data))}const a=await this.session.run(c),o={};return a.forEach((n,t)=>{o[t]=new m.Tensor(n.type,n.data,n.dims)}),o}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.Session=void 0;const m=b(7067),p=b(1296),h=b(1975),d=b(6496),u=b(1315),c=b(1745);l.Session=class{constructor(a={}){this._initialized=!1,this.backendHint=a.backendHint,this.profiler=u.Profiler.create(a.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(a,o,n){await this.profiler.event("session","Session.loadModel",async()=>{const t=await(0,h.resolveBackend)(this.backendHint);if(this.sessionHandler=t.createSessionHandler(this.context),this._model=new c.Model,typeof a=="string"){const e=a.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){const r=await(0,p.promisify)(m.readFile)(a);this.initialize(r,e)}else{const r=await fetch(a),i=await r.arrayBuffer();this.initialize(new Uint8Array(i),e)}}else if(ArrayBuffer.isView(a))this.initialize(a);else{const e=new Uint8Array(a,o||0,n||a.byteLength);this.initialize(e)}})}initialize(a,o){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(a,n,o),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new d.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(a){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const o=this.normalizeAndValidateInputs(a),n=await this._executionPlan.execute(this.sessionHandler,o);return this.createOutput(n)})}normalizeAndValidateInputs(a){const o=this._model.graph.getInputNames();if(Array.isArray(a)){if(a.length!==o.length)throw new Error(`incorrect input array length: expected ${o.length} but got ${a.length}`)}else{if(a.size!==o.length)throw new Error(`incorrect input map size: expected ${o.length} but got ${a.size}`);const n=new Array(a.size);let t=0;for(let e=0;e<o.length;++e){const r=a.get(o[e]);if(!r)throw new Error(`missing input tensor for: '${name}'`);n[t++]=r}a=n}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,a,!1);else{const n=this._model.graph.getInputIndices(),t=this._model.graph.getValues(),e=new Array(n.length);for(let r=0;r<n.length;++r){const i=t[n[r]];e[r]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(a[r].dims)}this.validateInputTensorDims(e,a,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,a),a}validateInputTensorTypes(a,o){for(let n=0;n<o.length;n++){const t=a[n],e=o[n].type;if(t!==e)throw new Error(`input tensor[${n}] check failed: expected type '${t}' but got ${e}`)}}validateInputTensorDims(a,o,n){for(let t=0;t<o.length;t++){const e=a[t],r=o[t].dims;if(!this.compareTensorDims(e,r,n))throw new Error(`input tensor[${t}] check failed: expected shape '[${e.join(",")}]' but got [${r.join(",")}]`)}}compareTensorDims(a,o,n){if(a.length!==o.length)return!1;for(let t=0;t<a.length;++t)if(a[t]!==o[t]&&(!n||a[t]!==0))return!1;return!0}createOutput(a){const o=this._model.graph.getOutputNames();if(a.length!==o.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let t=0;t<o.length;++t)n.set(o[t],a[t]);return n}initializeOps(a){const o=a.getNodes();this._ops=new Array(o.length);for(let n=0;n<o.length;n++)this._ops[n]=this.sessionHandler.resolve(o[n],this._model.opsets,a)}}},9240:function(R,l,b){var m=this&&this.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(l,"__esModule",{value:!0}),l.Tensor=void 0;const p=b(3442),h=m(b(1583)),d=b(5127),u=b(2446),c=b(7273);var a=d.onnxruntime.experimental.fbs;class o{get data(){if(this.cache===void 0){const s=this.dataProvider(this.dataId);if(s.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=s}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(s){return this.data[c.ShapeUtil.indicesToOffset(s,this.strides)]}set(s,f){this.data[c.ShapeUtil.indicesToOffset(s,this.strides)]=f}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=c.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(s,f,g,y,v,w=p.Guid.create()){this.dims=s,this.type=f,this.dataProvider=g,this.asyncDataProvider=y,this.cache=v,this.dataId=w,this.size=c.ShapeUtil.validateDimsAndCalcSize(s);const T=this.size,x=g===void 0&&y===void 0&&v===void 0;if(v!==void 0&&v.length!==T)throw new RangeError("Input dims doesn't match data length.");if(f==="string"){if(!(v===void 0||Array.isArray(v)&&v.every(A=>typeof A=="string")))throw new TypeError("cache should be a string array");x&&(this.cache=new Array(T))}else{if(v!==void 0){const A=t(f);if(!(v instanceof A))throw new TypeError(`cache should be type ${A.name}`)}if(x){const A=new ArrayBuffer(T*function(D){switch(D){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${D}`)}}(f));this.cache=function(D,$){return new(t($))(D)}(A,f)}}}static fromProto(s){if(!s)throw new Error("cannot construct Value from an empty tensor");const f=c.ProtoUtil.tensorDataTypeFromProto(s.dataType),g=c.ProtoUtil.tensorDimsFromProto(s.dims),y=new o(g,f);if(f==="string")s.stringData.forEach((v,w)=>{y.data[w]=(0,c.decodeUtf8String)(v)});else if(s.rawData&&typeof s.rawData.byteLength=="number"&&s.rawData.byteLength>0){const v=y.data,w=new DataView(s.rawData.buffer,s.rawData.byteOffset,s.rawData.byteLength),T=n(s.dataType),x=s.rawData.byteLength/T;if(s.rawData.byteLength%T!=0)throw new Error("invalid buffer length");if(v.length!==x)throw new Error("buffer length mismatch");for(let A=0;A<x;A++){const D=r(w,s.dataType,A*T);v[A]=D}}else{let v;switch(s.dataType){case u.onnx.TensorProto.DataType.FLOAT:v=s.floatData;break;case u.onnx.TensorProto.DataType.INT32:case u.onnx.TensorProto.DataType.INT16:case u.onnx.TensorProto.DataType.UINT16:case u.onnx.TensorProto.DataType.INT8:case u.onnx.TensorProto.DataType.UINT8:case u.onnx.TensorProto.DataType.BOOL:v=s.int32Data;break;case u.onnx.TensorProto.DataType.INT64:v=s.int64Data;break;case u.onnx.TensorProto.DataType.DOUBLE:v=s.doubleData;break;case u.onnx.TensorProto.DataType.UINT32:case u.onnx.TensorProto.DataType.UINT64:v=s.uint64Data;break;default:throw new Error("unspecific error")}if(v==null)throw new Error("failed to populate data from a tensorproto value");const w=y.data;if(w.length!==v.length)throw new Error("array length mismatch");for(let T=0;T<v.length;T++){const x=v[T];h.default.isLong(x)?w[T]=e(x,s.dataType):w[T]=x}}return y}static fromData(s,f,g){return new o(f,g,void 0,void 0,s)}static fromOrtTensor(s){if(!s)throw new Error("cannot construct Value from an empty tensor");const f=c.ProtoUtil.tensorDimsFromORTFormat(s),g=c.ProtoUtil.tensorDataTypeFromProto(s.dataType()),y=new o(f,g);if(g==="string")for(let v=0;v<s.stringDataLength();v++)y.data[v]=s.stringData(v);else if(s.rawDataArray()&&typeof s.rawDataLength()=="number"&&s.rawDataLength()>0){const v=y.data,w=new DataView(s.rawDataArray().buffer,s.rawDataArray().byteOffset,s.rawDataLength()),T=n(s.dataType()),x=s.rawDataLength()/T;if(s.rawDataLength()%T!=0)throw new Error("invalid buffer length");if(v.length!==x)throw new Error("buffer length mismatch");for(let A=0;A<x;A++){const D=r(w,s.dataType(),A*T);v[A]=D}}return y}}function n(i){switch(i){case u.onnx.TensorProto.DataType.UINT8:case u.onnx.TensorProto.DataType.INT8:case u.onnx.TensorProto.DataType.BOOL:return 1;case u.onnx.TensorProto.DataType.UINT16:case u.onnx.TensorProto.DataType.INT16:return 2;case u.onnx.TensorProto.DataType.FLOAT:case u.onnx.TensorProto.DataType.INT32:case u.onnx.TensorProto.DataType.UINT32:return 4;case u.onnx.TensorProto.DataType.INT64:case u.onnx.TensorProto.DataType.DOUBLE:case u.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${u.onnx.TensorProto.DataType[i]}`)}}function t(i){switch(i){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function e(i,s){if(s===u.onnx.TensorProto.DataType.INT64||s===a.TensorDataType.INT64){if(i.greaterThanOrEqual(2147483648)||i.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(s!==u.onnx.TensorProto.DataType.UINT32&&s!==a.TensorDataType.UINT32&&s!==u.onnx.TensorProto.DataType.UINT64&&s!==a.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${u.onnx.TensorProto.DataType[s]}`);if(i.greaterThanOrEqual(4294967296)||i.lessThan(0))throw new TypeError("uint64 is not supported")}return i.toNumber()}function r(i,s,f){switch(s){case u.onnx.TensorProto.DataType.BOOL:case u.onnx.TensorProto.DataType.UINT8:return i.getUint8(f);case u.onnx.TensorProto.DataType.INT8:return i.getInt8(f);case u.onnx.TensorProto.DataType.UINT16:return i.getUint16(f,!0);case u.onnx.TensorProto.DataType.INT16:return i.getInt16(f,!0);case u.onnx.TensorProto.DataType.FLOAT:return i.getFloat32(f,!0);case u.onnx.TensorProto.DataType.INT32:return i.getInt32(f,!0);case u.onnx.TensorProto.DataType.UINT32:return i.getUint32(f,!0);case u.onnx.TensorProto.DataType.INT64:return e(h.default.fromBits(i.getUint32(f,!0),i.getUint32(f+4,!0),!1),s);case u.onnx.TensorProto.DataType.DOUBLE:return i.getFloat64(f,!0);case u.onnx.TensorProto.DataType.UINT64:return e(h.default.fromBits(i.getUint32(f,!0),i.getUint32(f+4,!0),!0),s);default:throw new Error(`cannot read from DataView for type ${u.onnx.TensorProto.DataType[s]}`)}}l.Tensor=o},7273:function(R,l,b){var m=this&&this.__importDefault||function(s){return s&&s.__esModule?s:{default:s}};Object.defineProperty(l,"__esModule",{value:!0}),l.decodeUtf8String=l.MAX_CLIP=l.MIN_CLIP=l.PoolConvUtil=l.ReduceUtil=l.SplitUtil=l.MathUtil=l.ShapeUtil=l.LongUtil=l.ProtoUtil=l.GemmUtil=l.arrayCopyHelper=l.BroadcastUtil=l.MatMulUtil=l.ArrayUtil=l.assert=l.checkInputsShape=void 0;const p=b(5686),h=m(b(1583)),d=b(2446),u=b(9240);l.checkInputsShape=function(s,...f){if(!s||s.length!==f.length)return!1;for(let g=0;g<s.length;g++)if(!s[g].dims||s[g].dims.length!==f[g])return!1;return!0},l.assert=function(s,f){if(!s)throw new Error(typeof f=="string"?f:f())},l.ArrayUtil=class{static arraysEqual(s,f){if(s.length!==f.length)return!1;for(let g=0;g<s.length;g++)if(s[g]!==f[g])return!1;return!0}};class c{static preprocessInputShapes(f,g){return[f.length===1?[1,f[0]]:f,g.length===1?[g[0],1]:g]}static postprocessOutputShape(f,g,y){g===1&&f.splice(f.length-2,1),y===1&&f.pop()}static calcMatMulShape(f,g){return f[1]!==g[0]?void 0:[f[0],g[1]]}}l.MatMulUtil=c;class a{static calcShape(f,g,y=!1){const v=f.length,w=g.length;if(v===0)return g;if(w===0)return f;const T=Math.max(f.length,g.length),x=new Array(T);if(y){if(v<2||w<2)return;const A=c.calcMatMulShape([f[v-2],f[v-1]],[g[w-2],g[w-1]]);if(A===void 0)return;[x[T-2],x[T-1]]=A}for(let A=y?3:1;A<=T;A++){const D=v-A<0?1:f[v-A],$=w-A<0?1:g[w-A];if(D!==$&&D>1&&$>1)return;x[T-A]=Math.max(D,$)}return x}static index(f,g){const y=new Array(g.length);return a.fillIndex(f,g,y),y}static fillIndex(f,g,y){const v=f.length-g.length;for(let w=0;w<g.length;w++)y[w]=f[v+w]%g[w]}static calc(f,g,y,v,w){const T=a.calcShape(f.dims,g.dims);if(T){if(v&&!t.areEqual(T,f.dims))return;const x=t.size(T),A=v?f:new u.Tensor(T,w||f.type);if(T.length===0)A.set([],y(f.get([]),g.get([])));else{const D=new Array(T.length),$=new Array(f.dims.length),j=new Array(g.dims.length);let M,S=0,U=0,O=!1,E=!1;f.dims.length===0&&(S=f.get([]),O=!0),g.dims.length===0&&(U=g.get([]),E=!0);for(let F=0;F<x;F++){M=F;for(let q=T.length-1;q>=0;q--)D[q]=M%T[q],M=Math.floor(M/T[q]);O||(a.fillIndex(D,f.dims,$),S=f.get($)),E||(a.fillIndex(D,g.dims,j),U=g.get(j)),A.set(D,y(S,U))}}return A}}static isValidBroadcast(f,g){const y=f.length,v=g.length;if(y>v)return!1;for(let w=1;w<=y;w++)if(f[y-w]!==1&&f[y-w]!==g[v-w])return!1;return!0}static getBroadcastDims(f,g){const y=f.length,v=[];for(let w=0;w<y;w++){const T=y-1-w,x=f[T]||1;(g[g.length-1-w]||1)>1&&x===1&&v.unshift(T)}return v}}l.BroadcastUtil=a,l.arrayCopyHelper=function(s,f,g,y,v){if(y<0||y>=f.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=s.length)throw new Error("targetIndex out of bounds");if(y+v>f.length)throw new Error("source indices to be copied are outside bounds");if(g+v>s.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)s[g+w]=f[y+w]},l.GemmUtil=class{static getShapeOfGemmResult(s,f,g,y,v){if(s.length!==2||g.length!==2)throw new Error("shape need to be of size 2");let w,T,x;f?(w=s[1],T=s[0]):(w=s[0],T=s[1]);let A=-1;if(y?(x=g[0],A=1):(x=g[1],A=0),g[A]!==T)throw new Error("dimension mismatch");if(w<=0||x<=0||T<=0)throw new Error("invalid shape specified");if(v&&!a.isValidBroadcast(v,[w,x]))throw new Error("gemm: invalid bias shape for broadcast");return[w,x,T]}};class o{static tensorDataTypeFromProto(f){switch(f){case d.onnx.TensorProto.DataType.INT8:return"int8";case d.onnx.TensorProto.DataType.UINT8:return"uint8";case d.onnx.TensorProto.DataType.BOOL:return"bool";case d.onnx.TensorProto.DataType.INT16:return"int16";case d.onnx.TensorProto.DataType.UINT16:return"uint16";case d.onnx.TensorProto.DataType.INT32:return"int32";case d.onnx.TensorProto.DataType.UINT32:return"uint32";case d.onnx.TensorProto.DataType.FLOAT:return"float32";case d.onnx.TensorProto.DataType.DOUBLE:return"float64";case d.onnx.TensorProto.DataType.STRING:return"string";case d.onnx.TensorProto.DataType.INT64:return"int32";case d.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${d.onnx.TensorProto.DataType[f]}`)}}static tensorDataTypeStringToEnum(f){switch(f){case"int8":return d.onnx.TensorProto.DataType.INT8;case"uint8":return d.onnx.TensorProto.DataType.UINT8;case"bool":return d.onnx.TensorProto.DataType.BOOL;case"int16":return d.onnx.TensorProto.DataType.INT16;case"uint16":return d.onnx.TensorProto.DataType.UINT16;case"int32":return d.onnx.TensorProto.DataType.INT32;case"uint32":return d.onnx.TensorProto.DataType.UINT32;case"float32":return d.onnx.TensorProto.DataType.FLOAT;case"float64":return d.onnx.TensorProto.DataType.DOUBLE;case"string":return d.onnx.TensorProto.DataType.STRING;case"int64":return d.onnx.TensorProto.DataType.INT64;case"uint64":return d.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${f}`)}}static tensorDimsFromProto(f){return f.map(g=>h.default.isLong(g)?g.toNumber():g)}static tensorValueTypeFromProto(f){return{tensorType:o.tensorDataTypeFromProto(f.elemType),shape:{dims:o.tensorDimsFromProto(f.shape.dim.map(g=>g.dimValue))}}}static tensorDimsFromORTFormat(f){const g=[];for(let y=0;y<f.dimsLength();y++)g.push(n.longToNumber(f.dims(y)));return g}static tensorAttributesFromORTFormat(f){const g=[];for(let y=0;y<f.attributesLength();y++)g.push(f.attributes(y));return g}}l.ProtoUtil=o;class n{static longToNumber(f,g){return h.default.isLong(f)?f.toNumber():f instanceof p.flatbuffers.Long?h.default.fromValue({low:f.low,high:f.high,unsigned:g!=null&&g}).toNumber():f}static isLong(f){return h.default.isLong(f)||f instanceof p.flatbuffers.Long}}l.LongUtil=n;class t{static size(f){return t.getSizeFromDimensionRange(f,0,f.length)}static sizeFromDimension(f,g){if(g<0||g>f.length)throw new Error(`invalid dimension of ${g} for sizeFromDimension as Tensor has ${f.length} dimensions.`);return t.getSizeFromDimensionRange(f,g,f.length)}static sizeToDimension(f,g){if(g<0||g>f.length)throw new Error(`invalid dimension of ${g} for sizeToDimension as Tensor has ${f.length} dimensions.`);return t.getSizeFromDimensionRange(f,0,g)}static getSizeFromDimensionRange(f,g,y){let v=1;for(let w=g;w<y;w++){if(f[w]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");v*=f[w]}return v}static computeStrides(f){const g=f.length;if(g===0)return[];if(g===1)return[1];const y=new Array(g);y[g-1]=1,y[g-2]=f[g-1];for(let v=g-3;v>=0;--v)y[v]=y[v+1]*f[v+1];return y}static transpose(f){return f.slice().reverse()}static indicesToOffset(f,g,y){y===void 0&&(y=f.length);let v=0;for(let w=0;w<y;++w)v+=g[w]*f[w];return v}static offsetToIndices(f,g){const y=g.length;if(y===0)return[];if(y===1)return[f*g[0]];const v=new Array(g.length);for(let w=0;w<v.length-1;++w)v[w]=Math.floor(f/g[w]),f-=v[w]*g[w];return v[v.length-1]=f,v}static normalizeAxis(f,g){if(f<-g&&f>=g)throw new Error("unsupported axis for this operation.");return f<0?f+g:f}static normalizeAxes(f,g){return f.map(y=>this.normalizeAxis(y,g))}static incrementIndex(f,g,y){if(g.length===0||f.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(y===void 0)y=g.length;else if(y<=0||y>g.length)throw new Error("Incorrect axis to increment on");for(let v=y-1;v>=0&&(f[v]++,!(f[v]<g[v]));--v)f[v]=0}static calculateReshapedDims(f,g){if(g.length===0){if(f.length===0||t.size(f)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const y=g.length,v=new Array(y);let w=-1,T=1;for(let A=0;A<y;A++){if(g[A]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(g[A]===-1){if(w!==-1)throw new Error("at most one dimension in shape hints can be -1");w=A}else{if(g[A]===0){if(A>=f.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");v[A]=f[A]}else v[A]=g[A];T*=v[A]}}const x=t.size(f);if(w!==-1){if(x%T!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${f}] Output shape: [${g}]`);v[w]=x/T}else if(T!==x)throw new Error("reshapedDims and originalDims don't have matching sizes");return v}static sortBasedOnPerm(f,g){return g?g.map(y=>f[y]):f.slice().reverse()}static padShape(f,g){const y=f.length;return f.map((v,w)=>v+g[w]+g[w+y])}static areEqual(f,g){return f.length===g.length&&f.every((y,v)=>y===g[v])}static validateDimsAndCalcSize(f){if(f.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let g=1;for(const y of f){if(!Number.isInteger(y))throw new TypeError(`Invalid shape: ${y} is not an integer`);if(y<0||y>2147483647)throw new TypeError(`Invalid shape: length ${y} is not allowed`);g*=y}return g}static flattenShape(f,g){g<0&&(g+=f.length);const y=f.reduce((w,T)=>w*T,1),v=f.slice(g).reduce((w,T)=>w*T,1);return[y/v,v]}static squeezeShape(f,g){const y=new Array;g=t.normalizeAxes(g,f.length);for(let v=0;v<f.length;v++){const w=g.indexOf(v)>=0;if(w&&f[v]!==1)throw new Error("squeeze an axis of size different than 1");(g.length===0&&f[v]>1||g.length>0&&!w)&&y.push(f[v])}return y}static unsqueezeShape(f,g){const y=new Array(f.length+g.length);y.fill(0);for(let w=0;w<g.length;w++){const T=t.normalizeAxis(g[w],y.length);if(T>=y.length)throw new Error("'axes' has an out of range axis");if(y[T]!==0)throw new Error("'axes' has a duplicate axis");y[T]=1}let v=0;for(let w=0;w<y.length;w++)y[w]===0&&(y[w]=f[v++]);if(v!==f.length)throw new Error("the unsqueezed dimension could not be established");return y}}l.ShapeUtil=t,l.MathUtil=class{static sqr(s,f,g,y,v){if(y<0||y>=f.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=s.length)throw new Error("targetIndex out of bounds");if(y+v>f.length)throw new Error("source indices to be copied are outside bounds");if(g+v>s.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)s[g+w]+=Math.pow(f[y+w],2)}static axpy(s,f,g,y,v,w){if(y<0||y>=f.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=s.length)throw new Error("targetIndex out of bounds");if(y+v>f.length)throw new Error("source indices to be copied are outside bounds");if(g+v>s.length)throw new Error("target array is too small to hold result");for(let T=0;T<v;T++)s[g+T]+=w*f[y+T]}static powx(s,f,g,y,v,w){if(y<0||y>=f.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=s.length)throw new Error("targetIndex out of bounds");if(y+v>f.length)throw new Error("source indices to be copied are outside bounds");if(g+v>s.length)throw new Error("target array is too small to hold result");for(let T=0;T<v;T++)s[g+T]=Math.pow(f[y+T],w)}static mul(s,f,g,y,v){if(y<0||y>=f.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=s.length)throw new Error("targetIndex out of bounds");if(y+v>f.length)throw new Error("source indices to be copied are outside bounds");if(g+v>s.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)s[g+w]=f[y+w]*s[g+w]}};class e{static splitShape(f,g,y,v){if(y.length===0){if(!v)throw new Error("need to know number of outputs when the 'split' attribute is not specified");e.determineSplit(f[g],v,y)}const w=[],T=[0];for(let x=0;x<y.length;++x){x!==0&&T.push(T[x-1]+y[x-1]);const A=f.slice();A[g]=y[x],w.push(A)}return[w,T]}static determineSplit(f,g,y){if(f%g!=0)throw new Error("cannot split tensor to equal sized parts");for(let v=0;v<g;++v)y.push(f/g)}}l.SplitUtil=e;class r{static calcReduce(f,g,y,v,w){const T=f.dims.slice(0);g.length===0&&T.forEach((S,U)=>g.push(U));const x=r.calcReduceShape(T,g,!0),A=t.size(x),D=new u.Tensor(x,f.type),$=t.computeStrides(x),j=t.computeStrides(T),M=new Array(T.length);for(let S=0;S<A;S++){const U=t.offsetToIndices(S,$);a.fillIndex(U,T,M),D.set(U,r.calcReduceByAxis(f.numberData,g,T,0,t.indicesToOffset(M,j),v,w))}return y?D:new u.Tensor(r.calcReduceShape(T,g,y),D.type,void 0,void 0,D.data,D.dataId)}static calcReduceByAxis(f,g,y,v,w,T,x){let A=0;if(v>=g.length)return T(f[w]);const D=g[v],$=D>=y.length?1:t.size(y.slice(D+1));for(let j=0;j<y[D];j++)A=j===0?r.calcReduceByAxis(f,g,y,v+1,w,T,x):x(A,r.calcReduceByAxis(f,g,y,v+1,w,T,x)),w+=$;return A}static calcReduceShape(f,g,y){const v=f.slice();for(let w=0;w<g.length;w++)v[g[w]]=y?1:0;return v.filter(w=>w!==0)}}l.ReduceUtil=r;class i{static adjustPoolAttributes(f,g,y,v,w,T){if(!f&&y.length!==g.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(f)for(let x=0;x<g.length-2;x++)x>=y.length?y.push(g[x+2]):y[x]=g[x+2];for(let x=0;x<y.length;x++)if(x<v.length){if(v[x]<0)throw new Error("strides should be greater than or equal to 1")}else v.push(1);for(let x=0;x<y.length;x++)if(x<w.length){if(w[x]<0)throw new Error("dilations should be greater than or equal to 1")}else w.push(1);for(let x=0;x<2*y.length;x++)if(x<T.length){if(T[x]<0)throw new Error("pad should be greater than or equal to 1")}else T.push(0);for(let x=0;x<y.length;x++){if(y[x]<=0)throw new Error("kernel shapes need to be greater than 0");if(T[x]>=y[x]||T[x+y.length]>=y[x])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(f,g,y,v,w,T){if(T){if(w.length!==2*(f.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(g.length!==f.length-2)throw new Error("length of strides should be the length of data dimensions");if(v.length!==f.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let x=0;x<f.length-2;x++)i.adjustPadAndReturnShape(f[x+2],g[x],y[x],v[x],w,x,x+f.length-2,T)}}static computePoolOutputShape(f,g,y,v,w,T,x){if(g.length<=0)throw new Error("input shape must be of size greater than 0");const A=[g[0],g[1]];return i.computeShapeHelper(f,g,A,y,v,w,T,x),A}static computeConvOutputShape(f,g,y,v,w,T,x){if(f.length<=0||g.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const A=[f[0],g[0]];return i.computeShapeHelper(!1,f,A,y,v,w,T,x),A}static computeShapeHelper(f,g,y,v,w,T,x,A){if(f)for(let D=0;D<g.length-2;D++)y.push(1);else for(let D=0;D<g.length-2;D++)y.push(i.adjustPadAndReturnShape(g[D+2],v[D],w[D],T[D],x,D,D+g.length-2,A))}static adjustPadAndReturnShape(f,g,y,v,w,T,x,A){const D=y*(v-1)+1;if(!A||A==="NOTSET")return Math.floor((f+w[T]+w[x]-D)/g+1);switch(A){case"VALID":return w[T]=0,w[x]=0,Math.floor((f-D)/g+1);case"SAME_LOWER":case"SAME_UPPER":if(y!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const $=((f+g-1)/g-1)*g+v-f;return w[T]=Math.floor(A==="SAME_LOWER"?($+1)/2:$/2),w[x]=$-w[T],Math.floor((f+$-v)/g+1)}default:throw new Error("Unsupported AutoPad type")}}}l.PoolConvUtil=i,l.MIN_CLIP=-34028234663852886e22,l.MAX_CLIP=34028234663852886e22,l.decodeUtf8String=function(s){return new TextDecoder().decode(s)}},8408:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.version=void 0,l.version="1.16.3"},9544:function(R,l,b){var m,p=this&&this.__createBinding||(Object.create?function($,j,M,S){S===void 0&&(S=M);var U=Object.getOwnPropertyDescriptor(j,M);U&&!("get"in U?!j.__esModule:U.writable||U.configurable)||(U={enumerable:!0,get:function(){return j[M]}}),Object.defineProperty($,S,U)}:function($,j,M,S){S===void 0&&(S=M),$[S]=j[M]}),h=this&&this.__setModuleDefault||(Object.create?function($,j){Object.defineProperty($,"default",{enumerable:!0,value:j})}:function($,j){$.default=j}),d=this&&this.__importStar||function($){if($&&$.__esModule)return $;var j={};if($!=null)for(var M in $)M!=="default"&&Object.prototype.hasOwnProperty.call($,M)&&p(j,$,M);return h(j,$),j};Object.defineProperty(l,"__esModule",{value:!0}),l.endProfiling=l.run=l.releaseSession=l.createSession=l.createSessionFinalize=l.createSessionAllocate=l.initializeRuntime=l.initializeWebAssemblyInstance=void 0;const u=b(2235),c=d(b(1259)),a=b(263),o=()=>!!u.env.wasm.proxy&&typeof document<"u";let n,t,e,r=!1,i=!1,s=!1;const f=[],g=[],y=[],v=[],w=[],T=[],x=()=>{if(r||!i||s||!n)throw new Error("worker not ready")},A=$=>{switch($.data.type){case"init-wasm":r=!1,$.data.err?(s=!0,t[1]($.data.err)):(i=!0,t[0]());break;case"init-ort":$.data.err?e[1]($.data.err):e[0]();break;case"create_allocate":$.data.err?f.shift()[1]($.data.err):f.shift()[0]($.data.out);break;case"create_finalize":$.data.err?g.shift()[1]($.data.err):g.shift()[0]($.data.out);break;case"create":$.data.err?y.shift()[1]($.data.err):y.shift()[0]($.data.out);break;case"release":$.data.err?v.shift()[1]($.data.err):v.shift()[0]();break;case"run":$.data.err?w.shift()[1]($.data.err):w.shift()[0]($.data.out);break;case"end-profiling":$.data.err?T.shift()[1]($.data.err):T.shift()[0]()}},D=typeof document<"u"?(m=document==null?void 0:document.currentScript)===null||m===void 0?void 0:m.src:void 0;l.initializeWebAssemblyInstance=async()=>{if(o()){if(i)return;if(r)throw new Error("multiple calls to 'initWasm()' detected.");if(s)throw new Error("previous call to 'initWasm()' failed.");return r=!0,u.env.wasm.wasmPaths===void 0&&D&&D.indexOf("blob:")!==0&&(u.env.wasm.wasmPaths=D.substr(0,+D.lastIndexOf("/")+1)),new Promise(($,j)=>{n==null||n.terminate(),n=b(8050).Z(),n.onmessage=A,t=[$,j];const M={type:"init-wasm",in:u.env.wasm};n.postMessage(M)})}return(0,a.initializeWebAssembly)(u.env.wasm)},l.initializeRuntime=async $=>{if(o())return x(),new Promise((j,M)=>{e=[j,M];const S={type:"init-ort",in:$};n.postMessage(S)});await c.initRuntime($)},l.createSessionAllocate=async $=>o()?(x(),new Promise((j,M)=>{f.push([j,M]);const S={type:"create_allocate",in:{model:$}};n.postMessage(S,[$.buffer])})):c.createSessionAllocate($),l.createSessionFinalize=async($,j)=>o()?(x(),new Promise((M,S)=>{g.push([M,S]);const U={type:"create_finalize",in:{modeldata:$,options:j}};n.postMessage(U)})):c.createSessionFinalize($,j),l.createSession=async($,j)=>o()?(x(),new Promise((M,S)=>{y.push([M,S]);const U={type:"create",in:{model:$,options:j}};n.postMessage(U,[$.buffer])})):c.createSession($,j),l.releaseSession=async $=>{if(o())return x(),new Promise((j,M)=>{v.push([j,M]);const S={type:"release",in:$};n.postMessage(S)});c.releaseSession($)},l.run=async($,j,M,S,U)=>o()?(x(),new Promise((O,E)=>{w.push([O,E]);const F={type:"run",in:{sessionId:$,inputIndices:j,inputs:M,outputIndices:S,options:U}};n.postMessage(F,c.extractTransferableBuffers(M))})):c.run($,j,M,S,U),l.endProfiling=async $=>{if(o())return x(),new Promise((j,M)=>{T.push([j,M]);const S={type:"end-profiling",in:$};n.postMessage(S)});c.endProfiling($)}},7918:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.setRunOptions=void 0;const m=b(263),p=b(1497);l.setRunOptions=h=>{const d=(0,m.getInstance)();let u=0;const c=[],a=h||{};try{if((h==null?void 0:h.logSeverityLevel)===void 0)a.logSeverityLevel=2;else if(typeof h.logSeverityLevel!="number"||!Number.isInteger(h.logSeverityLevel)||h.logSeverityLevel<0||h.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${h.logSeverityLevel}`);if((h==null?void 0:h.logVerbosityLevel)===void 0)a.logVerbosityLevel=0;else if(typeof h.logVerbosityLevel!="number"||!Number.isInteger(h.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${h.logVerbosityLevel}`);(h==null?void 0:h.terminate)===void 0&&(a.terminate=!1);let o=0;return(h==null?void 0:h.tag)!==void 0&&(o=(0,p.allocWasmString)(h.tag,c)),u=d._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,o),u===0&&(0,p.checkLastError)("Can't create run options."),(h==null?void 0:h.extra)!==void 0&&(0,p.iterateExtraOptions)(h.extra,"",new WeakSet,(n,t)=>{const e=(0,p.allocWasmString)(n,c),r=(0,p.allocWasmString)(t,c);d._OrtAddRunConfigEntry(u,e,r)!==0&&(0,p.checkLastError)(`Can't set a run config entry: ${n} - ${t}.`)}),[u,c]}catch(o){throw u!==0&&d._OrtReleaseRunOptions(u),c.forEach(n=>d._free(n)),o}}},6640:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.OnnxruntimeWebAssemblySessionHandler=void 0;const m=b(2806),p=b(2235),h=b(2850),d=b(9544);let u;l.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(c){const a=await fetch(c);if(a.status!==200)throw new Error(`failed to load model: ${c}`);const o=await a.arrayBuffer();return(0,d.createSessionAllocate)(new Uint8Array(o))}async loadModel(c,a){if(u||(await(0,d.initializeRuntime)(p.env),u=!0),typeof c=="string")if(typeof process<"u"&&process.versions&&process.versions.node){const o=await(0,h.promisify)(m.readFile)(c);[this.sessionId,this.inputNames,this.outputNames]=await(0,d.createSession)(o,a)}else{const o=await this.createSessionAllocate(c);[this.sessionId,this.inputNames,this.outputNames]=await(0,d.createSessionFinalize)(o,a)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,d.createSession)(c,a)}async dispose(){return(0,d.releaseSession)(this.sessionId)}async run(c,a,o){const n=[],t=[];Object.entries(c).forEach(s=>{const f=s[0],g=s[1],y=this.inputNames.indexOf(f);if(y===-1)throw new Error(`invalid input '${f}'`);n.push(g),t.push(y)});const e=[];Object.entries(a).forEach(s=>{const f=s[0],g=this.outputNames.indexOf(f);if(g===-1)throw new Error(`invalid output '${f}'`);e.push(g)});const r=await(0,d.run)(this.sessionId,t,n.map(s=>[s.type,s.dims,s.data]),e,o),i={};for(let s=0;s<r.length;s++)i[this.outputNames[e[s]]]=new p.Tensor(r[s][0],r[s][2],r[s][1]);return i}startProfiling(){}endProfiling(){(0,d.endProfiling)(this.sessionId)}}},7622:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.setSessionOptions=void 0;const m=b(263),p=b(1497);l.setSessionOptions=h=>{var d,u,c,a;const o=(0,m.getInstance)();let n=0;const t=[],e=h||{};(r=>{r.extra||(r.extra={}),r.extra.session||(r.extra.session={});const i=r.extra.session;i.use_ort_model_bytes_directly||(i.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(s=>(typeof s=="string"?s:s.name)==="webgpu")&&(r.enableMemPattern=!1)})(e);try{const r=(v=>{switch(v){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${v}`)}})((d=e.graphOptimizationLevel)!==null&&d!==void 0?d:"all"),i=(v=>{switch(v){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${v}`)}})((u=e.executionMode)!==null&&u!==void 0?u:"sequential"),s=typeof e.logId=="string"?(0,p.allocWasmString)(e.logId,t):0,f=(c=e.logSeverityLevel)!==null&&c!==void 0?c:2;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log serverity level is not valid: ${f}`);const g=(a=e.logVerbosityLevel)!==null&&a!==void 0?a:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const y=typeof e.optimizedModelFilePath=="string"?(0,p.allocWasmString)(e.optimizedModelFilePath,t):0;return n=o._OrtCreateSessionOptions(r,!!e.enableCpuMemArena,!!e.enableMemPattern,i,!!e.enableProfiling,0,s,f,g,y),n===0&&(0,p.checkLastError)("Can't create session options."),e.executionProviders&&((v,w,T)=>{for(const x of w){let A=typeof x=="string"?x:x.name;switch(A){case"xnnpack":A="XNNPACK";break;case"webnn":if(A="WEBNN",typeof x!="string"){const $=x;if($!=null&&$.deviceType){const j=(0,p.allocWasmString)("deviceType",T),M=(0,p.allocWasmString)($.deviceType,T);(0,m.getInstance)()._OrtAddSessionConfigEntry(v,j,M)!==0&&(0,p.checkLastError)(`Can't set a session config entry: 'deviceType' - ${$.deviceType}.`)}if($!=null&&$.powerPreference){const j=(0,p.allocWasmString)("powerPreference",T),M=(0,p.allocWasmString)($.powerPreference,T);(0,m.getInstance)()._OrtAddSessionConfigEntry(v,j,M)!==0&&(0,p.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${$.powerPreference}.`)}}break;case"webgpu":A="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${A}`)}const D=(0,p.allocWasmString)(A,T);(0,m.getInstance)()._OrtAppendExecutionProvider(v,D)!==0&&(0,p.checkLastError)(`Can't append execution provider: ${A}.`)}})(n,e.executionProviders,t),e.extra!==void 0&&(0,p.iterateExtraOptions)(e.extra,"",new WeakSet,(v,w)=>{const T=(0,p.allocWasmString)(v,t),x=(0,p.allocWasmString)(w,t);o._OrtAddSessionConfigEntry(n,T,x)!==0&&(0,p.checkLastError)(`Can't set a session config entry: ${v} - ${w}.`)}),[n,t]}catch(r){throw n!==0&&o._OrtReleaseSessionOptions(n),t.forEach(i=>o._free(i)),r}}},7917:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.logLevelStringToEnum=l.tensorTypeToTypedArrayConstructor=l.getTensorElementSize=l.tensorDataTypeEnumToString=l.tensorDataTypeStringToEnum=void 0,l.tensorDataTypeStringToEnum=b=>{switch(b){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${b}`)}},l.tensorDataTypeEnumToString=b=>{switch(b){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${b}`)}},l.getTensorElementSize=b=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][b],l.tensorTypeToTypedArrayConstructor=b=>{switch(b){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${b}`)}},l.logLevelStringToEnum=b=>{switch(b){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${b}`)}}},1259:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.extractTransferableBuffers=l.endProfiling=l.run=l.releaseSession=l.createSession=l.createSessionFinalize=l.createSessionAllocate=l.initRuntime=void 0;const m=b(7918),p=b(7622),h=b(7917),d=b(263),u=b(1497);l.initRuntime=async a=>{var o,n;o=a.wasm.numThreads,n=(0,h.logLevelStringToEnum)(a.logLevel),(0,d.getInstance)()._OrtInit(o,n)!==0&&(0,u.checkLastError)("Can't initialize onnxruntime.")};const c=new Map;l.createSessionAllocate=a=>{const o=(0,d.getInstance)(),n=o._malloc(a.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${a.byteLength}.`);return o.HEAPU8.set(a,n),[n,a.byteLength]},l.createSessionFinalize=(a,o)=>{const n=(0,d.getInstance)();let t=0,e=0,r=[];const i=[],s=[];try{[e,r]=(0,p.setSessionOptions)(o),t=n._OrtCreateSession(a[0],a[1],e),t===0&&(0,u.checkLastError)("Can't create a session.");const[f,g]=(w=>{const T=(0,d.getInstance)(),x=T.stackSave();try{const A=T.stackAlloc(8);return T._OrtGetInputOutputCount(w,A,A+4)!==0&&(0,u.checkLastError)("Can't get session input/output count."),[T.HEAP32[A/4],T.HEAP32[A/4+1]]}finally{T.stackRestore(x)}})(t),y=[],v=[];for(let w=0;w<f;w++){const T=n._OrtGetInputName(t,w);T===0&&(0,u.checkLastError)("Can't get an input name."),i.push(T),y.push(n.UTF8ToString(T))}for(let w=0;w<g;w++){const T=n._OrtGetOutputName(t,w);T===0&&(0,u.checkLastError)("Can't get an output name."),s.push(T),v.push(n.UTF8ToString(T))}return c.set(t,[t,i,s]),[t,y,v]}catch(f){throw i.forEach(g=>n._OrtFree(g)),s.forEach(g=>n._OrtFree(g)),t!==0&&n._OrtReleaseSession(t),f}finally{n._free(a[0]),e!==0&&n._OrtReleaseSessionOptions(e),r.forEach(f=>n._free(f))}},l.createSession=(a,o)=>{const n=(0,l.createSessionAllocate)(a);return(0,l.createSessionFinalize)(n,o)},l.releaseSession=a=>{const o=(0,d.getInstance)(),n=c.get(a);if(!n)throw new Error(`cannot release session. invalid session id: ${a}`);const[t,e,r]=n;e.forEach(i=>o._OrtFree(i)),r.forEach(i=>o._OrtFree(i)),o._OrtReleaseSession(t),c.delete(a)},l.run=async(a,o,n,t,e)=>{const r=(0,d.getInstance)(),i=c.get(a);if(!i)throw new Error(`cannot run inference. invalid session id: ${a}`);const[s,f,g]=i,y=o.length,v=t.length;let w=0,T=[];const x=[],A=[];try{[w,T]=(0,m.setRunOptions)(e);for(let U=0;U<y;U++){const O=n[U][0],E=n[U][1],F=n[U][2];let q,H;if(Array.isArray(F)){H=4*F.length,q=r._malloc(H),A.push(q);let J=q/4;for(let tt=0;tt<F.length;tt++){if(typeof F[tt]!="string")throw new TypeError(`tensor data at index ${tt} is not a string`);r.HEAPU32[J++]=(0,u.allocWasmString)(F[tt],A)}}else H=F.byteLength,q=r._malloc(H),A.push(q),r.HEAPU8.set(new Uint8Array(F.buffer,F.byteOffset,H),q);const K=r.stackSave(),X=r.stackAlloc(4*E.length);try{let J=X/4;E.forEach(nt=>r.HEAP32[J++]=nt);const tt=r._OrtCreateTensor((0,h.tensorDataTypeStringToEnum)(O),q,H,X,E.length);tt===0&&(0,u.checkLastError)(`Can't create tensor for input[${U}].`),x.push(tt)}finally{r.stackRestore(K)}}const D=r.stackSave(),$=r.stackAlloc(4*y),j=r.stackAlloc(4*y),M=r.stackAlloc(4*v),S=r.stackAlloc(4*v);try{let U=$/4,O=j/4,E=M/4,F=S/4;for(let X=0;X<y;X++)r.HEAPU32[U++]=x[X],r.HEAPU32[O++]=f[o[X]];for(let X=0;X<v;X++)r.HEAPU32[E++]=0,r.HEAPU32[F++]=g[t[X]];let q=r._OrtRun(s,j,$,y,S,v,M,w);const H=r.jsepRunPromise;H&&H.then!==void 0&&(q=await H);const K=[];q!==0&&(0,u.checkLastError)("failed to call OrtRun().");for(let X=0;X<v;X++){const J=r.HEAPU32[M/4+X],tt=r.stackSave(),nt=r.stackAlloc(16);let rt,it=0;try{q=r._OrtGetTensorData(J,nt,nt+4,nt+8,nt+12),q!==0&&(0,u.checkLastError)(`Can't access output tensor data on index ${X}.`);let ut=nt/4;const gt=r.HEAPU32[ut++];it=r.HEAPU32[ut++];const xt=r.HEAPU32[ut++],kt=r.HEAPU32[ut++],mt=[];for(let lt=0;lt<kt;lt++)mt.push(r.HEAPU32[xt/4+lt]);r._OrtFree(xt);const Dt=mt.length===0?1:mt.reduce((lt,bt)=>lt*bt);if(rt=(0,h.tensorDataTypeEnumToString)(gt),rt==="string"){const lt=[];let bt=it/4;for(let St=0;St<Dt;St++){const _t=r.HEAPU32[bt++],At=St===Dt-1?void 0:r.HEAPU32[bt]-_t;lt.push(r.UTF8ToString(_t,At))}K.push([rt,mt,lt])}else{const lt=new((0,h.tensorTypeToTypedArrayConstructor)(rt))(Dt);new Uint8Array(lt.buffer,lt.byteOffset,lt.byteLength).set(r.HEAPU8.subarray(it,it+lt.byteLength)),K.push([rt,mt,lt])}}finally{r.stackRestore(tt),rt==="string"&&it&&r._free(it),r._OrtReleaseTensor(J)}}return K}finally{r.stackRestore(D)}}finally{x.forEach(D=>r._OrtReleaseTensor(D)),A.forEach(D=>r._free(D)),w!==0&&r._OrtReleaseRunOptions(w),T.forEach(D=>r._free(D))}},l.endProfiling=a=>{const o=(0,d.getInstance)(),n=c.get(a);if(!n)throw new Error("invalid session id");const t=n[0],e=o._OrtEndProfiling(t);e===0&&(0,u.checkLastError)("Can't get an profile file name."),o._OrtFree(e)},l.extractTransferableBuffers=a=>{const o=[];for(const n of a){const t=n[2];!Array.isArray(t)&&t.buffer&&o.push(t.buffer)}return o}},263:function(R,l,b){var m=this&&this.__createBinding||(Object.create?function(e,r,i,s){s===void 0&&(s=i);var f=Object.getOwnPropertyDescriptor(r,i);f&&!("get"in f?!r.__esModule:f.writable||f.configurable)||(f={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(e,s,f)}:function(e,r,i,s){s===void 0&&(s=i),e[s]=r[i]}),p=this&&this.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),h=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var r={};if(e!=null)for(var i in e)i!=="default"&&Object.prototype.hasOwnProperty.call(e,i)&&m(r,e,i);return p(r,e),r};Object.defineProperty(l,"__esModule",{value:!0}),l.dispose=l.getInstance=l.initializeWebAssembly=void 0;const d=h(b(6449)),u=b(932),c=b(3474);let a,o=!1,n=!1,t=!1;l.initializeWebAssembly=async e=>{if(o)return Promise.resolve();if(n)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(t)throw new Error("previous call to 'initializeWebAssembly()' failed.");n=!0;const r=e.initTimeout,i=e.numThreads,s=e.simd,f=i>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),g=s&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),y=e.wasmPaths,v=typeof y=="string"?y:void 0,w=((D,$)=>$?D?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":D?"ort-wasm-simd.wasm":"ort-wasm.wasm")(g,f),T=typeof y=="object"?y[w]:void 0;let x=!1;const A=[];if(r>0&&A.push(new Promise(D=>{setTimeout(()=>{x=!0,D()},r)})),A.push(new Promise((D,$)=>{const j=f?c:u,M={locateFile:(S,U)=>f&&S.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([b(4154)],{type:"text/javascript"})):S.endsWith(".wasm")?T||(v??U)+w:U+S};if(f)if(typeof Blob>"u")M.mainScriptUrlOrBlob=d.join(__dirname,"ort-wasm-threaded.js");else{const S=`var ortWasmThreaded=(function(){var _scriptDir;return ${j.toString()}})();`;M.mainScriptUrlOrBlob=new Blob([S],{type:"text/javascript"})}j(M).then(S=>{n=!1,o=!0,a=S,D()},S=>{n=!1,t=!0,$(S)})})),await Promise.race(A),x)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},l.getInstance=()=>{if(o&&a)return a;throw new Error("WebAssembly is not initialized yet.")},l.dispose=()=>{var e;!o||n||t||(n=!0,(e=a.PThread)===null||e===void 0||e.terminateAllThreads(),a=void 0,n=!1,o=!1,t=!0)}},1497:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.checkLastError=l.iterateExtraOptions=l.allocWasmString=void 0;const m=b(263);l.allocWasmString=(p,h)=>{const d=(0,m.getInstance)(),u=d.lengthBytesUTF8(p)+1,c=d._malloc(u);return d.stringToUTF8(p,c,u),h.push(c),c},l.iterateExtraOptions=(p,h,d,u)=>{if(typeof p=="object"&&p!==null){if(d.has(p))throw new Error("Circular reference in options");d.add(p)}Object.entries(p).forEach(([c,a])=>{const o=h?h+c:c;if(typeof a=="object")(0,l.iterateExtraOptions)(a,o+".",d,u);else if(typeof a=="string"||typeof a=="number")u(o,a.toString());else{if(typeof a!="boolean")throw new Error("Can't handle extra config type: "+typeof a);u(o,a?"1":"0")}})},l.checkLastError=p=>{const h=(0,m.getInstance)(),d=h.stackSave();try{const u=h.stackAlloc(8);h._OrtGetLastError(u,u+4);const c=h.HEAP32[u/4],a=h.HEAPU32[u/4+1],o=a?h.UTF8ToString(a):"";throw new Error(`${p} ERROR_CODE: ${c}, ERROR_MESSAGE: ${o}`)}finally{h.stackRestore(d)}}},8050:(R,l,b)=>{b.d(l,{Z:()=>h});var m=b(6614),p=b.n(m);function h(){return p()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:"all"),f=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:"sequential"),d="string"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)("Can\'t create session options."),l.executionProviders&&((e,t,r)=>{for(const o of t){let t="string"==typeof o?o:o.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)("deviceType",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)("powerPreference",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,"",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)("Can\'t create a session.");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),"string"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(d)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h="string"==typeof g?g:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(p,o),y="object"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=h?h:t)+m:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g="./this.program",h=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+"/":__dirname+"/",l=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:"utf8")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{t=r(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&"undefined"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>O.writeSync(2,e.join(" ")+"\\n"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&te("no native wasm support detected");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te("INITIAL_MEMORY should be larger than STACK_SIZE, was "+j+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e="Aborted("+e+")"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function re(e){return e.startsWith("data:application/octet-stream;base64,")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R("failed to asynchronously prepare wasm: "+e),te(e)}))}function oe(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:"run",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V="ort-wasm-threaded.wasm")||(V=_(V));var ce="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):"";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),"unwind";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:["$terminateWorker"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\'Internal error! Worker sent a message "\'+n+\'" to target pthread \'+r.targetThread+", but that thread no longer exists!")}else"checkMailbox"===n?He():"spawnThread"===n?ue(r):"cleanupThread"===n?se(r.thread):"killThread"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):"cancelThread"===n?ge.Fa[r.thread].postMessage({cmd:"cancel"}):"loaded"===n?(e.loaded=!0,t(e)):"alert"===n?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===n?c[r.handler](...r.args):n&&R("worker sent an unknown command "+n)},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var r,n=[];for(r of["onExit","onAbort","print","printErr"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:"load",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_("ort-wasm-threaded.worker.js");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,"undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob="spawnThread",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||"unwind"==e||h(1,e)}}catch(e){e instanceof oe||"unwind"==e||h(1,e)}};function We(e){e>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te("initRandomDevice")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,"0")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):""},r=fe(r),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),l[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(f in l={"%a":e=>d[e.Ga].substring(0,3),"%A":e=>d[e.Ga],"%b":e=>p[e.Na].substring(0,3),"%B":e=>p[e.Na],"%C":e=>i((e.Ka+1900)/100|0,2),"%d":e=>i(e.Qa,2),"%e":e=>o(e.Qa,2," "),"%g":e=>c(e).toString().substring(2),"%G":e=>c(e),"%H":e=>i(e.Ma,2),"%I":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},"%m":e=>i(e.Na+1,2),"%M":e=>i(e.jb,2),"%n":()=>"\\n","%p":e=>0<=e.Ma&&12>e.Ma?"AM":"PM","%S":e=>i(e.kb,2),"%t":()=>"\\t","%u":e=>e.Ga||7,"%U":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),"%V":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},"%w":e=>e.Ga,"%W":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),"%y":e=>(e.Ka+1900).toString().substring(2),"%Y":e=>e.Ka+1900,"%z":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.lb,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),l)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=ge.Fa[e])&&e.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te("")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var r=V;return T||"function"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith("file://")||v||"function"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R("wasm streaming compile failed: "+n),R("falling back to ArrayBuffer instantiation"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c="./this.program",l=(e,t)=>{throw t},f="object"==typeof window,d="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+"/":__dirname+"/",o=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:"utf8")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(f||d)&&(d?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e="Aborted("+e+")"),M=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function H(e){return e.startsWith("data:application/octet-stream;base64,")}if(!H(D="ort-wasm.wasm")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function z(e,t,r){return function(e){if(!y&&(f||d)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b("failed to asynchronously prepare wasm: "+e),W(e)}))}function G(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):"",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):""},r=J(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(l in c={"%a":e=>f[e.ha].substring(0,3),"%A":e=>f[e.ha],"%b":e=>d[e.pa].substring(0,3),"%B":e=>d[e.pa],"%C":e=>o((e.na+1900)/100|0,2),"%d":e=>o(e.ra,2),"%e":e=>a(e.ra,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>o(e.oa,2),"%I":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},"%m":e=>o(e.pa+1,2),"%M":e=>o(e.xa,2),"%n":()=>"\\n","%p":e=>0<=e.oa&&12>e.oa?"AM":"PM","%S":e=>o(e.ya,2),"%t":()=>"\\t","%u":e=>e.ha||7,"%U":e=>o(Math.floor((e.ma+7-e.ha)/7),2),"%V":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},"%w":e=>e.ha,"%W":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),"%y":e=>(e.na+1900).toString().substring(2),"%Y":e=>e.na+1900,"%z":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.za,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),c)r.includes(l)&&(r=r.replace(new RegExp(l,"g"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var r=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith("file://")||p||"function"!=typeof fetch?z(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b("wasm streaming compile failed: "+n),b("falling back to ArrayBuffer instantiation"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{"use strict";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:n})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:R=>{R.exports=function(l,b,m,p){var h=self||window;try{try{var d;try{d=new h.Blob([l])}catch{(d=new(h.BlobBuilder||h.WebKitBlobBuilder||h.MozBlobBuilder||h.MSBlobBuilder)).append(l),d=d.getBlob()}var u=h.URL||h.webkitURL,c=u.createObjectURL(d),a=new h[b](c,m);return u.revokeObjectURL(c),a}catch{return new h[b]("data:application/javascript,".concat(encodeURIComponent(l)),m)}}catch{if(!p)throw Error("Inline worker is not supported");return new h[b](p,m)}}},2446:(R,l,b)=>{var m,p,h,d=b(2100),u=d.Reader,c=d.Writer,a=d.util,o=d.roots.default||(d.roots.default={});o.onnx=((h={}).Version=(m={},(p=Object.create(m))[m[0]="_START_VERSION"]=0,p[m[1]="IR_VERSION_2017_10_10"]=1,p[m[2]="IR_VERSION_2017_10_30"]=2,p[m[3]="IR_VERSION_2017_11_3"]=3,p[m[4]="IR_VERSION_2019_1_22"]=4,p[m[5]="IR_VERSION_2019_3_18"]=5,p[m[6]="IR_VERSION_2019_9_19"]=6,p[m[7]="IR_VERSION_2020_5_8"]=7,p[m[8]="IR_VERSION_2021_7_30"]=8,p[m[9]="IR_VERSION"]=9,p),h.AttributeProto=function(){function n(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.name="",n.prototype.refAttrName="",n.prototype.docString="",n.prototype.type=0,n.prototype.f=0,n.prototype.i=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.s=a.newBuffer([]),n.prototype.t=null,n.prototype.g=null,n.prototype.sparseTensor=null,n.prototype.tp=null,n.prototype.floats=a.emptyArray,n.prototype.ints=a.emptyArray,n.prototype.strings=a.emptyArray,n.prototype.tensors=a.emptyArray,n.prototype.graphs=a.emptyArray,n.prototype.sparseTensors=a.emptyArray,n.prototype.typeProtos=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&e.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&e.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&e.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&e.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&o.onnx.TensorProto.encode(t.t,e.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&o.onnx.GraphProto.encode(t.g,e.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){e.uint32(58).fork();for(var r=0;r<t.floats.length;++r)e.float(t.floats[r]);e.ldelim()}if(t.ints!=null&&t.ints.length){for(e.uint32(66).fork(),r=0;r<t.ints.length;++r)e.int64(t.ints[r]);e.ldelim()}if(t.strings!=null&&t.strings.length)for(r=0;r<t.strings.length;++r)e.uint32(74).bytes(t.strings[r]);if(t.tensors!=null&&t.tensors.length)for(r=0;r<t.tensors.length;++r)o.onnx.TensorProto.encode(t.tensors[r],e.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(r=0;r<t.graphs.length;++r)o.onnx.GraphProto.encode(t.graphs[r],e.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&o.onnx.TypeProto.encode(t.tp,e.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(r=0;r<t.typeProtos.length;++r)o.onnx.TypeProto.encode(t.typeProtos[r],e.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&e.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&e.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&o.onnx.SparseTensorProto.encode(t.sparseTensor,e.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(r=0;r<t.sparseTensors.length;++r)o.onnx.SparseTensorProto.encode(t.sparseTensors[r],e.uint32(186).fork()).ldelim();return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.AttributeProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.name=t.string();break;case 21:i.refAttrName=t.string();break;case 13:i.docString=t.string();break;case 20:i.type=t.int32();break;case 2:i.f=t.float();break;case 3:i.i=t.int64();break;case 4:i.s=t.bytes();break;case 5:i.t=o.onnx.TensorProto.decode(t,t.uint32());break;case 6:i.g=o.onnx.GraphProto.decode(t,t.uint32());break;case 22:i.sparseTensor=o.onnx.SparseTensorProto.decode(t,t.uint32());break;case 14:i.tp=o.onnx.TypeProto.decode(t,t.uint32());break;case 7:if(i.floats&&i.floats.length||(i.floats=[]),(7&s)==2)for(var f=t.uint32()+t.pos;t.pos<f;)i.floats.push(t.float());else i.floats.push(t.float());break;case 8:if(i.ints&&i.ints.length||(i.ints=[]),(7&s)==2)for(f=t.uint32()+t.pos;t.pos<f;)i.ints.push(t.int64());else i.ints.push(t.int64());break;case 9:i.strings&&i.strings.length||(i.strings=[]),i.strings.push(t.bytes());break;case 10:i.tensors&&i.tensors.length||(i.tensors=[]),i.tensors.push(o.onnx.TensorProto.decode(t,t.uint32()));break;case 11:i.graphs&&i.graphs.length||(i.graphs=[]),i.graphs.push(o.onnx.GraphProto.decode(t,t.uint32()));break;case 23:i.sparseTensors&&i.sparseTensors.length||(i.sparseTensors=[]),i.sparseTensors.push(o.onnx.SparseTensorProto.decode(t,t.uint32()));break;case 15:i.typeProtos&&i.typeProtos.length||(i.typeProtos=[]),i.typeProtos.push(o.onnx.TypeProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!a.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!(a.isInteger(t.i)||t.i&&a.isInteger(t.i.low)&&a.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||a.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")&&(r=o.onnx.TensorProto.verify(t.t)))return"t."+r;if(t.g!=null&&t.hasOwnProperty("g")&&(r=o.onnx.GraphProto.verify(t.g)))return"g."+r;if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(r=o.onnx.SparseTensorProto.verify(t.sparseTensor)))return"sparseTensor."+r;if(t.tp!=null&&t.hasOwnProperty("tp")&&(r=o.onnx.TypeProto.verify(t.tp)))return"tp."+r;if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var e=0;e<t.floats.length;++e)if(typeof t.floats[e]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(e=0;e<t.ints.length;++e)if(!(a.isInteger(t.ints[e])||t.ints[e]&&a.isInteger(t.ints[e].low)&&a.isInteger(t.ints[e].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(e=0;e<t.strings.length;++e)if(!(t.strings[e]&&typeof t.strings[e].length=="number"||a.isString(t.strings[e])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(e=0;e<t.tensors.length;++e)if(r=o.onnx.TensorProto.verify(t.tensors[e]))return"tensors."+r}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(e=0;e<t.graphs.length;++e)if(r=o.onnx.GraphProto.verify(t.graphs[e]))return"graphs."+r}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(e=0;e<t.sparseTensors.length;++e)if(r=o.onnx.SparseTensorProto.verify(t.sparseTensors[e]))return"sparseTensors."+r}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(e=0;e<t.typeProtos.length;++e){var r;if(r=o.onnx.TypeProto.verify(t.typeProtos[e]))return"typeProtos."+r}}return null},n.fromObject=function(t){if(t instanceof o.onnx.AttributeProto)return t;var e=new o.onnx.AttributeProto;switch(t.name!=null&&(e.name=String(t.name)),t.refAttrName!=null&&(e.refAttrName=String(t.refAttrName)),t.docString!=null&&(e.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){e.type=t.type;break}break;case"UNDEFINED":case 0:e.type=0;break;case"FLOAT":case 1:e.type=1;break;case"INT":case 2:e.type=2;break;case"STRING":case 3:e.type=3;break;case"TENSOR":case 4:e.type=4;break;case"GRAPH":case 5:e.type=5;break;case"SPARSE_TENSOR":case 11:e.type=11;break;case"TYPE_PROTO":case 13:e.type=13;break;case"FLOATS":case 6:e.type=6;break;case"INTS":case 7:e.type=7;break;case"STRINGS":case 8:e.type=8;break;case"TENSORS":case 9:e.type=9;break;case"GRAPHS":case 10:e.type=10;break;case"SPARSE_TENSORS":case 12:e.type=12;break;case"TYPE_PROTOS":case 14:e.type=14}if(t.f!=null&&(e.f=Number(t.f)),t.i!=null&&(a.Long?(e.i=a.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?e.i=parseInt(t.i,10):typeof t.i=="number"?e.i=t.i:typeof t.i=="object"&&(e.i=new a.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?a.base64.decode(t.s,e.s=a.newBuffer(a.base64.length(t.s)),0):t.s.length>=0&&(e.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");e.t=o.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");e.g=o.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");e.sparseTensor=o.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");e.tp=o.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");e.floats=[];for(var r=0;r<t.floats.length;++r)e.floats[r]=Number(t.floats[r])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(e.ints=[],r=0;r<t.ints.length;++r)a.Long?(e.ints[r]=a.Long.fromValue(t.ints[r])).unsigned=!1:typeof t.ints[r]=="string"?e.ints[r]=parseInt(t.ints[r],10):typeof t.ints[r]=="number"?e.ints[r]=t.ints[r]:typeof t.ints[r]=="object"&&(e.ints[r]=new a.LongBits(t.ints[r].low>>>0,t.ints[r].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(e.strings=[],r=0;r<t.strings.length;++r)typeof t.strings[r]=="string"?a.base64.decode(t.strings[r],e.strings[r]=a.newBuffer(a.base64.length(t.strings[r])),0):t.strings[r].length>=0&&(e.strings[r]=t.strings[r])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(e.tensors=[],r=0;r<t.tensors.length;++r){if(typeof t.tensors[r]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");e.tensors[r]=o.onnx.TensorProto.fromObject(t.tensors[r])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(e.graphs=[],r=0;r<t.graphs.length;++r){if(typeof t.graphs[r]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");e.graphs[r]=o.onnx.GraphProto.fromObject(t.graphs[r])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");for(e.sparseTensors=[],r=0;r<t.sparseTensors.length;++r){if(typeof t.sparseTensors[r]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");e.sparseTensors[r]=o.onnx.SparseTensorProto.fromObject(t.sparseTensors[r])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");for(e.typeProtos=[],r=0;r<t.typeProtos.length;++r){if(typeof t.typeProtos[r]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");e.typeProtos[r]=o.onnx.TypeProto.fromObject(t.typeProtos[r])}}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.floats=[],r.ints=[],r.strings=[],r.tensors=[],r.graphs=[],r.typeProtos=[],r.sparseTensors=[]),e.defaults){if(r.name="",r.f=0,a.Long){var i=new a.Long(0,0,!1);r.i=e.longs===String?i.toString():e.longs===Number?i.toNumber():i}else r.i=e.longs===String?"0":0;e.bytes===String?r.s="":(r.s=[],e.bytes!==Array&&(r.s=a.newBuffer(r.s))),r.t=null,r.g=null,r.docString="",r.tp=null,r.type=e.enums===String?"UNDEFINED":0,r.refAttrName="",r.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(r.f=e.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?r.i=e.longs===String?String(t.i):t.i:r.i=e.longs===String?a.Long.prototype.toString.call(t.i):e.longs===Number?new a.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(r.s=e.bytes===String?a.base64.encode(t.s,0,t.s.length):e.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(r.t=o.onnx.TensorProto.toObject(t.t,e)),t.g!=null&&t.hasOwnProperty("g")&&(r.g=o.onnx.GraphProto.toObject(t.g,e)),t.floats&&t.floats.length){r.floats=[];for(var s=0;s<t.floats.length;++s)r.floats[s]=e.json&&!isFinite(t.floats[s])?String(t.floats[s]):t.floats[s]}if(t.ints&&t.ints.length)for(r.ints=[],s=0;s<t.ints.length;++s)typeof t.ints[s]=="number"?r.ints[s]=e.longs===String?String(t.ints[s]):t.ints[s]:r.ints[s]=e.longs===String?a.Long.prototype.toString.call(t.ints[s]):e.longs===Number?new a.LongBits(t.ints[s].low>>>0,t.ints[s].high>>>0).toNumber():t.ints[s];if(t.strings&&t.strings.length)for(r.strings=[],s=0;s<t.strings.length;++s)r.strings[s]=e.bytes===String?a.base64.encode(t.strings[s],0,t.strings[s].length):e.bytes===Array?Array.prototype.slice.call(t.strings[s]):t.strings[s];if(t.tensors&&t.tensors.length)for(r.tensors=[],s=0;s<t.tensors.length;++s)r.tensors[s]=o.onnx.TensorProto.toObject(t.tensors[s],e);if(t.graphs&&t.graphs.length)for(r.graphs=[],s=0;s<t.graphs.length;++s)r.graphs[s]=o.onnx.GraphProto.toObject(t.graphs[s],e);if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(r.tp=o.onnx.TypeProto.toObject(t.tp,e)),t.typeProtos&&t.typeProtos.length)for(r.typeProtos=[],s=0;s<t.typeProtos.length;++s)r.typeProtos[s]=o.onnx.TypeProto.toObject(t.typeProtos[s],e);if(t.type!=null&&t.hasOwnProperty("type")&&(r.type=e.enums===String?o.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:o.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(r.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(r.sparseTensor=o.onnx.SparseTensorProto.toObject(t.sparseTensor,e)),t.sparseTensors&&t.sparseTensors.length)for(r.sparseTensors=[],s=0;s<t.sparseTensors.length;++s)r.sparseTensors[s]=o.onnx.SparseTensorProto.toObject(t.sparseTensors[s],e);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},n.AttributeType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="INT"]=2,e[t[3]="STRING"]=3,e[t[4]="TENSOR"]=4,e[t[5]="GRAPH"]=5,e[t[11]="SPARSE_TENSOR"]=11,e[t[13]="TYPE_PROTO"]=13,e[t[6]="FLOATS"]=6,e[t[7]="INTS"]=7,e[t[8]="STRINGS"]=8,e[t[9]="TENSORS"]=9,e[t[10]="GRAPHS"]=10,e[t[12]="SPARSE_TENSORS"]=12,e[t[14]="TYPE_PROTOS"]=14,e}(),n}(),h.ValueInfoProto=function(){function n(t){if(t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.name="",n.prototype.type=null,n.prototype.docString="",n.create=function(t){return new n(t)},n.encode=function(t,e){return e||(e=c.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&e.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&o.onnx.TypeProto.encode(t.type,e.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(26).string(t.docString),e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.ValueInfoProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.name=t.string();break;case 2:i.type=o.onnx.TypeProto.decode(t,t.uint32());break;case 3:i.docString=t.string();break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var e=o.onnx.TypeProto.verify(t.type);if(e)return"type."+e}return t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString)?"docString: string expected":null},n.fromObject=function(t){if(t instanceof o.onnx.ValueInfoProto)return t;var e=new o.onnx.ValueInfoProto;if(t.name!=null&&(e.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");e.type=o.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(e.docString=String(t.docString)),e},n.toObject=function(t,e){e||(e={});var r={};return e.defaults&&(r.name="",r.type=null,r.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(r.type=o.onnx.TypeProto.toObject(t.type,e)),t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},n}(),h.NodeProto=function(){function n(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.name="",n.prototype.opType="",n.prototype.domain="",n.prototype.attribute=a.emptyArray,n.prototype.docString="",n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.input!=null&&t.input.length)for(var r=0;r<t.input.length;++r)e.uint32(10).string(t.input[r]);if(t.output!=null&&t.output.length)for(r=0;r<t.output.length;++r)e.uint32(18).string(t.output[r]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&e.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&e.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(r=0;r<t.attribute.length;++r)o.onnx.AttributeProto.encode(t.attribute[r],e.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(58).string(t.domain),e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.NodeProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.input&&i.input.length||(i.input=[]),i.input.push(t.string());break;case 2:i.output&&i.output.length||(i.output=[]),i.output.push(t.string());break;case 3:i.name=t.string();break;case 4:i.opType=t.string();break;case 7:i.domain=t.string();break;case 5:i.attribute&&i.attribute.length||(i.attribute=[]),i.attribute.push(o.onnx.AttributeProto.decode(t,t.uint32()));break;case 6:i.docString=t.string();break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var e=0;e<t.input.length;++e)if(!a.isString(t.input[e]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(!a.isString(t.output[e]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!a.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!a.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(e=0;e<t.attribute.length;++e){var r=o.onnx.AttributeProto.verify(t.attribute[e]);if(r)return"attribute."+r}}return t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString)?"docString: string expected":null},n.fromObject=function(t){if(t instanceof o.onnx.NodeProto)return t;var e=new o.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");e.input=[];for(var r=0;r<t.input.length;++r)e.input[r]=String(t.input[r])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");for(e.output=[],r=0;r<t.output.length;++r)e.output[r]=String(t.output[r])}if(t.name!=null&&(e.name=String(t.name)),t.opType!=null&&(e.opType=String(t.opType)),t.domain!=null&&(e.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(e.attribute=[],r=0;r<t.attribute.length;++r){if(typeof t.attribute[r]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");e.attribute[r]=o.onnx.AttributeProto.fromObject(t.attribute[r])}}return t.docString!=null&&(e.docString=String(t.docString)),e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.input=[],r.output=[],r.attribute=[]),e.defaults&&(r.name="",r.opType="",r.docString="",r.domain=""),t.input&&t.input.length){r.input=[];for(var i=0;i<t.input.length;++i)r.input[i]=t.input[i]}if(t.output&&t.output.length)for(r.output=[],i=0;i<t.output.length;++i)r.output[i]=t.output[i];if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(r.opType=t.opType),t.attribute&&t.attribute.length)for(r.attribute=[],i=0;i<t.attribute.length;++i)r.attribute[i]=o.onnx.AttributeProto.toObject(t.attribute[i],e);return t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},n}(),h.TrainingInfoProto=function(){function n(t){if(this.initializationBinding=[],this.updateBinding=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.initialization=null,n.prototype.algorithm=null,n.prototype.initializationBinding=a.emptyArray,n.prototype.updateBinding=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&o.onnx.GraphProto.encode(t.initialization,e.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&o.onnx.GraphProto.encode(t.algorithm,e.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var r=0;r<t.initializationBinding.length;++r)o.onnx.StringStringEntryProto.encode(t.initializationBinding[r],e.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(r=0;r<t.updateBinding.length;++r)o.onnx.StringStringEntryProto.encode(t.updateBinding[r],e.uint32(34).fork()).ldelim();return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.TrainingInfoProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.initialization=o.onnx.GraphProto.decode(t,t.uint32());break;case 2:i.algorithm=o.onnx.GraphProto.decode(t,t.uint32());break;case 3:i.initializationBinding&&i.initializationBinding.length||(i.initializationBinding=[]),i.initializationBinding.push(o.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 4:i.updateBinding&&i.updateBinding.length||(i.updateBinding=[]),i.updateBinding.push(o.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")&&(r=o.onnx.GraphProto.verify(t.initialization)))return"initialization."+r;if(t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(r=o.onnx.GraphProto.verify(t.algorithm)))return"algorithm."+r;if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var e=0;e<t.initializationBinding.length;++e)if(r=o.onnx.StringStringEntryProto.verify(t.initializationBinding[e]))return"initializationBinding."+r}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(e=0;e<t.updateBinding.length;++e){var r;if(r=o.onnx.StringStringEntryProto.verify(t.updateBinding[e]))return"updateBinding."+r}}return null},n.fromObject=function(t){if(t instanceof o.onnx.TrainingInfoProto)return t;var e=new o.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");e.initialization=o.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");e.algorithm=o.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");e.initializationBinding=[];for(var r=0;r<t.initializationBinding.length;++r){if(typeof t.initializationBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");e.initializationBinding[r]=o.onnx.StringStringEntryProto.fromObject(t.initializationBinding[r])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");for(e.updateBinding=[],r=0;r<t.updateBinding.length;++r){if(typeof t.updateBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");e.updateBinding[r]=o.onnx.StringStringEntryProto.fromObject(t.updateBinding[r])}}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.initializationBinding=[],r.updateBinding=[]),e.defaults&&(r.initialization=null,r.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(r.initialization=o.onnx.GraphProto.toObject(t.initialization,e)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(r.algorithm=o.onnx.GraphProto.toObject(t.algorithm,e)),t.initializationBinding&&t.initializationBinding.length){r.initializationBinding=[];for(var i=0;i<t.initializationBinding.length;++i)r.initializationBinding[i]=o.onnx.StringStringEntryProto.toObject(t.initializationBinding[i],e)}if(t.updateBinding&&t.updateBinding.length)for(r.updateBinding=[],i=0;i<t.updateBinding.length;++i)r.updateBinding[i]=o.onnx.StringStringEntryProto.toObject(t.updateBinding[i],e);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},n}(),h.ModelProto=function(){function n(t){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.irVersion=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.opsetImport=a.emptyArray,n.prototype.producerName="",n.prototype.producerVersion="",n.prototype.domain="",n.prototype.modelVersion=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.docString="",n.prototype.graph=null,n.prototype.metadataProps=a.emptyArray,n.prototype.trainingInfo=a.emptyArray,n.prototype.functions=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&e.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&e.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&e.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&e.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&o.onnx.GraphProto.encode(t.graph,e.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var r=0;r<t.opsetImport.length;++r)o.onnx.OperatorSetIdProto.encode(t.opsetImport[r],e.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(r=0;r<t.metadataProps.length;++r)o.onnx.StringStringEntryProto.encode(t.metadataProps[r],e.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(r=0;r<t.trainingInfo.length;++r)o.onnx.TrainingInfoProto.encode(t.trainingInfo[r],e.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(r=0;r<t.functions.length;++r)o.onnx.FunctionProto.encode(t.functions[r],e.uint32(202).fork()).ldelim();return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.ModelProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.irVersion=t.int64();break;case 8:i.opsetImport&&i.opsetImport.length||(i.opsetImport=[]),i.opsetImport.push(o.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 2:i.producerName=t.string();break;case 3:i.producerVersion=t.string();break;case 4:i.domain=t.string();break;case 5:i.modelVersion=t.int64();break;case 6:i.docString=t.string();break;case 7:i.graph=o.onnx.GraphProto.decode(t,t.uint32());break;case 14:i.metadataProps&&i.metadataProps.length||(i.metadataProps=[]),i.metadataProps.push(o.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 20:i.trainingInfo&&i.trainingInfo.length||(i.trainingInfo=[]),i.trainingInfo.push(o.onnx.TrainingInfoProto.decode(t,t.uint32()));break;case 25:i.functions&&i.functions.length||(i.functions=[]),i.functions.push(o.onnx.FunctionProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!(a.isInteger(t.irVersion)||t.irVersion&&a.isInteger(t.irVersion.low)&&a.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var e=0;e<t.opsetImport.length;++e)if(r=o.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return"opsetImport."+r}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!a.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!a.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!a.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!(a.isInteger(t.modelVersion)||t.modelVersion&&a.isInteger(t.modelVersion.low)&&a.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")&&(r=o.onnx.GraphProto.verify(t.graph)))return"graph."+r;if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(e=0;e<t.metadataProps.length;++e)if(r=o.onnx.StringStringEntryProto.verify(t.metadataProps[e]))return"metadataProps."+r}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(e=0;e<t.trainingInfo.length;++e)if(r=o.onnx.TrainingInfoProto.verify(t.trainingInfo[e]))return"trainingInfo."+r}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(e=0;e<t.functions.length;++e){var r;if(r=o.onnx.FunctionProto.verify(t.functions[e]))return"functions."+r}}return null},n.fromObject=function(t){if(t instanceof o.onnx.ModelProto)return t;var e=new o.onnx.ModelProto;if(t.irVersion!=null&&(a.Long?(e.irVersion=a.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?e.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?e.irVersion=t.irVersion:typeof t.irVersion=="object"&&(e.irVersion=new a.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");e.opsetImport=[];for(var r=0;r<t.opsetImport.length;++r){if(typeof t.opsetImport[r]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");e.opsetImport[r]=o.onnx.OperatorSetIdProto.fromObject(t.opsetImport[r])}}if(t.producerName!=null&&(e.producerName=String(t.producerName)),t.producerVersion!=null&&(e.producerVersion=String(t.producerVersion)),t.domain!=null&&(e.domain=String(t.domain)),t.modelVersion!=null&&(a.Long?(e.modelVersion=a.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?e.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?e.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(e.modelVersion=new a.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(e.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");e.graph=o.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(e.metadataProps=[],r=0;r<t.metadataProps.length;++r){if(typeof t.metadataProps[r]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");e.metadataProps[r]=o.onnx.StringStringEntryProto.fromObject(t.metadataProps[r])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");for(e.trainingInfo=[],r=0;r<t.trainingInfo.length;++r){if(typeof t.trainingInfo[r]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");e.trainingInfo[r]=o.onnx.TrainingInfoProto.fromObject(t.trainingInfo[r])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");for(e.functions=[],r=0;r<t.functions.length;++r){if(typeof t.functions[r]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");e.functions[r]=o.onnx.FunctionProto.fromObject(t.functions[r])}}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.opsetImport=[],r.metadataProps=[],r.trainingInfo=[],r.functions=[]),e.defaults){if(a.Long){var i=new a.Long(0,0,!1);r.irVersion=e.longs===String?i.toString():e.longs===Number?i.toNumber():i}else r.irVersion=e.longs===String?"0":0;r.producerName="",r.producerVersion="",r.domain="",a.Long?(i=new a.Long(0,0,!1),r.modelVersion=e.longs===String?i.toString():e.longs===Number?i.toNumber():i):r.modelVersion=e.longs===String?"0":0,r.docString="",r.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?r.irVersion=e.longs===String?String(t.irVersion):t.irVersion:r.irVersion=e.longs===String?a.Long.prototype.toString.call(t.irVersion):e.longs===Number?new a.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(r.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(r.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?r.modelVersion=e.longs===String?String(t.modelVersion):t.modelVersion:r.modelVersion=e.longs===String?a.Long.prototype.toString.call(t.modelVersion):e.longs===Number?new a.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(r.graph=o.onnx.GraphProto.toObject(t.graph,e)),t.opsetImport&&t.opsetImport.length){r.opsetImport=[];for(var s=0;s<t.opsetImport.length;++s)r.opsetImport[s]=o.onnx.OperatorSetIdProto.toObject(t.opsetImport[s],e)}if(t.metadataProps&&t.metadataProps.length)for(r.metadataProps=[],s=0;s<t.metadataProps.length;++s)r.metadataProps[s]=o.onnx.StringStringEntryProto.toObject(t.metadataProps[s],e);if(t.trainingInfo&&t.trainingInfo.length)for(r.trainingInfo=[],s=0;s<t.trainingInfo.length;++s)r.trainingInfo[s]=o.onnx.TrainingInfoProto.toObject(t.trainingInfo[s],e);if(t.functions&&t.functions.length)for(r.functions=[],s=0;s<t.functions.length;++s)r.functions[s]=o.onnx.FunctionProto.toObject(t.functions[s],e);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},n}(),h.StringStringEntryProto=function(){function n(t){if(t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.key="",n.prototype.value="",n.create=function(t){return new n(t)},n.encode=function(t,e){return e||(e=c.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&e.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&e.uint32(18).string(t.value),e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.StringStringEntryProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.key=t.string();break;case 2:i.value=t.string();break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!a.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!a.isString(t.value)?"value: string expected":null},n.fromObject=function(t){if(t instanceof o.onnx.StringStringEntryProto)return t;var e=new o.onnx.StringStringEntryProto;return t.key!=null&&(e.key=String(t.key)),t.value!=null&&(e.value=String(t.value)),e},n.toObject=function(t,e){e||(e={});var r={};return e.defaults&&(r.key="",r.value=""),t.key!=null&&t.hasOwnProperty("key")&&(r.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(r.value=t.value),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},n}(),h.TensorAnnotation=function(){function n(t){if(this.quantParameterTensorNames=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.tensorName="",n.prototype.quantParameterTensorNames=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&e.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var r=0;r<t.quantParameterTensorNames.length;++r)o.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[r],e.uint32(18).fork()).ldelim();return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.TensorAnnotation;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.tensorName=t.string();break;case 2:i.quantParameterTensorNames&&i.quantParameterTensorNames.length||(i.quantParameterTensorNames=[]),i.quantParameterTensorNames.push(o.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!a.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var e=0;e<t.quantParameterTensorNames.length;++e){var r=o.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);if(r)return"quantParameterTensorNames."+r}}return null},n.fromObject=function(t){if(t instanceof o.onnx.TensorAnnotation)return t;var e=new o.onnx.TensorAnnotation;if(t.tensorName!=null&&(e.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");e.quantParameterTensorNames=[];for(var r=0;r<t.quantParameterTensorNames.length;++r){if(typeof t.quantParameterTensorNames[r]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");e.quantParameterTensorNames[r]=o.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[r])}}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.quantParameterTensorNames=[]),e.defaults&&(r.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(r.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){r.quantParameterTensorNames=[];for(var i=0;i<t.quantParameterTensorNames.length;++i)r.quantParameterTensorNames[i]=o.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[i],e)}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},n}(),h.GraphProto=function(){function n(t){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.node=a.emptyArray,n.prototype.name="",n.prototype.initializer=a.emptyArray,n.prototype.sparseInitializer=a.emptyArray,n.prototype.docString="",n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.valueInfo=a.emptyArray,n.prototype.quantizationAnnotation=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.node!=null&&t.node.length)for(var r=0;r<t.node.length;++r)o.onnx.NodeProto.encode(t.node[r],e.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&e.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(r=0;r<t.initializer.length;++r)o.onnx.TensorProto.encode(t.initializer[r],e.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(r=0;r<t.input.length;++r)o.onnx.ValueInfoProto.encode(t.input[r],e.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(r=0;r<t.output.length;++r)o.onnx.ValueInfoProto.encode(t.output[r],e.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(r=0;r<t.valueInfo.length;++r)o.onnx.ValueInfoProto.encode(t.valueInfo[r],e.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(r=0;r<t.quantizationAnnotation.length;++r)o.onnx.TensorAnnotation.encode(t.quantizationAnnotation[r],e.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(r=0;r<t.sparseInitializer.length;++r)o.onnx.SparseTensorProto.encode(t.sparseInitializer[r],e.uint32(122).fork()).ldelim();return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.GraphProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.node&&i.node.length||(i.node=[]),i.node.push(o.onnx.NodeProto.decode(t,t.uint32()));break;case 2:i.name=t.string();break;case 5:i.initializer&&i.initializer.length||(i.initializer=[]),i.initializer.push(o.onnx.TensorProto.decode(t,t.uint32()));break;case 15:i.sparseInitializer&&i.sparseInitializer.length||(i.sparseInitializer=[]),i.sparseInitializer.push(o.onnx.SparseTensorProto.decode(t,t.uint32()));break;case 10:i.docString=t.string();break;case 11:i.input&&i.input.length||(i.input=[]),i.input.push(o.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 12:i.output&&i.output.length||(i.output=[]),i.output.push(o.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 13:i.valueInfo&&i.valueInfo.length||(i.valueInfo=[]),i.valueInfo.push(o.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 14:i.quantizationAnnotation&&i.quantizationAnnotation.length||(i.quantizationAnnotation=[]),i.quantizationAnnotation.push(o.onnx.TensorAnnotation.decode(t,t.uint32()));break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var e=0;e<t.node.length;++e)if(r=o.onnx.NodeProto.verify(t.node[e]))return"node."+r}if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(e=0;e<t.initializer.length;++e)if(r=o.onnx.TensorProto.verify(t.initializer[e]))return"initializer."+r}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(e=0;e<t.sparseInitializer.length;++e)if(r=o.onnx.SparseTensorProto.verify(t.sparseInitializer[e]))return"sparseInitializer."+r}if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(e=0;e<t.input.length;++e)if(r=o.onnx.ValueInfoProto.verify(t.input[e]))return"input."+r}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(r=o.onnx.ValueInfoProto.verify(t.output[e]))return"output."+r}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(e=0;e<t.valueInfo.length;++e)if(r=o.onnx.ValueInfoProto.verify(t.valueInfo[e]))return"valueInfo."+r}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(e=0;e<t.quantizationAnnotation.length;++e){var r;if(r=o.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e]))return"quantizationAnnotation."+r}}return null},n.fromObject=function(t){if(t instanceof o.onnx.GraphProto)return t;var e=new o.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");e.node=[];for(var r=0;r<t.node.length;++r){if(typeof t.node[r]!="object")throw TypeError(".onnx.GraphProto.node: object expected");e.node[r]=o.onnx.NodeProto.fromObject(t.node[r])}}if(t.name!=null&&(e.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(e.initializer=[],r=0;r<t.initializer.length;++r){if(typeof t.initializer[r]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");e.initializer[r]=o.onnx.TensorProto.fromObject(t.initializer[r])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");for(e.sparseInitializer=[],r=0;r<t.sparseInitializer.length;++r){if(typeof t.sparseInitializer[r]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");e.sparseInitializer[r]=o.onnx.SparseTensorProto.fromObject(t.sparseInitializer[r])}}if(t.docString!=null&&(e.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");for(e.input=[],r=0;r<t.input.length;++r){if(typeof t.input[r]!="object")throw TypeError(".onnx.GraphProto.input: object expected");e.input[r]=o.onnx.ValueInfoProto.fromObject(t.input[r])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");for(e.output=[],r=0;r<t.output.length;++r){if(typeof t.output[r]!="object")throw TypeError(".onnx.GraphProto.output: object expected");e.output[r]=o.onnx.ValueInfoProto.fromObject(t.output[r])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(e.valueInfo=[],r=0;r<t.valueInfo.length;++r){if(typeof t.valueInfo[r]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");e.valueInfo[r]=o.onnx.ValueInfoProto.fromObject(t.valueInfo[r])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(e.quantizationAnnotation=[],r=0;r<t.quantizationAnnotation.length;++r){if(typeof t.quantizationAnnotation[r]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");e.quantizationAnnotation[r]=o.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[r])}}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.node=[],r.initializer=[],r.input=[],r.output=[],r.valueInfo=[],r.quantizationAnnotation=[],r.sparseInitializer=[]),e.defaults&&(r.name="",r.docString=""),t.node&&t.node.length){r.node=[];for(var i=0;i<t.node.length;++i)r.node[i]=o.onnx.NodeProto.toObject(t.node[i],e)}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.initializer&&t.initializer.length)for(r.initializer=[],i=0;i<t.initializer.length;++i)r.initializer[i]=o.onnx.TensorProto.toObject(t.initializer[i],e);if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.input&&t.input.length)for(r.input=[],i=0;i<t.input.length;++i)r.input[i]=o.onnx.ValueInfoProto.toObject(t.input[i],e);if(t.output&&t.output.length)for(r.output=[],i=0;i<t.output.length;++i)r.output[i]=o.onnx.ValueInfoProto.toObject(t.output[i],e);if(t.valueInfo&&t.valueInfo.length)for(r.valueInfo=[],i=0;i<t.valueInfo.length;++i)r.valueInfo[i]=o.onnx.ValueInfoProto.toObject(t.valueInfo[i],e);if(t.quantizationAnnotation&&t.quantizationAnnotation.length)for(r.quantizationAnnotation=[],i=0;i<t.quantizationAnnotation.length;++i)r.quantizationAnnotation[i]=o.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[i],e);if(t.sparseInitializer&&t.sparseInitializer.length)for(r.sparseInitializer=[],i=0;i<t.sparseInitializer.length;++i)r.sparseInitializer[i]=o.onnx.SparseTensorProto.toObject(t.sparseInitializer[i],e);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},n}(),h.TensorProto=function(){function n(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.dims=a.emptyArray,n.prototype.dataType=0,n.prototype.segment=null,n.prototype.floatData=a.emptyArray,n.prototype.int32Data=a.emptyArray,n.prototype.stringData=a.emptyArray,n.prototype.int64Data=a.emptyArray,n.prototype.name="",n.prototype.docString="",n.prototype.rawData=a.newBuffer([]),n.prototype.externalData=a.emptyArray,n.prototype.dataLocation=0,n.prototype.doubleData=a.emptyArray,n.prototype.uint64Data=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.dims!=null&&t.dims.length){e.uint32(10).fork();for(var r=0;r<t.dims.length;++r)e.int64(t.dims[r]);e.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&e.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&o.onnx.TensorProto.Segment.encode(t.segment,e.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){for(e.uint32(34).fork(),r=0;r<t.floatData.length;++r)e.float(t.floatData[r]);e.ldelim()}if(t.int32Data!=null&&t.int32Data.length){for(e.uint32(42).fork(),r=0;r<t.int32Data.length;++r)e.int32(t.int32Data[r]);e.ldelim()}if(t.stringData!=null&&t.stringData.length)for(r=0;r<t.stringData.length;++r)e.uint32(50).bytes(t.stringData[r]);if(t.int64Data!=null&&t.int64Data.length){for(e.uint32(58).fork(),r=0;r<t.int64Data.length;++r)e.int64(t.int64Data[r]);e.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&e.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&e.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){for(e.uint32(82).fork(),r=0;r<t.doubleData.length;++r)e.double(t.doubleData[r]);e.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){for(e.uint32(90).fork(),r=0;r<t.uint64Data.length;++r)e.uint64(t.uint64Data[r]);e.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(r=0;r<t.externalData.length;++r)o.onnx.StringStringEntryProto.encode(t.externalData[r],e.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&e.uint32(112).int32(t.dataLocation),e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.TensorProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:if(i.dims&&i.dims.length||(i.dims=[]),(7&s)==2)for(var f=t.uint32()+t.pos;t.pos<f;)i.dims.push(t.int64());else i.dims.push(t.int64());break;case 2:i.dataType=t.int32();break;case 3:i.segment=o.onnx.TensorProto.Segment.decode(t,t.uint32());break;case 4:if(i.floatData&&i.floatData.length||(i.floatData=[]),(7&s)==2)for(f=t.uint32()+t.pos;t.pos<f;)i.floatData.push(t.float());else i.floatData.push(t.float());break;case 5:if(i.int32Data&&i.int32Data.length||(i.int32Data=[]),(7&s)==2)for(f=t.uint32()+t.pos;t.pos<f;)i.int32Data.push(t.int32());else i.int32Data.push(t.int32());break;case 6:i.stringData&&i.stringData.length||(i.stringData=[]),i.stringData.push(t.bytes());break;case 7:if(i.int64Data&&i.int64Data.length||(i.int64Data=[]),(7&s)==2)for(f=t.uint32()+t.pos;t.pos<f;)i.int64Data.push(t.int64());else i.int64Data.push(t.int64());break;case 8:i.name=t.string();break;case 12:i.docString=t.string();break;case 9:i.rawData=t.bytes();break;case 13:i.externalData&&i.externalData.length||(i.externalData=[]),i.externalData.push(o.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 14:i.dataLocation=t.int32();break;case 10:if(i.doubleData&&i.doubleData.length||(i.doubleData=[]),(7&s)==2)for(f=t.uint32()+t.pos;t.pos<f;)i.doubleData.push(t.double());else i.doubleData.push(t.double());break;case 11:if(i.uint64Data&&i.uint64Data.length||(i.uint64Data=[]),(7&s)==2)for(f=t.uint32()+t.pos;t.pos<f;)i.uint64Data.push(t.uint64());else i.uint64Data.push(t.uint64());break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var e=0;e<t.dims.length;++e)if(!(a.isInteger(t.dims[e])||t.dims[e]&&a.isInteger(t.dims[e].low)&&a.isInteger(t.dims[e].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!a.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")&&(r=o.onnx.TensorProto.Segment.verify(t.segment)))return"segment."+r;if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(e=0;e<t.floatData.length;++e)if(typeof t.floatData[e]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(e=0;e<t.int32Data.length;++e)if(!a.isInteger(t.int32Data[e]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(e=0;e<t.stringData.length;++e)if(!(t.stringData[e]&&typeof t.stringData[e].length=="number"||a.isString(t.stringData[e])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(e=0;e<t.int64Data.length;++e)if(!(a.isInteger(t.int64Data[e])||t.int64Data[e]&&a.isInteger(t.int64Data[e].low)&&a.isInteger(t.int64Data[e].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||a.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(e=0;e<t.externalData.length;++e){var r;if(r=o.onnx.StringStringEntryProto.verify(t.externalData[e]))return"externalData."+r}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(e=0;e<t.doubleData.length;++e)if(typeof t.doubleData[e]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(e=0;e<t.uint64Data.length;++e)if(!(a.isInteger(t.uint64Data[e])||t.uint64Data[e]&&a.isInteger(t.uint64Data[e].low)&&a.isInteger(t.uint64Data[e].high)))return"uint64Data: integer|Long[] expected"}return null},n.fromObject=function(t){if(t instanceof o.onnx.TensorProto)return t;var e=new o.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");e.dims=[];for(var r=0;r<t.dims.length;++r)a.Long?(e.dims[r]=a.Long.fromValue(t.dims[r])).unsigned=!1:typeof t.dims[r]=="string"?e.dims[r]=parseInt(t.dims[r],10):typeof t.dims[r]=="number"?e.dims[r]=t.dims[r]:typeof t.dims[r]=="object"&&(e.dims[r]=new a.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber())}if(t.dataType!=null&&(e.dataType=0|t.dataType),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");e.segment=o.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(e.floatData=[],r=0;r<t.floatData.length;++r)e.floatData[r]=Number(t.floatData[r])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(e.int32Data=[],r=0;r<t.int32Data.length;++r)e.int32Data[r]=0|t.int32Data[r]}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(e.stringData=[],r=0;r<t.stringData.length;++r)typeof t.stringData[r]=="string"?a.base64.decode(t.stringData[r],e.stringData[r]=a.newBuffer(a.base64.length(t.stringData[r])),0):t.stringData[r].length>=0&&(e.stringData[r]=t.stringData[r])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(e.int64Data=[],r=0;r<t.int64Data.length;++r)a.Long?(e.int64Data[r]=a.Long.fromValue(t.int64Data[r])).unsigned=!1:typeof t.int64Data[r]=="string"?e.int64Data[r]=parseInt(t.int64Data[r],10):typeof t.int64Data[r]=="number"?e.int64Data[r]=t.int64Data[r]:typeof t.int64Data[r]=="object"&&(e.int64Data[r]=new a.LongBits(t.int64Data[r].low>>>0,t.int64Data[r].high>>>0).toNumber())}if(t.name!=null&&(e.name=String(t.name)),t.docString!=null&&(e.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?a.base64.decode(t.rawData,e.rawData=a.newBuffer(a.base64.length(t.rawData)),0):t.rawData.length>=0&&(e.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(e.externalData=[],r=0;r<t.externalData.length;++r){if(typeof t.externalData[r]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");e.externalData[r]=o.onnx.StringStringEntryProto.fromObject(t.externalData[r])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){e.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:e.dataLocation=0;break;case"EXTERNAL":case 1:e.dataLocation=1}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(e.doubleData=[],r=0;r<t.doubleData.length;++r)e.doubleData[r]=Number(t.doubleData[r])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(e.uint64Data=[],r=0;r<t.uint64Data.length;++r)a.Long?(e.uint64Data[r]=a.Long.fromValue(t.uint64Data[r])).unsigned=!0:typeof t.uint64Data[r]=="string"?e.uint64Data[r]=parseInt(t.uint64Data[r],10):typeof t.uint64Data[r]=="number"?e.uint64Data[r]=t.uint64Data[r]:typeof t.uint64Data[r]=="object"&&(e.uint64Data[r]=new a.LongBits(t.uint64Data[r].low>>>0,t.uint64Data[r].high>>>0).toNumber(!0))}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.dims=[],r.floatData=[],r.int32Data=[],r.stringData=[],r.int64Data=[],r.doubleData=[],r.uint64Data=[],r.externalData=[]),e.defaults&&(r.dataType=0,r.segment=null,r.name="",e.bytes===String?r.rawData="":(r.rawData=[],e.bytes!==Array&&(r.rawData=a.newBuffer(r.rawData))),r.docString="",r.dataLocation=e.enums===String?"DEFAULT":0),t.dims&&t.dims.length){r.dims=[];for(var i=0;i<t.dims.length;++i)typeof t.dims[i]=="number"?r.dims[i]=e.longs===String?String(t.dims[i]):t.dims[i]:r.dims[i]=e.longs===String?a.Long.prototype.toString.call(t.dims[i]):e.longs===Number?new a.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber():t.dims[i]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(r.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(r.segment=o.onnx.TensorProto.Segment.toObject(t.segment,e)),t.floatData&&t.floatData.length)for(r.floatData=[],i=0;i<t.floatData.length;++i)r.floatData[i]=e.json&&!isFinite(t.floatData[i])?String(t.floatData[i]):t.floatData[i];if(t.int32Data&&t.int32Data.length)for(r.int32Data=[],i=0;i<t.int32Data.length;++i)r.int32Data[i]=t.int32Data[i];if(t.stringData&&t.stringData.length)for(r.stringData=[],i=0;i<t.stringData.length;++i)r.stringData[i]=e.bytes===String?a.base64.encode(t.stringData[i],0,t.stringData[i].length):e.bytes===Array?Array.prototype.slice.call(t.stringData[i]):t.stringData[i];if(t.int64Data&&t.int64Data.length)for(r.int64Data=[],i=0;i<t.int64Data.length;++i)typeof t.int64Data[i]=="number"?r.int64Data[i]=e.longs===String?String(t.int64Data[i]):t.int64Data[i]:r.int64Data[i]=e.longs===String?a.Long.prototype.toString.call(t.int64Data[i]):e.longs===Number?new a.LongBits(t.int64Data[i].low>>>0,t.int64Data[i].high>>>0).toNumber():t.int64Data[i];if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(r.rawData=e.bytes===String?a.base64.encode(t.rawData,0,t.rawData.length):e.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length)for(r.doubleData=[],i=0;i<t.doubleData.length;++i)r.doubleData[i]=e.json&&!isFinite(t.doubleData[i])?String(t.doubleData[i]):t.doubleData[i];if(t.uint64Data&&t.uint64Data.length)for(r.uint64Data=[],i=0;i<t.uint64Data.length;++i)typeof t.uint64Data[i]=="number"?r.uint64Data[i]=e.longs===String?String(t.uint64Data[i]):t.uint64Data[i]:r.uint64Data[i]=e.longs===String?a.Long.prototype.toString.call(t.uint64Data[i]):e.longs===Number?new a.LongBits(t.uint64Data[i].low>>>0,t.uint64Data[i].high>>>0).toNumber(!0):t.uint64Data[i];if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.externalData&&t.externalData.length)for(r.externalData=[],i=0;i<t.externalData.length;++i)r.externalData[i]=o.onnx.StringStringEntryProto.toObject(t.externalData[i],e);return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(r.dataLocation=e.enums===String?o.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:o.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},n.DataType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="UINT8"]=2,e[t[3]="INT8"]=3,e[t[4]="UINT16"]=4,e[t[5]="INT16"]=5,e[t[6]="INT32"]=6,e[t[7]="INT64"]=7,e[t[8]="STRING"]=8,e[t[9]="BOOL"]=9,e[t[10]="FLOAT16"]=10,e[t[11]="DOUBLE"]=11,e[t[12]="UINT32"]=12,e[t[13]="UINT64"]=13,e[t[14]="COMPLEX64"]=14,e[t[15]="COMPLEX128"]=15,e[t[16]="BFLOAT16"]=16,e[t[17]="FLOAT8E4M3FN"]=17,e[t[18]="FLOAT8E4M3FNUZ"]=18,e[t[19]="FLOAT8E5M2"]=19,e[t[20]="FLOAT8E5M2FNUZ"]=20,e}(),n.Segment=function(){function t(e){if(e)for(var r=Object.keys(e),i=0;i<r.length;++i)e[r[i]]!=null&&(this[r[i]]=e[r[i]])}return t.prototype.begin=a.Long?a.Long.fromBits(0,0,!1):0,t.prototype.end=a.Long?a.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(e,r){return r||(r=c.create()),e.begin!=null&&Object.hasOwnProperty.call(e,"begin")&&r.uint32(8).int64(e.begin),e.end!=null&&Object.hasOwnProperty.call(e,"end")&&r.uint32(16).int64(e.end),r},t.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},t.decode=function(e,r){e instanceof u||(e=u.create(e));for(var i=r===void 0?e.len:e.pos+r,s=new o.onnx.TensorProto.Segment;e.pos<i;){var f=e.uint32();switch(f>>>3){case 1:s.begin=e.int64();break;case 2:s.end=e.int64();break;default:e.skipType(7&f)}}return s},t.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},t.verify=function(e){return typeof e!="object"||e===null?"object expected":e.begin!=null&&e.hasOwnProperty("begin")&&!(a.isInteger(e.begin)||e.begin&&a.isInteger(e.begin.low)&&a.isInteger(e.begin.high))?"begin: integer|Long expected":e.end!=null&&e.hasOwnProperty("end")&&!(a.isInteger(e.end)||e.end&&a.isInteger(e.end.low)&&a.isInteger(e.end.high))?"end: integer|Long expected":null},t.fromObject=function(e){if(e instanceof o.onnx.TensorProto.Segment)return e;var r=new o.onnx.TensorProto.Segment;return e.begin!=null&&(a.Long?(r.begin=a.Long.fromValue(e.begin)).unsigned=!1:typeof e.begin=="string"?r.begin=parseInt(e.begin,10):typeof e.begin=="number"?r.begin=e.begin:typeof e.begin=="object"&&(r.begin=new a.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber())),e.end!=null&&(a.Long?(r.end=a.Long.fromValue(e.end)).unsigned=!1:typeof e.end=="string"?r.end=parseInt(e.end,10):typeof e.end=="number"?r.end=e.end:typeof e.end=="object"&&(r.end=new a.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber())),r},t.toObject=function(e,r){r||(r={});var i={};if(r.defaults){if(a.Long){var s=new a.Long(0,0,!1);i.begin=r.longs===String?s.toString():r.longs===Number?s.toNumber():s}else i.begin=r.longs===String?"0":0;a.Long?(s=new a.Long(0,0,!1),i.end=r.longs===String?s.toString():r.longs===Number?s.toNumber():s):i.end=r.longs===String?"0":0}return e.begin!=null&&e.hasOwnProperty("begin")&&(typeof e.begin=="number"?i.begin=r.longs===String?String(e.begin):e.begin:i.begin=r.longs===String?a.Long.prototype.toString.call(e.begin):r.longs===Number?new a.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber():e.begin),e.end!=null&&e.hasOwnProperty("end")&&(typeof e.end=="number"?i.end=r.longs===String?String(e.end):e.end:i.end=r.longs===String?a.Long.prototype.toString.call(e.end):r.longs===Number?new a.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber():e.end),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},t.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorProto.Segment"},t}(),n.DataLocation=function(){var t={},e=Object.create(t);return e[t[0]="DEFAULT"]=0,e[t[1]="EXTERNAL"]=1,e}(),n}(),h.SparseTensorProto=function(){function n(t){if(this.dims=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.values=null,n.prototype.indices=null,n.prototype.dims=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&o.onnx.TensorProto.encode(t.values,e.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&o.onnx.TensorProto.encode(t.indices,e.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){e.uint32(26).fork();for(var r=0;r<t.dims.length;++r)e.int64(t.dims[r]);e.ldelim()}return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.SparseTensorProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.values=o.onnx.TensorProto.decode(t,t.uint32());break;case 2:i.indices=o.onnx.TensorProto.decode(t,t.uint32());break;case 3:if(i.dims&&i.dims.length||(i.dims=[]),(7&s)==2)for(var f=t.uint32()+t.pos;t.pos<f;)i.dims.push(t.int64());else i.dims.push(t.int64());break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";var e;if(t.values!=null&&t.hasOwnProperty("values")&&(e=o.onnx.TensorProto.verify(t.values)))return"values."+e;if(t.indices!=null&&t.hasOwnProperty("indices")&&(e=o.onnx.TensorProto.verify(t.indices)))return"indices."+e;if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var r=0;r<t.dims.length;++r)if(!(a.isInteger(t.dims[r])||t.dims[r]&&a.isInteger(t.dims[r].low)&&a.isInteger(t.dims[r].high)))return"dims: integer|Long[] expected"}return null},n.fromObject=function(t){if(t instanceof o.onnx.SparseTensorProto)return t;var e=new o.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");e.values=o.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");e.indices=o.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");e.dims=[];for(var r=0;r<t.dims.length;++r)a.Long?(e.dims[r]=a.Long.fromValue(t.dims[r])).unsigned=!1:typeof t.dims[r]=="string"?e.dims[r]=parseInt(t.dims[r],10):typeof t.dims[r]=="number"?e.dims[r]=t.dims[r]:typeof t.dims[r]=="object"&&(e.dims[r]=new a.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber())}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.dims=[]),e.defaults&&(r.values=null,r.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(r.values=o.onnx.TensorProto.toObject(t.values,e)),t.indices!=null&&t.hasOwnProperty("indices")&&(r.indices=o.onnx.TensorProto.toObject(t.indices,e)),t.dims&&t.dims.length){r.dims=[];for(var i=0;i<t.dims.length;++i)typeof t.dims[i]=="number"?r.dims[i]=e.longs===String?String(t.dims[i]):t.dims[i]:r.dims[i]=e.longs===String?a.Long.prototype.toString.call(t.dims[i]):e.longs===Number?new a.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber():t.dims[i]}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},n}(),h.TensorShapeProto=function(){function n(t){if(this.dim=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.dim=a.emptyArray,n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.dim!=null&&t.dim.length)for(var r=0;r<t.dim.length;++r)o.onnx.TensorShapeProto.Dimension.encode(t.dim[r],e.uint32(10).fork()).ldelim();return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.TensorShapeProto;t.pos<r;){var s=t.uint32();s>>>3==1?(i.dim&&i.dim.length||(i.dim=[]),i.dim.push(o.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()))):t.skipType(7&s)}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var e=0;e<t.dim.length;++e){var r=o.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);if(r)return"dim."+r}}return null},n.fromObject=function(t){if(t instanceof o.onnx.TensorShapeProto)return t;var e=new o.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");e.dim=[];for(var r=0;r<t.dim.length;++r){if(typeof t.dim[r]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");e.dim[r]=o.onnx.TensorShapeProto.Dimension.fromObject(t.dim[r])}}return e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.dim=[]),t.dim&&t.dim.length){r.dim=[];for(var i=0;i<t.dim.length;++i)r.dim[i]=o.onnx.TensorShapeProto.Dimension.toObject(t.dim[i],e)}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},n.Dimension=function(){function t(r){if(r)for(var i=Object.keys(r),s=0;s<i.length;++s)r[i[s]]!=null&&(this[i[s]]=r[i[s]])}var e;return t.prototype.dimValue=null,t.prototype.dimParam=null,t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:a.oneOfGetter(e=["dimValue","dimParam"]),set:a.oneOfSetter(e)}),t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=c.create()),r.dimValue!=null&&Object.hasOwnProperty.call(r,"dimValue")&&i.uint32(8).int64(r.dimValue),r.dimParam!=null&&Object.hasOwnProperty.call(r,"dimParam")&&i.uint32(18).string(r.dimParam),r.denotation!=null&&Object.hasOwnProperty.call(r,"denotation")&&i.uint32(26).string(r.denotation),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var s=i===void 0?r.len:r.pos+i,f=new o.onnx.TensorShapeProto.Dimension;r.pos<s;){var g=r.uint32();switch(g>>>3){case 1:f.dimValue=r.int64();break;case 2:f.dimParam=r.string();break;case 3:f.denotation=r.string();break;default:r.skipType(7&g)}}return f},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";var i={};if(r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(i.value=1,!(a.isInteger(r.dimValue)||r.dimValue&&a.isInteger(r.dimValue.low)&&a.isInteger(r.dimValue.high))))return"dimValue: integer|Long expected";if(r.dimParam!=null&&r.hasOwnProperty("dimParam")){if(i.value===1)return"value: multiple values";if(i.value=1,!a.isString(r.dimParam))return"dimParam: string expected"}return r.denotation!=null&&r.hasOwnProperty("denotation")&&!a.isString(r.denotation)?"denotation: string expected":null},t.fromObject=function(r){if(r instanceof o.onnx.TensorShapeProto.Dimension)return r;var i=new o.onnx.TensorShapeProto.Dimension;return r.dimValue!=null&&(a.Long?(i.dimValue=a.Long.fromValue(r.dimValue)).unsigned=!1:typeof r.dimValue=="string"?i.dimValue=parseInt(r.dimValue,10):typeof r.dimValue=="number"?i.dimValue=r.dimValue:typeof r.dimValue=="object"&&(i.dimValue=new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber())),r.dimParam!=null&&(i.dimParam=String(r.dimParam)),r.denotation!=null&&(i.denotation=String(r.denotation)),i},t.toObject=function(r,i){i||(i={});var s={};return i.defaults&&(s.denotation=""),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(typeof r.dimValue=="number"?s.dimValue=i.longs===String?String(r.dimValue):r.dimValue:s.dimValue=i.longs===String?a.Long.prototype.toString.call(r.dimValue):i.longs===Number?new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber():r.dimValue,i.oneofs&&(s.value="dimValue")),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&(s.dimParam=r.dimParam,i.oneofs&&(s.value="dimParam")),r.denotation!=null&&r.hasOwnProperty("denotation")&&(s.denotation=r.denotation),s},t.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TensorShapeProto.Dimension"},t}(),n}(),h.TypeProto=function(){function n(e){if(e)for(var r=Object.keys(e),i=0;i<r.length;++i)e[r[i]]!=null&&(this[r[i]]=e[r[i]])}var t;return n.prototype.tensorType=null,n.prototype.sequenceType=null,n.prototype.mapType=null,n.prototype.optionalType=null,n.prototype.sparseTensorType=null,n.prototype.denotation="",Object.defineProperty(n.prototype,"value",{get:a.oneOfGetter(t=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:a.oneOfSetter(t)}),n.create=function(e){return new n(e)},n.encode=function(e,r){return r||(r=c.create()),e.tensorType!=null&&Object.hasOwnProperty.call(e,"tensorType")&&o.onnx.TypeProto.Tensor.encode(e.tensorType,r.uint32(10).fork()).ldelim(),e.sequenceType!=null&&Object.hasOwnProperty.call(e,"sequenceType")&&o.onnx.TypeProto.Sequence.encode(e.sequenceType,r.uint32(34).fork()).ldelim(),e.mapType!=null&&Object.hasOwnProperty.call(e,"mapType")&&o.onnx.TypeProto.Map.encode(e.mapType,r.uint32(42).fork()).ldelim(),e.denotation!=null&&Object.hasOwnProperty.call(e,"denotation")&&r.uint32(50).string(e.denotation),e.sparseTensorType!=null&&Object.hasOwnProperty.call(e,"sparseTensorType")&&o.onnx.TypeProto.SparseTensor.encode(e.sparseTensorType,r.uint32(66).fork()).ldelim(),e.optionalType!=null&&Object.hasOwnProperty.call(e,"optionalType")&&o.onnx.TypeProto.Optional.encode(e.optionalType,r.uint32(74).fork()).ldelim(),r},n.encodeDelimited=function(e,r){return this.encode(e,r).ldelim()},n.decode=function(e,r){e instanceof u||(e=u.create(e));for(var i=r===void 0?e.len:e.pos+r,s=new o.onnx.TypeProto;e.pos<i;){var f=e.uint32();switch(f>>>3){case 1:s.tensorType=o.onnx.TypeProto.Tensor.decode(e,e.uint32());break;case 4:s.sequenceType=o.onnx.TypeProto.Sequence.decode(e,e.uint32());break;case 5:s.mapType=o.onnx.TypeProto.Map.decode(e,e.uint32());break;case 9:s.optionalType=o.onnx.TypeProto.Optional.decode(e,e.uint32());break;case 8:s.sparseTensorType=o.onnx.TypeProto.SparseTensor.decode(e,e.uint32());break;case 6:s.denotation=e.string();break;default:e.skipType(7&f)}}return s},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";var r={};if(e.tensorType!=null&&e.hasOwnProperty("tensorType")&&(r.value=1,i=o.onnx.TypeProto.Tensor.verify(e.tensorType)))return"tensorType."+i;if(e.sequenceType!=null&&e.hasOwnProperty("sequenceType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Sequence.verify(e.sequenceType))return"sequenceType."+i}if(e.mapType!=null&&e.hasOwnProperty("mapType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Map.verify(e.mapType))return"mapType."+i}if(e.optionalType!=null&&e.hasOwnProperty("optionalType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Optional.verify(e.optionalType))return"optionalType."+i}if(e.sparseTensorType!=null&&e.hasOwnProperty("sparseTensorType")){if(r.value===1)return"value: multiple values";var i;if(r.value=1,i=o.onnx.TypeProto.SparseTensor.verify(e.sparseTensorType))return"sparseTensorType."+i}return e.denotation!=null&&e.hasOwnProperty("denotation")&&!a.isString(e.denotation)?"denotation: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.TypeProto)return e;var r=new o.onnx.TypeProto;if(e.tensorType!=null){if(typeof e.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");r.tensorType=o.onnx.TypeProto.Tensor.fromObject(e.tensorType)}if(e.sequenceType!=null){if(typeof e.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");r.sequenceType=o.onnx.TypeProto.Sequence.fromObject(e.sequenceType)}if(e.mapType!=null){if(typeof e.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");r.mapType=o.onnx.TypeProto.Map.fromObject(e.mapType)}if(e.optionalType!=null){if(typeof e.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");r.optionalType=o.onnx.TypeProto.Optional.fromObject(e.optionalType)}if(e.sparseTensorType!=null){if(typeof e.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");r.sparseTensorType=o.onnx.TypeProto.SparseTensor.fromObject(e.sparseTensorType)}return e.denotation!=null&&(r.denotation=String(e.denotation)),r},n.toObject=function(e,r){r||(r={});var i={};return r.defaults&&(i.denotation=""),e.tensorType!=null&&e.hasOwnProperty("tensorType")&&(i.tensorType=o.onnx.TypeProto.Tensor.toObject(e.tensorType,r),r.oneofs&&(i.value="tensorType")),e.sequenceType!=null&&e.hasOwnProperty("sequenceType")&&(i.sequenceType=o.onnx.TypeProto.Sequence.toObject(e.sequenceType,r),r.oneofs&&(i.value="sequenceType")),e.mapType!=null&&e.hasOwnProperty("mapType")&&(i.mapType=o.onnx.TypeProto.Map.toObject(e.mapType,r),r.oneofs&&(i.value="mapType")),e.denotation!=null&&e.hasOwnProperty("denotation")&&(i.denotation=e.denotation),e.sparseTensorType!=null&&e.hasOwnProperty("sparseTensorType")&&(i.sparseTensorType=o.onnx.TypeProto.SparseTensor.toObject(e.sparseTensorType,r),r.oneofs&&(i.value="sparseTensorType")),e.optionalType!=null&&e.hasOwnProperty("optionalType")&&(i.optionalType=o.onnx.TypeProto.Optional.toObject(e.optionalType,r),r.oneofs&&(i.value="optionalType")),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TypeProto"},n.Tensor=function(){function e(r){if(r)for(var i=Object.keys(r),s=0;s<i.length;++s)r[i[s]]!=null&&(this[i[s]]=r[i[s]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=c.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&i.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&o.onnx.TensorShapeProto.encode(r.shape,i.uint32(18).fork()).ldelim(),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof u||(r=u.create(r));for(var s=i===void 0?r.len:r.pos+i,f=new o.onnx.TypeProto.Tensor;r.pos<s;){var g=r.uint32();switch(g>>>3){case 1:f.elemType=r.int32();break;case 2:f.shape=o.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return f},e.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var i=o.onnx.TensorShapeProto.verify(r.shape);if(i)return"shape."+i}return null},e.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Tensor)return r;var i=new o.onnx.TypeProto.Tensor;if(r.elemType!=null&&(i.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");i.shape=o.onnx.TensorShapeProto.fromObject(r.shape)}return i},e.toObject=function(r,i){i||(i={});var s={};return i.defaults&&(s.elemType=0,s.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(s.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(s.shape=o.onnx.TensorShapeProto.toObject(r.shape,i)),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Tensor"},e}(),n.Sequence=function(){function e(r){if(r)for(var i=Object.keys(r),s=0;s<i.length;++s)r[i[s]]!=null&&(this[i[s]]=r[i[s]])}return e.prototype.elemType=null,e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=c.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&o.onnx.TypeProto.encode(r.elemType,i.uint32(10).fork()).ldelim(),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof u||(r=u.create(r));for(var s=i===void 0?r.len:r.pos+i,f=new o.onnx.TypeProto.Sequence;r.pos<s;){var g=r.uint32();g>>>3==1?f.elemType=o.onnx.TypeProto.decode(r,r.uint32()):r.skipType(7&g)}return f},e.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var i=o.onnx.TypeProto.verify(r.elemType);if(i)return"elemType."+i}return null},e.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Sequence)return r;var i=new o.onnx.TypeProto.Sequence;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");i.elemType=o.onnx.TypeProto.fromObject(r.elemType)}return i},e.toObject=function(r,i){i||(i={});var s={};return i.defaults&&(s.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(s.elemType=o.onnx.TypeProto.toObject(r.elemType,i)),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Sequence"},e}(),n.Map=function(){function e(r){if(r)for(var i=Object.keys(r),s=0;s<i.length;++s)r[i[s]]!=null&&(this[i[s]]=r[i[s]])}return e.prototype.keyType=0,e.prototype.valueType=null,e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=c.create()),r.keyType!=null&&Object.hasOwnProperty.call(r,"keyType")&&i.uint32(8).int32(r.keyType),r.valueType!=null&&Object.hasOwnProperty.call(r,"valueType")&&o.onnx.TypeProto.encode(r.valueType,i.uint32(18).fork()).ldelim(),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof u||(r=u.create(r));for(var s=i===void 0?r.len:r.pos+i,f=new o.onnx.TypeProto.Map;r.pos<s;){var g=r.uint32();switch(g>>>3){case 1:f.keyType=r.int32();break;case 2:f.valueType=o.onnx.TypeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return f},e.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.keyType!=null&&r.hasOwnProperty("keyType")&&!a.isInteger(r.keyType))return"keyType: integer expected";if(r.valueType!=null&&r.hasOwnProperty("valueType")){var i=o.onnx.TypeProto.verify(r.valueType);if(i)return"valueType."+i}return null},e.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Map)return r;var i=new o.onnx.TypeProto.Map;if(r.keyType!=null&&(i.keyType=0|r.keyType),r.valueType!=null){if(typeof r.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");i.valueType=o.onnx.TypeProto.fromObject(r.valueType)}return i},e.toObject=function(r,i){i||(i={});var s={};return i.defaults&&(s.keyType=0,s.valueType=null),r.keyType!=null&&r.hasOwnProperty("keyType")&&(s.keyType=r.keyType),r.valueType!=null&&r.hasOwnProperty("valueType")&&(s.valueType=o.onnx.TypeProto.toObject(r.valueType,i)),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Map"},e}(),n.Optional=function(){function e(r){if(r)for(var i=Object.keys(r),s=0;s<i.length;++s)r[i[s]]!=null&&(this[i[s]]=r[i[s]])}return e.prototype.elemType=null,e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=c.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&o.onnx.TypeProto.encode(r.elemType,i.uint32(10).fork()).ldelim(),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof u||(r=u.create(r));for(var s=i===void 0?r.len:r.pos+i,f=new o.onnx.TypeProto.Optional;r.pos<s;){var g=r.uint32();g>>>3==1?f.elemType=o.onnx.TypeProto.decode(r,r.uint32()):r.skipType(7&g)}return f},e.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var i=o.onnx.TypeProto.verify(r.elemType);if(i)return"elemType."+i}return null},e.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Optional)return r;var i=new o.onnx.TypeProto.Optional;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");i.elemType=o.onnx.TypeProto.fromObject(r.elemType)}return i},e.toObject=function(r,i){i||(i={});var s={};return i.defaults&&(s.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(s.elemType=o.onnx.TypeProto.toObject(r.elemType,i)),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Optional"},e}(),n.SparseTensor=function(){function e(r){if(r)for(var i=Object.keys(r),s=0;s<i.length;++s)r[i[s]]!=null&&(this[i[s]]=r[i[s]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=c.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&i.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&o.onnx.TensorShapeProto.encode(r.shape,i.uint32(18).fork()).ldelim(),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof u||(r=u.create(r));for(var s=i===void 0?r.len:r.pos+i,f=new o.onnx.TypeProto.SparseTensor;r.pos<s;){var g=r.uint32();switch(g>>>3){case 1:f.elemType=r.int32();break;case 2:f.shape=o.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return f},e.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var i=o.onnx.TensorShapeProto.verify(r.shape);if(i)return"shape."+i}return null},e.fromObject=function(r){if(r instanceof o.onnx.TypeProto.SparseTensor)return r;var i=new o.onnx.TypeProto.SparseTensor;if(r.elemType!=null&&(i.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");i.shape=o.onnx.TensorShapeProto.fromObject(r.shape)}return i},e.toObject=function(r,i){i||(i={});var s={};return i.defaults&&(s.elemType=0,s.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(s.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(s.shape=o.onnx.TensorShapeProto.toObject(r.shape,i)),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.SparseTensor"},e}(),n}(),h.OperatorSetIdProto=function(){function n(t){if(t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.domain="",n.prototype.version=a.Long?a.Long.fromBits(0,0,!1):0,n.create=function(t){return new n(t)},n.encode=function(t,e){return e||(e=c.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&e.uint32(16).int64(t.version),e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.OperatorSetIdProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.domain=t.string();break;case 2:i.version=t.int64();break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!a.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!(a.isInteger(t.version)||t.version&&a.isInteger(t.version.low)&&a.isInteger(t.version.high))?"version: integer|Long expected":null},n.fromObject=function(t){if(t instanceof o.onnx.OperatorSetIdProto)return t;var e=new o.onnx.OperatorSetIdProto;return t.domain!=null&&(e.domain=String(t.domain)),t.version!=null&&(a.Long?(e.version=a.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?e.version=parseInt(t.version,10):typeof t.version=="number"?e.version=t.version:typeof t.version=="object"&&(e.version=new a.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),e},n.toObject=function(t,e){e||(e={});var r={};if(e.defaults)if(r.domain="",a.Long){var i=new a.Long(0,0,!1);r.version=e.longs===String?i.toString():e.longs===Number?i.toNumber():i}else r.version=e.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?r.version=e.longs===String?String(t.version):t.version:r.version=e.longs===String?a.Long.prototype.toString.call(t.version):e.longs===Number?new a.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},n}(),h.OperatorStatus=function(){var n={},t=Object.create(n);return t[n[0]="EXPERIMENTAL"]=0,t[n[1]="STABLE"]=1,t}(),h.FunctionProto=function(){function n(t){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.name="",n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.attribute=a.emptyArray,n.prototype.attributeProto=a.emptyArray,n.prototype.node=a.emptyArray,n.prototype.docString="",n.prototype.opsetImport=a.emptyArray,n.prototype.domain="",n.create=function(t){return new n(t)},n.encode=function(t,e){if(e||(e=c.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&e.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var r=0;r<t.input.length;++r)e.uint32(34).string(t.input[r]);if(t.output!=null&&t.output.length)for(r=0;r<t.output.length;++r)e.uint32(42).string(t.output[r]);if(t.attribute!=null&&t.attribute.length)for(r=0;r<t.attribute.length;++r)e.uint32(50).string(t.attribute[r]);if(t.node!=null&&t.node.length)for(r=0;r<t.node.length;++r)o.onnx.NodeProto.encode(t.node[r],e.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&e.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(r=0;r<t.opsetImport.length;++r)o.onnx.OperatorSetIdProto.encode(t.opsetImport[r],e.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&e.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(r=0;r<t.attributeProto.length;++r)o.onnx.AttributeProto.encode(t.attributeProto[r],e.uint32(90).fork()).ldelim();return e},n.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},n.decode=function(t,e){t instanceof u||(t=u.create(t));for(var r=e===void 0?t.len:t.pos+e,i=new o.onnx.FunctionProto;t.pos<r;){var s=t.uint32();switch(s>>>3){case 1:i.name=t.string();break;case 4:i.input&&i.input.length||(i.input=[]),i.input.push(t.string());break;case 5:i.output&&i.output.length||(i.output=[]),i.output.push(t.string());break;case 6:i.attribute&&i.attribute.length||(i.attribute=[]),i.attribute.push(t.string());break;case 11:i.attributeProto&&i.attributeProto.length||(i.attributeProto=[]),i.attributeProto.push(o.onnx.AttributeProto.decode(t,t.uint32()));break;case 7:i.node&&i.node.length||(i.node=[]),i.node.push(o.onnx.NodeProto.decode(t,t.uint32()));break;case 8:i.docString=t.string();break;case 9:i.opsetImport&&i.opsetImport.length||(i.opsetImport=[]),i.opsetImport.push(o.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 10:i.domain=t.string();break;default:t.skipType(7&s)}}return i},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var e=0;e<t.input.length;++e)if(!a.isString(t.input[e]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(!a.isString(t.output[e]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(e=0;e<t.attribute.length;++e)if(!a.isString(t.attribute[e]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(e=0;e<t.attributeProto.length;++e)if(r=o.onnx.AttributeProto.verify(t.attributeProto[e]))return"attributeProto."+r}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(e=0;e<t.node.length;++e)if(r=o.onnx.NodeProto.verify(t.node[e]))return"node."+r}if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(e=0;e<t.opsetImport.length;++e){var r;if(r=o.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return"opsetImport."+r}}return t.domain!=null&&t.hasOwnProperty("domain")&&!a.isString(t.domain)?"domain: string expected":null},n.fromObject=function(t){if(t instanceof o.onnx.FunctionProto)return t;var e=new o.onnx.FunctionProto;if(t.name!=null&&(e.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");e.input=[];for(var r=0;r<t.input.length;++r)e.input[r]=String(t.input[r])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");for(e.output=[],r=0;r<t.output.length;++r)e.output[r]=String(t.output[r])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");for(e.attribute=[],r=0;r<t.attribute.length;++r)e.attribute[r]=String(t.attribute[r])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");for(e.attributeProto=[],r=0;r<t.attributeProto.length;++r){if(typeof t.attributeProto[r]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");e.attributeProto[r]=o.onnx.AttributeProto.fromObject(t.attributeProto[r])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");for(e.node=[],r=0;r<t.node.length;++r){if(typeof t.node[r]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");e.node[r]=o.onnx.NodeProto.fromObject(t.node[r])}}if(t.docString!=null&&(e.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");for(e.opsetImport=[],r=0;r<t.opsetImport.length;++r){if(typeof t.opsetImport[r]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");e.opsetImport[r]=o.onnx.OperatorSetIdProto.fromObject(t.opsetImport[r])}}return t.domain!=null&&(e.domain=String(t.domain)),e},n.toObject=function(t,e){e||(e={});var r={};if((e.arrays||e.defaults)&&(r.input=[],r.output=[],r.attribute=[],r.node=[],r.opsetImport=[],r.attributeProto=[]),e.defaults&&(r.name="",r.docString="",r.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.input&&t.input.length){r.input=[];for(var i=0;i<t.input.length;++i)r.input[i]=t.input[i]}if(t.output&&t.output.length)for(r.output=[],i=0;i<t.output.length;++i)r.output[i]=t.output[i];if(t.attribute&&t.attribute.length)for(r.attribute=[],i=0;i<t.attribute.length;++i)r.attribute[i]=t.attribute[i];if(t.node&&t.node.length)for(r.node=[],i=0;i<t.node.length;++i)r.node[i]=o.onnx.NodeProto.toObject(t.node[i],e);if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.opsetImport&&t.opsetImport.length)for(r.opsetImport=[],i=0;i<t.opsetImport.length;++i)r.opsetImport[i]=o.onnx.OperatorSetIdProto.toObject(t.opsetImport[i],e);if(t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.attributeProto&&t.attributeProto.length)for(r.attributeProto=[],i=0;i<t.attributeProto.length;++i)r.attributeProto[i]=o.onnx.AttributeProto.toObject(t.attributeProto[i],e);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,d.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},n}(),h),R.exports=o},3474:(R,l,b)=>{var m,p=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(m=m||__filename),function(h={}){function d(){return q.buffer!=J.buffer&&gt(),J}function u(){return q.buffer!=J.buffer&&gt(),tt}function c(){return q.buffer!=J.buffer&&gt(),nt}function a(){return q.buffer!=J.buffer&&gt(),rt}function o(){return q.buffer!=J.buffer&&gt(),it}var n,t,e=h;e.ready=new Promise((_,P)=>{n=_,t=P});var r,i,s,f=Object.assign({},e),g="./this.program",y=(_,P)=>{throw P},v=typeof window=="object",w=typeof importScripts=="function",T=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=e.ENVIRONMENT_IS_PTHREAD||!1,A="";function D(_){return e.locateFile?e.locateFile(_,A):A+_}if(T){var $=b(1384),j=b(908);let _;A=w?j.dirname(A)+"/":__dirname+"/",r=(P,k)=>(P=P.startsWith("file://")?new URL(P):j.normalize(P),$.readFileSync(P,k?void 0:"utf8")),s=P=>((P=r(P,!0)).buffer||(P=new Uint8Array(P)),P),i=(P,k,N,B=!0)=>{P=P.startsWith("file://")?new URL(P):j.normalize(P),$.readFile(P,B?void 0:"utf8",(Y,Q)=>{Y?N(Y):k(B?Q.buffer:Q)})},!e.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),y=(P,k)=>{throw process.exitCode=P,k},e.inspect=()=>"[Emscripten Module object]";try{_=b(9925)}catch(P){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),P}commonjsGlobal.Worker=_.Worker}else(v||w)&&(w?A=self.location.href:typeof document<"u"&&document.currentScript&&(A=document.currentScript.src),m&&(A=m),A=A.indexOf("blob:")!==0?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",T||(r=_=>{var P=new XMLHttpRequest;return P.open("GET",_,!1),P.send(null),P.responseText},w&&(s=_=>{var P=new XMLHttpRequest;return P.open("GET",_,!1),P.responseType="arraybuffer",P.send(null),new Uint8Array(P.response)}),i=(_,P,k)=>{var N=new XMLHttpRequest;N.open("GET",_,!0),N.responseType="arraybuffer",N.onload=()=>{N.status==200||N.status==0&&N.response?P(N.response):k()},N.onerror=k,N.send(null)}));T&&typeof performance>"u"&&(commonjsGlobal.performance=b(6953).performance);var M=console.log.bind(console),S=console.error.bind(console);T&&(M=(..._)=>$.writeSync(1,_.join(" ")+`
`),S=(..._)=>$.writeSync(2,_.join(" ")+`
`));var U,O=e.print||M,E=e.printErr||S;Object.assign(e,f),f=null,e.thisProgram&&(g=e.thisProgram),e.quit&&(y=e.quit),e.wasmBinary&&(U=e.wasmBinary);var F=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Ot("no native wasm support detected");var q,H,K,X,J,tt,nt,rt,it,ut=!1;function gt(){var _=q.buffer;e.HEAP8=J=new Int8Array(_),e.HEAP16=new Int16Array(_),e.HEAP32=nt=new Int32Array(_),e.HEAPU8=tt=new Uint8Array(_),e.HEAPU16=new Uint16Array(_),e.HEAPU32=rt=new Uint32Array(_),e.HEAPF32=new Float32Array(_),e.HEAPF64=it=new Float64Array(_)}var xt=e.INITIAL_MEMORY||16777216;if(5242880<=xt||Ot("INITIAL_MEMORY should be larger than STACK_SIZE, was "+xt+"! (STACK_SIZE=5242880)"),x)q=e.wasmMemory;else if(e.wasmMemory)q=e.wasmMemory;else if(!((q=new WebAssembly.Memory({initial:xt/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw E("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),T&&E("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");gt(),xt=q.buffer.byteLength;var kt,mt=[],Dt=[],lt=[],bt=0;function St(){return F||0<bt}var _t,At,Et=0,Pt=null;function Ct(){Et++,e.monitorRunDependencies&&e.monitorRunDependencies(Et)}function Lt(){if(Et--,e.monitorRunDependencies&&e.monitorRunDependencies(Et),Et==0&&Pt){var _=Pt;Pt=null,_()}}function Ot(_){throw e.onAbort&&e.onAbort(_),E(_="Aborted("+_+")"),ut=!0,X=1,_=new WebAssembly.RuntimeError(_+". Build with -sASSERTIONS for more info."),t(_),_}function Ft(_){return _.startsWith("data:application/octet-stream;base64,")}function Gt(_){if(_==_t&&U)return new Uint8Array(U);if(s)return s(_);throw"both async and sync fetching of the wasm failed"}function Qt(_,P,k){return function(N){if(!U&&(v||w)){if(typeof fetch=="function"&&!N.startsWith("file://"))return fetch(N,{credentials:"same-origin"}).then(B=>{if(!B.ok)throw"failed to load wasm binary file at '"+N+"'";return B.arrayBuffer()}).catch(()=>Gt(N));if(i)return new Promise((B,Y)=>{i(N,Q=>B(new Uint8Array(Q)),Y)})}return Promise.resolve().then(()=>Gt(N))}(_).then(N=>WebAssembly.instantiate(N,P)).then(N=>N).then(k,N=>{E("failed to asynchronously prepare wasm: "+N),Ot(N)})}function jt(_){this.name="ExitStatus",this.message=`Program terminated with exit(${_})`,this.status=_}function Bt(_){_.terminate(),_.onmessage=()=>{}}function Ht(_){(_=et.Fa[_])||Ot(),et.fb(_)}function qt(_){var P=et.Za();if(!P)return 6;et.Ia.push(P),et.Fa[_.Ha]=P,P.Ha=_.Ha;var k={cmd:"run",start_routine:_.gb,arg:_.Ya,pthread_ptr:_.Ha};return T&&P.unref(),P.postMessage(k,_.mb),0}Ft(_t="ort-wasm-threaded.wasm")||(_t=D(_t));var te=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Wt=(_,P,k)=>{var N=(P>>>=0)+k;for(k=P;_[k]&&!(k>=N);)++k;if(16<k-P&&_.buffer&&te)return te.decode(_.buffer instanceof SharedArrayBuffer?_.slice(P,k):_.subarray(P,k));for(N="";P<k;){var B=_[P++];if(128&B){var Y=63&_[P++];if((224&B)==192)N+=String.fromCharCode((31&B)<<6|Y);else{var Q=63&_[P++];65536>(B=(240&B)==224?(15&B)<<12|Y<<6|Q:(7&B)<<18|Y<<12|Q<<6|63&_[P++])?N+=String.fromCharCode(B):(B-=65536,N+=String.fromCharCode(55296|B>>10,56320|1023&B))}}else N+=String.fromCharCode(B)}return N},Nt=(_,P)=>(_>>>=0)?Wt(u(),_,P):"";function Xt(_){if(x)return pt(1,1,_);X=_,St()||(et.hb(),e.onExit&&e.onExit(_),ut=!0),y(_,new jt(_))}var Vt=_=>{if(X=_,x)throw Yt(_),"unwind";Xt(_)},et={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){x?et.ab():et.$a()},$a:function(){mt.unshift(()=>{Ct(),et.bb(()=>Lt())})},ab:function(){et.receiveObjectTransfer=et.eb,et.threadInitTLS=et.Sa,et.setExitStatus=et.Ra,F=!1},Ra:function(_){X=_},rb:["$terminateWorker"],hb:function(){for(var _ of et.Ia)Bt(_);for(_ of et.La)Bt(_);et.La=[],et.Ia=[],et.Fa=[]},fb:function(_){var P=_.Ha;delete et.Fa[P],et.La.push(_),et.Ia.splice(et.Ia.indexOf(_),1),_.Ha=0,le(P)},eb:function(){},Sa:function(){et.Ta.forEach(_=>_())},cb:_=>new Promise(P=>{_.onmessage=B=>{var Y=(B=B.data).cmd;if(B.targetThread&&B.targetThread!=ne()){var Q=et.Fa[B.qb];Q?Q.postMessage(B,B.transferList):E('Internal error! Worker sent a message "'+Y+'" to target pthread '+B.targetThread+", but that thread no longer exists!")}else Y==="checkMailbox"?ee():Y==="spawnThread"?qt(B):Y==="cleanupThread"?Ht(B.thread):Y==="killThread"?(B=B.thread,Y=et.Fa[B],delete et.Fa[B],Bt(Y),le(B),et.Ia.splice(et.Ia.indexOf(Y),1),Y.Ha=0):Y==="cancelThread"?et.Fa[B.thread].postMessage({cmd:"cancel"}):Y==="loaded"?(_.loaded=!0,P(_)):Y==="alert"?alert("Thread "+B.threadId+": "+B.text):B.target==="setimmediate"?_.postMessage(B):Y==="callHandler"?e[B.handler](...B.args):Y&&E("worker sent an unknown command "+Y)},_.onerror=B=>{throw E("worker sent an error! "+B.filename+":"+B.lineno+": "+B.message),B},T&&(_.on("message",function(B){_.onmessage({data:B})}),_.on("error",function(B){_.onerror(B)}));var k,N=[];for(k of["onExit","onAbort","print","printErr"])e.hasOwnProperty(k)&&N.push(k);_.postMessage({cmd:"load",handlers:N,urlOrBlob:e.mainScriptUrlOrBlob||m,wasmMemory:q,wasmModule:K})}),bb:function(_){_()},Xa:function(){var _=D("ort-wasm-threaded.worker.js");_=new Worker(_),et.La.push(_)},Za:function(){return et.La.length==0&&(et.Xa(),et.cb(et.La[0])),et.La.pop()}};e.PThread=et;var Mt=_=>{for(;0<_.length;)_.shift()(e)};function Yt(_){if(x)return pt(2,0,_);Vt(_)}e.establishStackSpace=function(){var _=ne(),P=c()[_+52>>2>>>0];_=c()[_+56>>2>>>0],Ne(P,P-_),oe(P)};var I=[];function L(_){this.Oa=_-24,this.Wa=function(P){a()[this.Oa+4>>2>>>0]=P},this.Va=function(P){a()[this.Oa+8>>2>>>0]=P},this.Pa=function(P,k){this.Ua(),this.Wa(P),this.Va(k)},this.Ua=function(){a()[this.Oa+16>>2>>>0]=0}}function C(_,P,k,N){return x?pt(3,1,_,P,k,N):G(_,P,k,N)}function G(_,P,k,N){if(_>>>=0,P>>>=0,k>>>=0,N>>>=0,typeof SharedArrayBuffer>"u")return E("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var B=[];return x&&B.length===0?C(_,P,k,N):(_={gb:k,Ha:_,Ya:N,mb:B},x?(_.ob="spawnThread",postMessage(_,B),0):qt(_))}function W(_,P,k){return x?pt(4,1,_,P,k):0}function Z(_,P){if(x)return pt(5,1,_,P)}e.invokeEntryPoint=function(_,P){var k=I[_];k||(_>=I.length&&(I.length=_+1),I[_]=k=kt.get(_)),_=k(P),St()?et.Ra(_):ce(_)};var ot=_=>{for(var P=0,k=0;k<_.length;++k){var N=_.charCodeAt(k);127>=N?P++:2047>=N?P+=2:55296<=N&&57343>=N?(P+=4,++k):P+=3}return P},ht=(_,P,k,N)=>{if(!(0<N))return 0;var B=k>>>=0;N=k+N-1;for(var Y=0;Y<_.length;++Y){var Q=_.charCodeAt(Y);if(55296<=Q&&57343>=Q&&(Q=65536+((1023&Q)<<10)|1023&_.charCodeAt(++Y)),127>=Q){if(k>=N)break;P[k++>>>0]=Q}else{if(2047>=Q){if(k+1>=N)break;P[k++>>>0]=192|Q>>6}else{if(65535>=Q){if(k+2>=N)break;P[k++>>>0]=224|Q>>12}else{if(k+3>=N)break;P[k++>>>0]=240|Q>>18,P[k++>>>0]=128|Q>>12&63}P[k++>>>0]=128|Q>>6&63}P[k++>>>0]=128|63&Q}}return P[k>>>0]=0,k-B},yt=(_,P,k)=>ht(_,u(),P,k);function Tt(_,P){if(x)return pt(6,1,_,P)}function vt(_,P,k){if(x)return pt(7,1,_,P,k)}function Kt(_,P,k){return x?pt(8,1,_,P,k):0}function Jt(_,P){if(x)return pt(9,1,_,P)}function V(_,P,k){if(x)return pt(10,1,_,P,k)}function at(_,P,k,N){if(x)return pt(11,1,_,P,k,N)}function ct(_,P,k,N){if(x)return pt(12,1,_,P,k,N)}function Rt(_,P,k,N){if(x)return pt(13,1,_,P,k,N)}function Zt(_){if(x)return pt(14,1,_)}function fe(_,P){if(x)return pt(15,1,_,P)}function he(_,P,k){if(x)return pt(16,1,_,P,k)}var Be=_=>{if(!ut)try{if(_(),!St())try{x?ce(X):Vt(X)}catch(P){P instanceof jt||P=="unwind"||y(1,P)}}catch(P){P instanceof jt||P=="unwind"||y(1,P)}};function ie(_){_>>>=0,typeof Atomics.nb=="function"&&(Atomics.nb(c(),_>>2,_).value.then(ee),_+=128,Atomics.store(c(),_>>2,1))}function ee(){var _=ne();_&&(ie(_),Be(()=>Re()))}e.__emscripten_thread_mailbox_await=ie,e.checkMailbox=ee;var zt=_=>_%4==0&&(_%100!=0||_%400==0),ge=[0,31,60,91,121,152,182,213,244,274,305,335],me=[0,31,59,90,120,151,181,212,243,273,304,334];function be(_,P,k,N,B,Y,Q,dt){return x?pt(17,1,_,P,k,N,B,Y,Q,dt):-52}function ye(_,P,k,N,B,Y,Q){if(x)return pt(18,1,_,P,k,N,B,Y,Q)}var ve=_=>{var P=ot(_)+1,k=$e(P);return k&&yt(_,k,P),k},Ve=_=>{var P=pe();return _=_(),oe(P),_};function pt(_,P){var k=arguments.length-2,N=arguments;return Ve(()=>{for(var B=de(8*k),Y=B>>3,Q=0;Q<k;Q++){var dt=N[2+Q];o()[Y+Q>>>0]=dt}return Fe(_,k,B,P)})}var ae,se=[],ue={},we=()=>{if(!ae){var _,P={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(_ in ue)ue[_]===void 0?delete P[_]:P[_]=ue[_];var k=[];for(_ in P)k.push(`${_}=${P[_]}`);ae=k}return ae};function Te(_,P){if(x)return pt(19,1,_,P);_>>>=0,P>>>=0;var k=0;return we().forEach(function(N,B){var Y=P+k;for(B=a()[_+4*B>>2>>>0]=Y,Y=0;Y<N.length;++Y)d()[B++>>0>>>0]=N.charCodeAt(Y);d()[B>>0>>>0]=0,k+=N.length+1}),0}function xe(_,P){if(x)return pt(20,1,_,P);_>>>=0,P>>>=0;var k=we();a()[_>>2>>>0]=k.length;var N=0;return k.forEach(function(B){N+=B.length+1}),a()[P>>2>>>0]=N,0}function _e(_){return x?pt(21,1,_):52}function Oe(_,P,k,N){return x?pt(22,1,_,P,k,N):52}function Se(_,P,k,N,B){return x?pt(23,1,_,P,k,N,B):70}var ze=[null,[],[]];function Ae(_,P,k,N){if(x)return pt(24,1,_,P,k,N);P>>>=0,k>>>=0,N>>>=0;for(var B=0,Y=0;Y<k;Y++){var Q=a()[P>>2>>>0],dt=a()[P+4>>2>>>0];P+=8;for(var $t=0;$t<dt;$t++){var wt=u()[Q+$t>>>0],It=ze[_];wt===0||wt===10?((_===1?O:E)(Wt(It,0)),It.length=0):It.push(wt)}B+=dt}return a()[N>>2>>>0]=B,0}var Pe=_=>(Pe=(()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return N=>(N.set(crypto.getRandomValues(new Uint8Array(N.byteLength))),N);if(T)try{var P=b(760);if(P.randomFillSync)return N=>P.randomFillSync(N);var k=P.randomBytes;return N=>(N.set(k(N.byteLength)),N)}catch{}Ot("initRandomDevice")})())(_),Ie=[31,29,31,30,31,30,31,31,30,31,30,31],Ee=[31,28,31,30,31,30,31,31,30,31,30,31],Ge=(_,P)=>{d().set(_,P>>>0)};function De(_,P,k,N){function B(z,st,ft){for(z=typeof z=="number"?z.toString():z||"";z.length<st;)z=ft[0]+z;return z}function Y(z,st){return B(z,st,"0")}function Q(z,st){function ft(Ue){return 0>Ue?-1:0<Ue?1:0}var Ut;return(Ut=ft(z.getFullYear()-st.getFullYear()))===0&&(Ut=ft(z.getMonth()-st.getMonth()))===0&&(Ut=ft(z.getDate()-st.getDate())),Ut}function dt(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function $t(z){var st=z.Ja;for(z=new Date(new Date(z.Ka+1900,0,1).getTime());0<st;){var ft=z.getMonth(),Ut=(zt(z.getFullYear())?Ie:Ee)[ft];if(!(st>Ut-z.getDate())){z.setDate(z.getDate()+st);break}st-=Ut-z.getDate()+1,z.setDate(1),11>ft?z.setMonth(ft+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1))}return ft=new Date(z.getFullYear()+1,0,4),st=dt(new Date(z.getFullYear(),0,4)),ft=dt(ft),0>=Q(st,z)?0>=Q(ft,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}_>>>=0,P>>>=0,k>>>=0,N>>>=0;var wt=c()[N+40>>2>>>0];for(var It in N={kb:c()[N>>2>>>0],jb:c()[N+4>>2>>>0],Ma:c()[N+8>>2>>>0],Qa:c()[N+12>>2>>>0],Na:c()[N+16>>2>>>0],Ka:c()[N+20>>2>>>0],Ga:c()[N+24>>2>>>0],Ja:c()[N+28>>2>>>0],sb:c()[N+32>>2>>>0],ib:c()[N+36>>2>>>0],lb:wt?Nt(wt):""},k=Nt(k),wt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})k=k.replace(new RegExp(It,"g"),wt[It]);var je="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Me="January February March April May June July August September October November December".split(" ");for(It in wt={"%a":z=>je[z.Ga].substring(0,3),"%A":z=>je[z.Ga],"%b":z=>Me[z.Na].substring(0,3),"%B":z=>Me[z.Na],"%C":z=>Y((z.Ka+1900)/100|0,2),"%d":z=>Y(z.Qa,2),"%e":z=>B(z.Qa,2," "),"%g":z=>$t(z).toString().substring(2),"%G":z=>$t(z),"%H":z=>Y(z.Ma,2),"%I":z=>((z=z.Ma)==0?z=12:12<z&&(z-=12),Y(z,2)),"%j":z=>{for(var st=0,ft=0;ft<=z.Na-1;st+=(zt(z.Ka+1900)?Ie:Ee)[ft++]);return Y(z.Qa+st,3)},"%m":z=>Y(z.Na+1,2),"%M":z=>Y(z.jb,2),"%n":()=>`
`,"%p":z=>0<=z.Ma&&12>z.Ma?"AM":"PM","%S":z=>Y(z.kb,2),"%t":()=>"	","%u":z=>z.Ga||7,"%U":z=>Y(Math.floor((z.Ja+7-z.Ga)/7),2),"%V":z=>{var st=Math.floor((z.Ja+7-(z.Ga+6)%7)/7);if(2>=(z.Ga+371-z.Ja-2)%7&&st++,st)st==53&&((ft=(z.Ga+371-z.Ja)%7)==4||ft==3&&zt(z.Ka)||(st=1));else{st=52;var ft=(z.Ga+7-z.Ja-1)%7;(ft==4||ft==5&&zt(z.Ka%400-1))&&st++}return Y(st,2)},"%w":z=>z.Ga,"%W":z=>Y(Math.floor((z.Ja+7-(z.Ga+6)%7)/7),2),"%y":z=>(z.Ka+1900).toString().substring(2),"%Y":z=>z.Ka+1900,"%z":z=>{var st=0<=(z=z.ib);return z=Math.abs(z)/60,(st?"+":"-")+("0000"+(z/60*100+z%60)).slice(-4)},"%Z":z=>z.lb,"%%":()=>"%"},k=k.replace(/%%/g,"\0\0"),wt)k.includes(It)&&(k=k.replace(new RegExp(It,"g"),wt[It](N)));return It=function(z){var st=Array(ot(z)+1);return ht(z,st,0,st.length),st}(k=k.replace(/\0\0/g,"%")),It.length>P?0:(Ge(It,_),It.length-1)}et.Pa();var He=[null,Xt,Yt,C,W,Z,Tt,vt,Kt,Jt,V,at,ct,Rt,Zt,fe,he,be,ye,Te,xe,_e,Oe,Se,Ae],qe={b:function(_,P,k){throw new L(_>>>=0).Pa(P>>>0,k>>>0),_},N:function(_){ke(_>>>0,!w,1,!v,131072,!1),et.Sa()},k:function(_){_>>>=0,x?postMessage({cmd:"cleanupThread",thread:_}):Ht(_)},I:G,h:W,T:Z,E:Tt,G:vt,U:Kt,R:Jt,J:V,Q:at,o:ct,F:Rt,C:Zt,S:fe,D:he,q:()=>!0,A:function(_,P){(_>>>=0)==P>>>0?setTimeout(()=>ee()):x?postMessage({targetThread:_,cmd:"checkMailbox"}):(_=et.Fa[_])&&_.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:ie,p:function(_){T&&et.Fa[_>>>0].ref()},t:function(_,P,k){_=P+2097152>>>0<4194305-!!_?(_>>>0)+4294967296*P:NaN,k>>>=0,_=new Date(1e3*_),c()[k>>2>>>0]=_.getUTCSeconds(),c()[k+4>>2>>>0]=_.getUTCMinutes(),c()[k+8>>2>>>0]=_.getUTCHours(),c()[k+12>>2>>>0]=_.getUTCDate(),c()[k+16>>2>>>0]=_.getUTCMonth(),c()[k+20>>2>>>0]=_.getUTCFullYear()-1900,c()[k+24>>2>>>0]=_.getUTCDay(),_=(_.getTime()-Date.UTC(_.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,c()[k+28>>2>>>0]=_},u:function(_,P,k){_=P+2097152>>>0<4194305-!!_?(_>>>0)+4294967296*P:NaN,k>>>=0,_=new Date(1e3*_),c()[k>>2>>>0]=_.getSeconds(),c()[k+4>>2>>>0]=_.getMinutes(),c()[k+8>>2>>>0]=_.getHours(),c()[k+12>>2>>>0]=_.getDate(),c()[k+16>>2>>>0]=_.getMonth(),c()[k+20>>2>>>0]=_.getFullYear()-1900,c()[k+24>>2>>>0]=_.getDay(),P=(zt(_.getFullYear())?ge:me)[_.getMonth()]+_.getDate()-1|0,c()[k+28>>2>>>0]=P,c()[k+36>>2>>>0]=-60*_.getTimezoneOffset(),P=new Date(_.getFullYear(),6,1).getTimezoneOffset();var N=new Date(_.getFullYear(),0,1).getTimezoneOffset();_=0|(P!=N&&_.getTimezoneOffset()==Math.min(N,P)),c()[k+32>>2>>>0]=_},v:function(_){_>>>=0;var P=new Date(c()[_+20>>2>>>0]+1900,c()[_+16>>2>>>0],c()[_+12>>2>>>0],c()[_+8>>2>>>0],c()[_+4>>2>>>0],c()[_>>2>>>0],0),k=c()[_+32>>2>>>0],N=P.getTimezoneOffset(),B=new Date(P.getFullYear(),6,1).getTimezoneOffset(),Y=new Date(P.getFullYear(),0,1).getTimezoneOffset(),Q=Math.min(Y,B);return 0>k?c()[_+32>>2>>>0]=+(B!=Y&&Q==N):0<k!=(Q==N)&&(B=Math.max(Y,B),P.setTime(P.getTime()+6e4*((0<k?Q:B)-N))),c()[_+24>>2>>>0]=P.getDay(),k=(zt(P.getFullYear())?ge:me)[P.getMonth()]+P.getDate()-1|0,c()[_+28>>2>>>0]=k,c()[_>>2>>>0]=P.getSeconds(),c()[_+4>>2>>>0]=P.getMinutes(),c()[_+8>>2>>>0]=P.getHours(),c()[_+12>>2>>>0]=P.getDate(),c()[_+16>>2>>>0]=P.getMonth(),c()[_+20>>2>>>0]=P.getYear(),_=P.getTime()/1e3,Le((At=_,1<=+Math.abs(At)?0<At?+Math.floor(At/4294967296)>>>0:~~+Math.ceil((At-+(~~At>>>0))/4294967296)>>>0:0)),_>>>0},r:be,s:ye,z:function(_,P,k){function N(wt){return(wt=wt.toTimeString().match(/\(([A-Za-z ]+)\)$/))?wt[1]:"GMT"}_>>>=0,P>>>=0,k>>>=0;var B=new Date().getFullYear(),Y=new Date(B,0,1),Q=new Date(B,6,1);B=Y.getTimezoneOffset();var dt=Q.getTimezoneOffset(),$t=Math.max(B,dt);a()[_>>2>>>0]=60*$t,c()[P>>2>>>0]=+(B!=dt),_=N(Y),P=N(Q),_=ve(_),P=ve(P),dt<B?(a()[k>>2>>>0]=_,a()[k+4>>2>>>0]=P):(a()[k>>2>>>0]=P,a()[k+4>>2>>>0]=_)},c:()=>{Ot("")},l:function(){},i:function(){return Date.now()},V:()=>{throw bt+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return T?b(3993).cpus().length:navigator.hardwareConcurrency},K:function(_,P,k,N){for(et.pb=P>>>0,se.length=k,P=N>>>0>>3,N=0;N<k;N++)se[N]=o()[P+N>>>0];return He[_].apply(null,se)},y:function(_){_>>>=0;var P=u().length;if(_<=P||4294901760<_)return!1;for(var k=1;4>=k;k*=2){var N=P*(1+.2/k);N=Math.min(N,_+100663296);var B=Math;N=Math.max(_,N);t:{B=B.min.call(B,4294901760,N+(65536-N%65536)%65536)-q.buffer.byteLength+65535>>>16;try{q.grow(B),gt();var Y=1;break t}catch{}Y=void 0}if(Y)return!0}return!1},O:Te,P:xe,j:Vt,g:_e,n:Oe,w:Se,m:Ae,x:function(_,P){return _>>>=0,P>>>=0,Pe(u().subarray(_>>>0,_+P>>>0)),0},a:q||e.wasmMemory,H:De,d:function(_,P,k,N){return De(_>>>0,P>>>0,k>>>0,N>>>0)}};(function(){function _(k,N){return k=k.exports,H=k=function(B){var Y=dt=>()=>dt()>>>0,Q=dt=>$t=>dt($t)>>>0;return(B=Object.assign({},B)).__errno_location=Y(B.__errno_location),B.pthread_self=Y(B.pthread_self),B.malloc=Q(B.malloc),B.stackSave=Y(B.stackSave),B.stackAlloc=Q(B.stackAlloc),B}(k),et.Ta.push(H.sa),kt=H.ta,Dt.unshift(H.W),K=N,Lt(),k}var P={a:qe};if(Ct(),e.instantiateWasm)try{return e.instantiateWasm(P,_)}catch(k){E("Module.instantiateWasm callback failed with error: "+k),t(k)}(function(k,N){var B=_t;return U||typeof WebAssembly.instantiateStreaming!="function"||Ft(B)||B.startsWith("file://")||T||typeof fetch!="function"?Qt(B,k,N):fetch(B,{credentials:"same-origin"}).then(Y=>WebAssembly.instantiateStreaming(Y,k).then(N,function(Q){return E("wasm streaming compile failed: "+Q),E("falling back to ArrayBuffer instantiation"),Qt(B,k,N)}))})(P,function(k){_(k.instance,k.module)}).catch(t)})(),e._OrtInit=(_,P)=>(e._OrtInit=H.X)(_,P),e._OrtGetLastError=(_,P)=>(e._OrtGetLastError=H.Y)(_,P),e._OrtCreateSessionOptions=(_,P,k,N,B,Y,Q,dt,$t,wt)=>(e._OrtCreateSessionOptions=H.Z)(_,P,k,N,B,Y,Q,dt,$t,wt),e._OrtAppendExecutionProvider=(_,P)=>(e._OrtAppendExecutionProvider=H._)(_,P),e._OrtAddSessionConfigEntry=(_,P,k)=>(e._OrtAddSessionConfigEntry=H.$)(_,P,k),e._OrtReleaseSessionOptions=_=>(e._OrtReleaseSessionOptions=H.aa)(_),e._OrtCreateSession=(_,P,k)=>(e._OrtCreateSession=H.ba)(_,P,k),e._OrtReleaseSession=_=>(e._OrtReleaseSession=H.ca)(_),e._OrtGetInputOutputCount=(_,P,k)=>(e._OrtGetInputOutputCount=H.da)(_,P,k),e._OrtGetInputName=(_,P)=>(e._OrtGetInputName=H.ea)(_,P),e._OrtGetOutputName=(_,P)=>(e._OrtGetOutputName=H.fa)(_,P),e._OrtFree=_=>(e._OrtFree=H.ga)(_),e._OrtCreateTensor=(_,P,k,N,B)=>(e._OrtCreateTensor=H.ha)(_,P,k,N,B),e._OrtGetTensorData=(_,P,k,N,B)=>(e._OrtGetTensorData=H.ia)(_,P,k,N,B),e._OrtReleaseTensor=_=>(e._OrtReleaseTensor=H.ja)(_),e._OrtCreateRunOptions=(_,P,k,N)=>(e._OrtCreateRunOptions=H.ka)(_,P,k,N),e._OrtAddRunConfigEntry=(_,P,k)=>(e._OrtAddRunConfigEntry=H.la)(_,P,k),e._OrtReleaseRunOptions=_=>(e._OrtReleaseRunOptions=H.ma)(_),e._OrtRun=(_,P,k,N,B,Y,Q,dt)=>(e._OrtRun=H.na)(_,P,k,N,B,Y,Q,dt),e._OrtEndProfiling=_=>(e._OrtEndProfiling=H.oa)(_);var ne=e._pthread_self=()=>(ne=e._pthread_self=H.pa)(),$e=e._malloc=_=>($e=e._malloc=H.qa)(_);e._free=_=>(e._free=H.ra)(_),e.__emscripten_tls_init=()=>(e.__emscripten_tls_init=H.sa)();var ke=e.__emscripten_thread_init=(_,P,k,N,B,Y)=>(ke=e.__emscripten_thread_init=H.ua)(_,P,k,N,B,Y);e.__emscripten_thread_crashed=()=>(e.__emscripten_thread_crashed=H.va)();var re,Fe=(_,P,k,N)=>(Fe=H.wa)(_,P,k,N),le=_=>(le=H.xa)(_),ce=e.__emscripten_thread_exit=_=>(ce=e.__emscripten_thread_exit=H.ya)(_),Re=e.__emscripten_check_mailbox=()=>(Re=e.__emscripten_check_mailbox=H.za)(),Le=_=>(Le=H.Aa)(_),Ne=(_,P)=>(Ne=H.Ba)(_,P),pe=()=>(pe=H.Ca)(),oe=_=>(oe=H.Da)(_),de=_=>(de=H.Ea)(_);function Ce(){function _(){if(!re&&(re=!0,e.calledRun=!0,!ut)&&(x||Mt(Dt),n(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),!x)){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;){var P=e.postRun.shift();lt.unshift(P)}Mt(lt)}}if(!(0<Et))if(x)n(e),x||Mt(Dt),startWorker(e);else{if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)mt.unshift(e.preRun.shift());Mt(mt),0<Et||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),_()},1)):_())}}if(e.keepRuntimeAlive=St,e.wasmMemory=q,e.stackAlloc=de,e.stackSave=pe,e.stackRestore=oe,e.UTF8ToString=Nt,e.stringToUTF8=yt,e.lengthBytesUTF8=ot,e.ExitStatus=jt,e.PThread=et,Pt=function _(){re||Ce(),re||(Pt=_)},e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Ce(),h.ready});R.exports=p},932:(R,l,b)=>{var m,p=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(m=m||__filename),function(h={}){var d,u,c=h;c.ready=new Promise((I,L)=>{d=I,u=L});var a,o,n,t=Object.assign({},c),e="./this.program",r=(I,L)=>{throw L},i=typeof window=="object",s=typeof importScripts=="function",f=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";if(f){var y=b(1384),v=b(908);g=s?v.dirname(g)+"/":__dirname+"/",a=(I,L)=>(I=I.startsWith("file://")?new URL(I):v.normalize(I),y.readFileSync(I,L?void 0:"utf8")),n=I=>((I=a(I,!0)).buffer||(I=new Uint8Array(I)),I),o=(I,L,C,G=!0)=>{I=I.startsWith("file://")?new URL(I):v.normalize(I),y.readFile(I,G?void 0:"utf8",(W,Z)=>{W?C(W):L(G?Z.buffer:Z)})},!c.thisProgram&&1<process.argv.length&&(e=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),r=(I,L)=>{throw process.exitCode=I,L},c.inspect=()=>"[Emscripten Module object]"}else(i||s)&&(s?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),m&&(g=m),g=g.indexOf("blob:")!==0?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=I=>{var L=new XMLHttpRequest;return L.open("GET",I,!1),L.send(null),L.responseText},s&&(n=I=>{var L=new XMLHttpRequest;return L.open("GET",I,!1),L.responseType="arraybuffer",L.send(null),new Uint8Array(L.response)}),o=(I,L,C)=>{var G=new XMLHttpRequest;G.open("GET",I,!0),G.responseType="arraybuffer",G.onload=()=>{G.status==200||G.status==0&&G.response?L(G.response):C()},G.onerror=C,G.send(null)});var w,T=c.print||console.log.bind(console),x=c.printErr||console.error.bind(console);Object.assign(c,t),t=null,c.thisProgram&&(e=c.thisProgram),c.quit&&(r=c.quit),c.wasmBinary&&(w=c.wasmBinary);var A=c.noExitRuntime||!0;typeof WebAssembly!="object"&&rt("no native wasm support detected");var D,$,j,M,S,U,O=!1;function E(){var I=D.buffer;c.HEAP8=j=new Int8Array(I),c.HEAP16=new Int16Array(I),c.HEAP32=S=new Int32Array(I),c.HEAPU8=M=new Uint8Array(I),c.HEAPU16=new Uint16Array(I),c.HEAPU32=U=new Uint32Array(I),c.HEAPF32=new Float32Array(I),c.HEAPF64=new Float64Array(I)}var F=[],q=[],H=[];function K(){var I=c.preRun.shift();F.unshift(I)}var X,J,tt=0,nt=null;function rt(I){throw c.onAbort&&c.onAbort(I),x(I="Aborted("+I+")"),O=!0,I=new WebAssembly.RuntimeError(I+". Build with -sASSERTIONS for more info."),u(I),I}function it(I){return I.startsWith("data:application/octet-stream;base64,")}if(!it(X="ort-wasm.wasm")){var ut=X;X=c.locateFile?c.locateFile(ut,g):g+ut}function gt(I){if(I==X&&w)return new Uint8Array(w);if(n)return n(I);throw"both async and sync fetching of the wasm failed"}function xt(I,L,C){return function(G){if(!w&&(i||s)){if(typeof fetch=="function"&&!G.startsWith("file://"))return fetch(G,{credentials:"same-origin"}).then(W=>{if(!W.ok)throw"failed to load wasm binary file at '"+G+"'";return W.arrayBuffer()}).catch(()=>gt(G));if(o)return new Promise((W,Z)=>{o(G,ot=>W(new Uint8Array(ot)),Z)})}return Promise.resolve().then(()=>gt(G))}(I).then(G=>WebAssembly.instantiate(G,L)).then(G=>G).then(C,G=>{x("failed to asynchronously prepare wasm: "+G),rt(G)})}function kt(I){this.name="ExitStatus",this.message=`Program terminated with exit(${I})`,this.status=I}var mt=I=>{for(;0<I.length;)I.shift()(c)};function Dt(I){this.qa=I-24,this.va=function(L){U[this.qa+4>>2>>>0]=L},this.ua=function(L){U[this.qa+8>>2>>>0]=L},this.sa=function(L,C){this.ta(),this.va(L),this.ua(C)},this.ta=function(){U[this.qa+16>>2>>>0]=0}}var lt,bt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,St=(I,L,C)=>{var G=(L>>>=0)+C;for(C=L;I[C]&&!(C>=G);)++C;if(16<C-L&&I.buffer&&bt)return bt.decode(I.subarray(L,C));for(G="";L<C;){var W=I[L++];if(128&W){var Z=63&I[L++];if((224&W)==192)G+=String.fromCharCode((31&W)<<6|Z);else{var ot=63&I[L++];65536>(W=(240&W)==224?(15&W)<<12|Z<<6|ot:(7&W)<<18|Z<<12|ot<<6|63&I[L++])?G+=String.fromCharCode(W):(W-=65536,G+=String.fromCharCode(55296|W>>10,56320|1023&W))}}else G+=String.fromCharCode(W)}return G},_t=(I,L)=>(I>>>=0)?St(M,I,L):"",At=I=>{for(var L=0,C=0;C<I.length;++C){var G=I.charCodeAt(C);127>=G?L++:2047>=G?L+=2:55296<=G&&57343>=G?(L+=4,++C):L+=3}return L},Et=(I,L,C,G)=>{if(!(0<G))return 0;var W=C>>>=0;G=C+G-1;for(var Z=0;Z<I.length;++Z){var ot=I.charCodeAt(Z);if(55296<=ot&&57343>=ot&&(ot=65536+((1023&ot)<<10)|1023&I.charCodeAt(++Z)),127>=ot){if(C>=G)break;L[C++>>>0]=ot}else{if(2047>=ot){if(C+1>=G)break;L[C++>>>0]=192|ot>>6}else{if(65535>=ot){if(C+2>=G)break;L[C++>>>0]=224|ot>>12}else{if(C+3>=G)break;L[C++>>>0]=240|ot>>18,L[C++>>>0]=128|ot>>12&63}L[C++>>>0]=128|ot>>6&63}L[C++>>>0]=128|63&ot}}return L[C>>>0]=0,C-W},Pt=I=>I%4==0&&(I%100!=0||I%400==0),Ct=[0,31,60,91,121,152,182,213,244,274,305,335],Lt=[0,31,59,90,120,151,181,212,243,273,304,334],Ot=I=>{var L=At(I)+1,C=Wt(L);return C&&Et(I,M,C,L),C},Ft={},Gt=()=>{if(!lt){var I,L={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:e||"./this.program"};for(I in Ft)Ft[I]===void 0?delete L[I]:L[I]=Ft[I];var C=[];for(I in L)C.push(`${I}=${L[I]}`);lt=C}return lt},Qt=[null,[],[]],jt=I=>(jt=(()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return G=>crypto.getRandomValues(G);if(f)try{var L=b(760);if(L.randomFillSync)return G=>L.randomFillSync(G);var C=L.randomBytes;return G=>(G.set(C(G.byteLength)),G)}catch{}rt("initRandomDevice")})())(I),Bt=[31,29,31,30,31,30,31,31,30,31,30,31],Ht=[31,28,31,30,31,30,31,31,30,31,30,31];function qt(I,L,C,G){function W(V,at,ct){for(V=typeof V=="number"?V.toString():V||"";V.length<at;)V=ct[0]+V;return V}function Z(V,at){return W(V,at,"0")}function ot(V,at){function ct(Zt){return 0>Zt?-1:0<Zt?1:0}var Rt;return(Rt=ct(V.getFullYear()-at.getFullYear()))===0&&(Rt=ct(V.getMonth()-at.getMonth()))===0&&(Rt=ct(V.getDate()-at.getDate())),Rt}function ht(V){switch(V.getDay()){case 0:return new Date(V.getFullYear()-1,11,29);case 1:return V;case 2:return new Date(V.getFullYear(),0,3);case 3:return new Date(V.getFullYear(),0,2);case 4:return new Date(V.getFullYear(),0,1);case 5:return new Date(V.getFullYear()-1,11,31);case 6:return new Date(V.getFullYear()-1,11,30)}}function yt(V){var at=V.ma;for(V=new Date(new Date(V.na+1900,0,1).getTime());0<at;){var ct=V.getMonth(),Rt=(Pt(V.getFullYear())?Bt:Ht)[ct];if(!(at>Rt-V.getDate())){V.setDate(V.getDate()+at);break}at-=Rt-V.getDate()+1,V.setDate(1),11>ct?V.setMonth(ct+1):(V.setMonth(0),V.setFullYear(V.getFullYear()+1))}return ct=new Date(V.getFullYear()+1,0,4),at=ht(new Date(V.getFullYear(),0,4)),ct=ht(ct),0>=ot(at,V)?0>=ot(ct,V)?V.getFullYear()+1:V.getFullYear():V.getFullYear()-1}I>>>=0,L>>>=0,C>>>=0;var Tt=S[40+(G>>>=0)>>2>>>0];for(var vt in G={ya:S[G>>2>>>0],xa:S[G+4>>2>>>0],oa:S[G+8>>2>>>0],ra:S[G+12>>2>>>0],pa:S[G+16>>2>>>0],na:S[G+20>>2>>>0],ha:S[G+24>>2>>>0],ma:S[G+28>>2>>>0],Aa:S[G+32>>2>>>0],wa:S[G+36>>2>>>0],za:Tt?_t(Tt):""},C=_t(C),Tt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})C=C.replace(new RegExp(vt,"g"),Tt[vt]);var Kt="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Jt="January February March April May June July August September October November December".split(" ");for(vt in Tt={"%a":V=>Kt[V.ha].substring(0,3),"%A":V=>Kt[V.ha],"%b":V=>Jt[V.pa].substring(0,3),"%B":V=>Jt[V.pa],"%C":V=>Z((V.na+1900)/100|0,2),"%d":V=>Z(V.ra,2),"%e":V=>W(V.ra,2," "),"%g":V=>yt(V).toString().substring(2),"%G":V=>yt(V),"%H":V=>Z(V.oa,2),"%I":V=>((V=V.oa)==0?V=12:12<V&&(V-=12),Z(V,2)),"%j":V=>{for(var at=0,ct=0;ct<=V.pa-1;at+=(Pt(V.na+1900)?Bt:Ht)[ct++]);return Z(V.ra+at,3)},"%m":V=>Z(V.pa+1,2),"%M":V=>Z(V.xa,2),"%n":()=>`
`,"%p":V=>0<=V.oa&&12>V.oa?"AM":"PM","%S":V=>Z(V.ya,2),"%t":()=>"	","%u":V=>V.ha||7,"%U":V=>Z(Math.floor((V.ma+7-V.ha)/7),2),"%V":V=>{var at=Math.floor((V.ma+7-(V.ha+6)%7)/7);if(2>=(V.ha+371-V.ma-2)%7&&at++,at)at==53&&((ct=(V.ha+371-V.ma)%7)==4||ct==3&&Pt(V.na)||(at=1));else{at=52;var ct=(V.ha+7-V.ma-1)%7;(ct==4||ct==5&&Pt(V.na%400-1))&&at++}return Z(at,2)},"%w":V=>V.ha,"%W":V=>Z(Math.floor((V.ma+7-(V.ha+6)%7)/7),2),"%y":V=>(V.na+1900).toString().substring(2),"%Y":V=>V.na+1900,"%z":V=>{var at=0<=(V=V.wa);return V=Math.abs(V)/60,(at?"+":"-")+("0000"+(V/60*100+V%60)).slice(-4)},"%Z":V=>V.za,"%%":()=>"%"},C=C.replace(/%%/g,"\0\0"),Tt)C.includes(vt)&&(C=C.replace(new RegExp(vt,"g"),Tt[vt](G)));return vt=function(V){var at=Array(At(V)+1);return Et(V,at,0,at.length),at}(C=C.replace(/\0\0/g,"%")),vt.length>L?0:(j.set(vt,I>>>0),vt.length-1)}var te={a:function(I,L,C){throw new Dt(I>>>=0).sa(L>>>0,C>>>0),I},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(I,L,C){I=L+2097152>>>0<4194305-!!I?(I>>>0)+4294967296*L:NaN,C>>>=0,I=new Date(1e3*I),S[C>>2>>>0]=I.getUTCSeconds(),S[C+4>>2>>>0]=I.getUTCMinutes(),S[C+8>>2>>>0]=I.getUTCHours(),S[C+12>>2>>>0]=I.getUTCDate(),S[C+16>>2>>>0]=I.getUTCMonth(),S[C+20>>2>>>0]=I.getUTCFullYear()-1900,S[C+24>>2>>>0]=I.getUTCDay(),S[C+28>>2>>>0]=(I.getTime()-Date.UTC(I.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(I,L,C){I=L+2097152>>>0<4194305-!!I?(I>>>0)+4294967296*L:NaN,C>>>=0,I=new Date(1e3*I),S[C>>2>>>0]=I.getSeconds(),S[C+4>>2>>>0]=I.getMinutes(),S[C+8>>2>>>0]=I.getHours(),S[C+12>>2>>>0]=I.getDate(),S[C+16>>2>>>0]=I.getMonth(),S[C+20>>2>>>0]=I.getFullYear()-1900,S[C+24>>2>>>0]=I.getDay(),S[C+28>>2>>>0]=(Pt(I.getFullYear())?Ct:Lt)[I.getMonth()]+I.getDate()-1|0,S[C+36>>2>>>0]=-60*I.getTimezoneOffset(),L=new Date(I.getFullYear(),6,1).getTimezoneOffset();var G=new Date(I.getFullYear(),0,1).getTimezoneOffset();S[C+32>>2>>>0]=0|(L!=G&&I.getTimezoneOffset()==Math.min(G,L))},p:function(I){I>>>=0;var L=new Date(S[I+20>>2>>>0]+1900,S[I+16>>2>>>0],S[I+12>>2>>>0],S[I+8>>2>>>0],S[I+4>>2>>>0],S[I>>2>>>0],0),C=S[I+32>>2>>>0],G=L.getTimezoneOffset(),W=new Date(L.getFullYear(),6,1).getTimezoneOffset(),Z=new Date(L.getFullYear(),0,1).getTimezoneOffset(),ot=Math.min(Z,W);return 0>C?S[I+32>>2>>>0]=+(W!=Z&&ot==G):0<C!=(ot==G)&&(W=Math.max(Z,W),L.setTime(L.getTime()+6e4*((0<C?ot:W)-G))),S[I+24>>2>>>0]=L.getDay(),S[I+28>>2>>>0]=(Pt(L.getFullYear())?Ct:Lt)[L.getMonth()]+L.getDate()-1|0,S[I>>2>>>0]=L.getSeconds(),S[I+4>>2>>>0]=L.getMinutes(),S[I+8>>2>>>0]=L.getHours(),S[I+12>>2>>>0]=L.getDate(),S[I+16>>2>>>0]=L.getMonth(),S[I+20>>2>>>0]=L.getYear(),I=L.getTime()/1e3,Xt((J=I,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),I>>>0},l:function(){return-52},m:function(){},u:function(I,L,C){function G(yt){return(yt=yt.toTimeString().match(/\(([A-Za-z ]+)\)$/))?yt[1]:"GMT"}C>>>=0;var W=new Date().getFullYear(),Z=new Date(W,0,1),ot=new Date(W,6,1);W=Z.getTimezoneOffset();var ht=ot.getTimezoneOffset();U[I>>>0>>2>>>0]=60*Math.max(W,ht),S[L>>>0>>2>>>0]=+(W!=ht),I=G(Z),L=G(ot),I=Ot(I),L=Ot(L),ht<W?(U[C>>2>>>0]=I,U[C+4>>2>>>0]=L):(U[C>>2>>>0]=L,U[C+4>>2>>>0]=I)},d:()=>{rt("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(I,L,C){return L>>>=0,M.copyWithin(I>>>0>>>0,L>>>0,L+(C>>>0)>>>0)},t:function(I){I>>>=0;var L=M.length;if(4294901760<I)return!1;for(var C=1;4>=C;C*=2){var G=L*(1+.2/C);G=Math.min(G,I+100663296);var W=Math;G=Math.max(I,G);t:{W=W.min.call(W,4294901760,G+(65536-G%65536)%65536)-D.buffer.byteLength+65535>>>16;try{D.grow(W),E();var Z=1;break t}catch{}Z=void 0}if(Z)return!0}return!1},D:function(I,L){I>>>=0,L>>>=0;var C=0;return Gt().forEach(function(G,W){var Z=L+C;for(W=U[I+4*W>>2>>>0]=Z,Z=0;Z<G.length;++Z)j[W++>>0>>>0]=G.charCodeAt(Z);j[W>>0>>>0]=0,C+=G.length+1}),0},E:function(I,L){I>>>=0,L>>>=0;var C=Gt();U[I>>2>>>0]=C.length;var G=0;return C.forEach(function(W){G+=W.length+1}),U[L>>2>>>0]=G,0},s:I=>{A||(c.onExit&&c.onExit(I),O=!0),r(I,new kt(I))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(I,L,C,G){L>>>=0,C>>>=0,G>>>=0;for(var W=0,Z=0;Z<C;Z++){var ot=U[L>>2>>>0],ht=U[L+4>>2>>>0];L+=8;for(var yt=0;yt<ht;yt++){var Tt=M[ot+yt>>>0],vt=Qt[I];Tt===0||Tt===10?((I===1?T:x)(St(vt,0)),vt.length=0):vt.push(Tt)}W+=ht}return U[G>>2>>>0]=W,0},r:function(I,L){return I>>>=0,jt(M.subarray(I>>>0,I+(L>>>0)>>>0)),0},C:qt,c:function(I,L,C,G){return qt(I>>>0,L>>>0,C>>>0,G>>>0)}};(function(){function I(C){if(C=C.exports,$=C=function(W){var Z=ht=>()=>ht()>>>0,ot=ht=>yt=>ht(yt)>>>0;return(W=Object.assign({},W)).__errno_location=Z(W.__errno_location),W.malloc=ot(W.malloc),W.stackSave=Z(W.stackSave),W.stackAlloc=ot(W.stackAlloc),W}(C),D=$.L,E(),q.unshift($.M),tt--,c.monitorRunDependencies&&c.monitorRunDependencies(tt),tt==0&&nt){var G=nt;nt=null,G()}return C}var L={a:te};if(tt++,c.monitorRunDependencies&&c.monitorRunDependencies(tt),c.instantiateWasm)try{return c.instantiateWasm(L,I)}catch(C){x("Module.instantiateWasm callback failed with error: "+C),u(C)}(function(C,G){var W=X;return w||typeof WebAssembly.instantiateStreaming!="function"||it(W)||W.startsWith("file://")||f||typeof fetch!="function"?xt(W,C,G):fetch(W,{credentials:"same-origin"}).then(Z=>WebAssembly.instantiateStreaming(Z,C).then(G,function(ot){return x("wasm streaming compile failed: "+ot),x("falling back to ArrayBuffer instantiation"),xt(W,C,G)}))})(L,function(C){I(C.instance)}).catch(u)})(),c._OrtInit=(I,L)=>(c._OrtInit=$.N)(I,L),c._OrtGetLastError=(I,L)=>(c._OrtGetLastError=$.O)(I,L),c._OrtCreateSessionOptions=(I,L,C,G,W,Z,ot,ht,yt,Tt)=>(c._OrtCreateSessionOptions=$.P)(I,L,C,G,W,Z,ot,ht,yt,Tt),c._OrtAppendExecutionProvider=(I,L)=>(c._OrtAppendExecutionProvider=$.Q)(I,L),c._OrtAddSessionConfigEntry=(I,L,C)=>(c._OrtAddSessionConfigEntry=$.R)(I,L,C),c._OrtReleaseSessionOptions=I=>(c._OrtReleaseSessionOptions=$.S)(I),c._OrtCreateSession=(I,L,C)=>(c._OrtCreateSession=$.T)(I,L,C),c._OrtReleaseSession=I=>(c._OrtReleaseSession=$.U)(I),c._OrtGetInputOutputCount=(I,L,C)=>(c._OrtGetInputOutputCount=$.V)(I,L,C),c._OrtGetInputName=(I,L)=>(c._OrtGetInputName=$.W)(I,L),c._OrtGetOutputName=(I,L)=>(c._OrtGetOutputName=$.X)(I,L),c._OrtFree=I=>(c._OrtFree=$.Y)(I),c._OrtCreateTensor=(I,L,C,G,W)=>(c._OrtCreateTensor=$.Z)(I,L,C,G,W),c._OrtGetTensorData=(I,L,C,G,W)=>(c._OrtGetTensorData=$._)(I,L,C,G,W),c._OrtReleaseTensor=I=>(c._OrtReleaseTensor=$.$)(I),c._OrtCreateRunOptions=(I,L,C,G)=>(c._OrtCreateRunOptions=$.aa)(I,L,C,G),c._OrtAddRunConfigEntry=(I,L,C)=>(c._OrtAddRunConfigEntry=$.ba)(I,L,C),c._OrtReleaseRunOptions=I=>(c._OrtReleaseRunOptions=$.ca)(I),c._OrtRun=(I,L,C,G,W,Z,ot,ht)=>(c._OrtRun=$.da)(I,L,C,G,W,Z,ot,ht),c._OrtEndProfiling=I=>(c._OrtEndProfiling=$.ea)(I);var Wt=c._malloc=I=>(Wt=c._malloc=$.fa)(I);c._free=I=>(c._free=$.ga)(I);var Nt,Xt=I=>(Xt=$.ia)(I),Vt=()=>(Vt=$.ja)(),et=I=>(et=$.ka)(I),Mt=I=>(Mt=$.la)(I);function Yt(){function I(){if(!Nt&&(Nt=!0,c.calledRun=!0,!O)){if(mt(q),d(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;){var L=c.postRun.shift();H.unshift(L)}mt(H)}}if(!(0<tt)){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)K();mt(F),0<tt||(c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),I()},1)):I())}}if(c.stackAlloc=Mt,c.stackSave=Vt,c.stackRestore=et,c.UTF8ToString=_t,c.stringToUTF8=(I,L,C)=>Et(I,M,L,C),c.lengthBytesUTF8=At,nt=function I(){Nt||Yt(),Nt||(nt=I)},c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return Yt(),h.ready});R.exports=p},4537:R=>{R.exports=function(l,b){for(var m=new Array(arguments.length-1),p=0,h=2,d=!0;h<arguments.length;)m[p++]=arguments[h++];return new Promise(function(u,c){m[p]=function(a){if(d)if(d=!1,a)c(a);else{for(var o=new Array(arguments.length-1),n=0;n<o.length;)o[n++]=arguments[n];u.apply(null,o)}};try{l.apply(b||null,m)}catch(a){d&&(d=!1,c(a))}})}},7419:(R,l)=>{var b=l;b.length=function(u){var c=u.length;if(!c)return 0;for(var a=0;--c%4>1&&u.charAt(c)==="=";)++a;return Math.ceil(3*u.length)/4-a};for(var m=new Array(64),p=new Array(123),h=0;h<64;)p[m[h]=h<26?h+65:h<52?h+71:h<62?h-4:h-59|43]=h++;b.encode=function(u,c,a){for(var o,n=null,t=[],e=0,r=0;c<a;){var i=u[c++];switch(r){case 0:t[e++]=m[i>>2],o=(3&i)<<4,r=1;break;case 1:t[e++]=m[o|i>>4],o=(15&i)<<2,r=2;break;case 2:t[e++]=m[o|i>>6],t[e++]=m[63&i],r=0}e>8191&&((n||(n=[])).push(String.fromCharCode.apply(String,t)),e=0)}return r&&(t[e++]=m[o],t[e++]=61,r===1&&(t[e++]=61)),n?(e&&n.push(String.fromCharCode.apply(String,t.slice(0,e))),n.join("")):String.fromCharCode.apply(String,t.slice(0,e))};var d="invalid encoding";b.decode=function(u,c,a){for(var o,n=a,t=0,e=0;e<u.length;){var r=u.charCodeAt(e++);if(r===61&&t>1)break;if((r=p[r])===void 0)throw Error(d);switch(t){case 0:o=r,t=1;break;case 1:c[a++]=o<<2|(48&r)>>4,o=r,t=2;break;case 2:c[a++]=(15&o)<<4|(60&r)>>2,o=r,t=3;break;case 3:c[a++]=(3&o)<<6|r,t=0}}if(t===1)throw Error(d);return a-n},b.test=function(u){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(u)}},9211:R=>{function l(){this._listeners={}}R.exports=l,l.prototype.on=function(b,m,p){return(this._listeners[b]||(this._listeners[b]=[])).push({fn:m,ctx:p||this}),this},l.prototype.off=function(b,m){if(b===void 0)this._listeners={};else if(m===void 0)this._listeners[b]=[];else for(var p=this._listeners[b],h=0;h<p.length;)p[h].fn===m?p.splice(h,1):++h;return this},l.prototype.emit=function(b){var m=this._listeners[b];if(m){for(var p=[],h=1;h<arguments.length;)p.push(arguments[h++]);for(h=0;h<m.length;)m[h].fn.apply(m[h++].ctx,p)}return this}},945:R=>{function l(d){return typeof Float32Array<"u"?function(){var u=new Float32Array([-0]),c=new Uint8Array(u.buffer),a=c[3]===128;function o(r,i,s){u[0]=r,i[s]=c[0],i[s+1]=c[1],i[s+2]=c[2],i[s+3]=c[3]}function n(r,i,s){u[0]=r,i[s]=c[3],i[s+1]=c[2],i[s+2]=c[1],i[s+3]=c[0]}function t(r,i){return c[0]=r[i],c[1]=r[i+1],c[2]=r[i+2],c[3]=r[i+3],u[0]}function e(r,i){return c[3]=r[i],c[2]=r[i+1],c[1]=r[i+2],c[0]=r[i+3],u[0]}d.writeFloatLE=a?o:n,d.writeFloatBE=a?n:o,d.readFloatLE=a?t:e,d.readFloatBE=a?e:t}():function(){function u(a,o,n,t){var e=o<0?1:0;if(e&&(o=-o),o===0)a(1/o>0?0:2147483648,n,t);else if(isNaN(o))a(2143289344,n,t);else if(o>34028234663852886e22)a((e<<31|2139095040)>>>0,n,t);else if(o<11754943508222875e-54)a((e<<31|Math.round(o/1401298464324817e-60))>>>0,n,t);else{var r=Math.floor(Math.log(o)/Math.LN2);a((e<<31|r+127<<23|8388607&Math.round(o*Math.pow(2,-r)*8388608))>>>0,n,t)}}function c(a,o,n){var t=a(o,n),e=2*(t>>31)+1,r=t>>>23&255,i=8388607&t;return r===255?i?NaN:e*(1/0):r===0?1401298464324817e-60*e*i:e*Math.pow(2,r-150)*(i+8388608)}d.writeFloatLE=u.bind(null,b),d.writeFloatBE=u.bind(null,m),d.readFloatLE=c.bind(null,p),d.readFloatBE=c.bind(null,h)}(),typeof Float64Array<"u"?function(){var u=new Float64Array([-0]),c=new Uint8Array(u.buffer),a=c[7]===128;function o(r,i,s){u[0]=r,i[s]=c[0],i[s+1]=c[1],i[s+2]=c[2],i[s+3]=c[3],i[s+4]=c[4],i[s+5]=c[5],i[s+6]=c[6],i[s+7]=c[7]}function n(r,i,s){u[0]=r,i[s]=c[7],i[s+1]=c[6],i[s+2]=c[5],i[s+3]=c[4],i[s+4]=c[3],i[s+5]=c[2],i[s+6]=c[1],i[s+7]=c[0]}function t(r,i){return c[0]=r[i],c[1]=r[i+1],c[2]=r[i+2],c[3]=r[i+3],c[4]=r[i+4],c[5]=r[i+5],c[6]=r[i+6],c[7]=r[i+7],u[0]}function e(r,i){return c[7]=r[i],c[6]=r[i+1],c[5]=r[i+2],c[4]=r[i+3],c[3]=r[i+4],c[2]=r[i+5],c[1]=r[i+6],c[0]=r[i+7],u[0]}d.writeDoubleLE=a?o:n,d.writeDoubleBE=a?n:o,d.readDoubleLE=a?t:e,d.readDoubleBE=a?e:t}():function(){function u(a,o,n,t,e,r){var i=t<0?1:0;if(i&&(t=-t),t===0)a(0,e,r+o),a(1/t>0?0:2147483648,e,r+n);else if(isNaN(t))a(0,e,r+o),a(2146959360,e,r+n);else if(t>17976931348623157e292)a(0,e,r+o),a((i<<31|2146435072)>>>0,e,r+n);else{var s;if(t<22250738585072014e-324)a((s=t/5e-324)>>>0,e,r+o),a((i<<31|s/4294967296)>>>0,e,r+n);else{var f=Math.floor(Math.log(t)/Math.LN2);f===1024&&(f=1023),a(4503599627370496*(s=t*Math.pow(2,-f))>>>0,e,r+o),a((i<<31|f+1023<<20|1048576*s&1048575)>>>0,e,r+n)}}}function c(a,o,n,t,e){var r=a(t,e+o),i=a(t,e+n),s=2*(i>>31)+1,f=i>>>20&2047,g=4294967296*(1048575&i)+r;return f===2047?g?NaN:s*(1/0):f===0?5e-324*s*g:s*Math.pow(2,f-1075)*(g+4503599627370496)}d.writeDoubleLE=u.bind(null,b,0,4),d.writeDoubleBE=u.bind(null,m,4,0),d.readDoubleLE=c.bind(null,p,0,4),d.readDoubleBE=c.bind(null,h,4,0)}(),d}function b(d,u,c){u[c]=255&d,u[c+1]=d>>>8&255,u[c+2]=d>>>16&255,u[c+3]=d>>>24}function m(d,u,c){u[c]=d>>>24,u[c+1]=d>>>16&255,u[c+2]=d>>>8&255,u[c+3]=255&d}function p(d,u){return(d[u]|d[u+1]<<8|d[u+2]<<16|d[u+3]<<24)>>>0}function h(d,u){return(d[u]<<24|d[u+1]<<16|d[u+2]<<8|d[u+3])>>>0}R.exports=l(l)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(R){}return null}module.exports=inquire},6662:R=>{R.exports=function(l,b,m){var p=m||8192,h=p>>>1,d=null,u=p;return function(c){if(c<1||c>h)return l(c);u+c>p&&(d=l(p),u=0);var a=b.call(d,u,u+=c);return 7&u&&(u=1+(7|u)),a}}},4997:(R,l)=>{var b=l;b.length=function(m){for(var p=0,h=0,d=0;d<m.length;++d)(h=m.charCodeAt(d))<128?p+=1:h<2048?p+=2:(64512&h)==55296&&(64512&m.charCodeAt(d+1))==56320?(++d,p+=4):p+=3;return p},b.read=function(m,p,h){if(h-p<1)return"";for(var d,u=null,c=[],a=0;p<h;)(d=m[p++])<128?c[a++]=d:d>191&&d<224?c[a++]=(31&d)<<6|63&m[p++]:d>239&&d<365?(d=((7&d)<<18|(63&m[p++])<<12|(63&m[p++])<<6|63&m[p++])-65536,c[a++]=55296+(d>>10),c[a++]=56320+(1023&d)):c[a++]=(15&d)<<12|(63&m[p++])<<6|63&m[p++],a>8191&&((u||(u=[])).push(String.fromCharCode.apply(String,c)),a=0);return u?(a&&u.push(String.fromCharCode.apply(String,c.slice(0,a))),u.join("")):String.fromCharCode.apply(String,c.slice(0,a))},b.write=function(m,p,h){for(var d,u,c=h,a=0;a<m.length;++a)(d=m.charCodeAt(a))<128?p[h++]=d:d<2048?(p[h++]=d>>6|192,p[h++]=63&d|128):(64512&d)==55296&&(64512&(u=m.charCodeAt(a+1)))==56320?(d=65536+((1023&d)<<10)+(1023&u),++a,p[h++]=d>>18|240,p[h++]=d>>12&63|128,p[h++]=d>>6&63|128,p[h++]=63&d|128):(p[h++]=d>>12|224,p[h++]=d>>6&63|128,p[h++]=63&d|128);return h-c}},3442:(R,l)=>{l.__esModule=!0;var b=function(){function m(p){if(!p)throw new TypeError("Invalid argument; `value` has no value.");this.value=m.EMPTY,p&&m.isGuid(p)&&(this.value=p)}return m.isGuid=function(p){var h=p.toString();return p&&(p instanceof m||m.validator.test(h))},m.create=function(){return new m([m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-"))},m.createEmpty=function(){return new m("emptyguid")},m.parse=function(p){return new m(p)},m.raw=function(){return[m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-")},m.gen=function(p){for(var h="",d=0;d<p;d++)h+=(65536*(1+Math.random())|0).toString(16).substring(1);return h},m.prototype.equals=function(p){return m.isGuid(p)&&this.value===p.toString()},m.prototype.isEmpty=function(){return this.value===m.EMPTY},m.prototype.toString=function(){return this.value},m.prototype.toJSON=function(){return{value:this.value}},m.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),m.EMPTY="00000000-0000-0000-0000-000000000000",m}();l.Guid=b},2100:(R,l,b)=>{R.exports=b(9482)},9482:(R,l,b)=>{var m=l;function p(){m.util._configure(),m.Writer._configure(m.BufferWriter),m.Reader._configure(m.BufferReader)}m.build="minimal",m.Writer=b(1173),m.BufferWriter=b(3155),m.Reader=b(1408),m.BufferReader=b(593),m.util=b(9693),m.rpc=b(5994),m.roots=b(5054),m.configure=p,p()},1408:(R,l,b)=>{R.exports=c;var m,p=b(9693),h=p.LongBits,d=p.utf8;function u(i,s){return RangeError("index out of range: "+i.pos+" + "+(s||1)+" > "+i.len)}function c(i){this.buf=i,this.pos=0,this.len=i.length}var a,o=typeof Uint8Array<"u"?function(i){if(i instanceof Uint8Array||Array.isArray(i))return new c(i);throw Error("illegal buffer")}:function(i){if(Array.isArray(i))return new c(i);throw Error("illegal buffer")},n=function(){return p.Buffer?function(i){return(c.create=function(s){return p.Buffer.isBuffer(s)?new m(s):o(s)})(i)}:o};function t(){var i=new h(0,0),s=0;if(!(this.len-this.pos>4)){for(;s<3;++s){if(this.pos>=this.len)throw u(this);if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*s)>>>0,this.buf[this.pos++]<128)return i}return i.lo=(i.lo|(127&this.buf[this.pos++])<<7*s)>>>0,i}for(;s<4;++s)if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*s)>>>0,this.buf[this.pos++]<128)return i;if(i.lo=(i.lo|(127&this.buf[this.pos])<<28)>>>0,i.hi=(i.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return i;if(s=0,this.len-this.pos>4){for(;s<5;++s)if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*s+3)>>>0,this.buf[this.pos++]<128)return i}else for(;s<5;++s){if(this.pos>=this.len)throw u(this);if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*s+3)>>>0,this.buf[this.pos++]<128)return i}throw Error("invalid varint encoding")}function e(i,s){return(i[s-4]|i[s-3]<<8|i[s-2]<<16|i[s-1]<<24)>>>0}function r(){if(this.pos+8>this.len)throw u(this,8);return new h(e(this.buf,this.pos+=4),e(this.buf,this.pos+=4))}c.create=n(),c.prototype._slice=p.Array.prototype.subarray||p.Array.prototype.slice,c.prototype.uint32=(a=4294967295,function(){if(a=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(a=(a|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return a;if((this.pos+=5)>this.len)throw this.pos=this.len,u(this,10);return a}),c.prototype.int32=function(){return 0|this.uint32()},c.prototype.sint32=function(){var i=this.uint32();return i>>>1^-(1&i)|0},c.prototype.bool=function(){return this.uint32()!==0},c.prototype.fixed32=function(){if(this.pos+4>this.len)throw u(this,4);return e(this.buf,this.pos+=4)},c.prototype.sfixed32=function(){if(this.pos+4>this.len)throw u(this,4);return 0|e(this.buf,this.pos+=4)},c.prototype.float=function(){if(this.pos+4>this.len)throw u(this,4);var i=p.float.readFloatLE(this.buf,this.pos);return this.pos+=4,i},c.prototype.double=function(){if(this.pos+8>this.len)throw u(this,4);var i=p.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,i},c.prototype.bytes=function(){var i=this.uint32(),s=this.pos,f=this.pos+i;if(f>this.len)throw u(this,i);return this.pos+=i,Array.isArray(this.buf)?this.buf.slice(s,f):s===f?new this.buf.constructor(0):this._slice.call(this.buf,s,f)},c.prototype.string=function(){var i=this.bytes();return d.read(i,0,i.length)},c.prototype.skip=function(i){if(typeof i=="number"){if(this.pos+i>this.len)throw u(this,i);this.pos+=i}else do if(this.pos>=this.len)throw u(this);while(128&this.buf[this.pos++]);return this},c.prototype.skipType=function(i){switch(i){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(i=7&this.uint32())!=4;)this.skipType(i);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+i+" at offset "+this.pos)}return this},c._configure=function(i){m=i,c.create=n(),m._configure();var s=p.Long?"toLong":"toNumber";p.merge(c.prototype,{int64:function(){return t.call(this)[s](!1)},uint64:function(){return t.call(this)[s](!0)},sint64:function(){return t.call(this).zzDecode()[s](!1)},fixed64:function(){return r.call(this)[s](!0)},sfixed64:function(){return r.call(this)[s](!1)}})}},593:(R,l,b)=>{R.exports=h;var m=b(1408);(h.prototype=Object.create(m.prototype)).constructor=h;var p=b(9693);function h(d){m.call(this,d)}h._configure=function(){p.Buffer&&(h.prototype._slice=p.Buffer.prototype.slice)},h.prototype.string=function(){var d=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+d,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+d,this.len))},h._configure()},5054:R=>{R.exports={}},5994:(R,l,b)=>{l.Service=b(7948)},7948:(R,l,b)=>{R.exports=p;var m=b(9693);function p(h,d,u){if(typeof h!="function")throw TypeError("rpcImpl must be a function");m.EventEmitter.call(this),this.rpcImpl=h,this.requestDelimited=!!d,this.responseDelimited=!!u}(p.prototype=Object.create(m.EventEmitter.prototype)).constructor=p,p.prototype.rpcCall=function h(d,u,c,a,o){if(!a)throw TypeError("request must be specified");var n=this;if(!o)return m.asPromise(h,n,d,u,c,a);if(n.rpcImpl)try{return n.rpcImpl(d,u[n.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(t,e){if(t)return n.emit("error",t,d),o(t);if(e!==null){if(!(e instanceof c))try{e=c[n.responseDelimited?"decodeDelimited":"decode"](e)}catch(r){return n.emit("error",r,d),o(r)}return n.emit("data",e,d),o(null,e)}n.end(!0)})}catch(t){return n.emit("error",t,d),void setTimeout(function(){o(t)},0)}else setTimeout(function(){o(Error("already ended"))},0)},p.prototype.end=function(h){return this.rpcImpl&&(h||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(R,l,b)=>{R.exports=p;var m=b(9693);function p(c,a){this.lo=c>>>0,this.hi=a>>>0}var h=p.zero=new p(0,0);h.toNumber=function(){return 0},h.zzEncode=h.zzDecode=function(){return this},h.length=function(){return 1};var d=p.zeroHash="\0\0\0\0\0\0\0\0";p.fromNumber=function(c){if(c===0)return h;var a=c<0;a&&(c=-c);var o=c>>>0,n=(c-o)/4294967296>>>0;return a&&(n=~n>>>0,o=~o>>>0,++o>4294967295&&(o=0,++n>4294967295&&(n=0))),new p(o,n)},p.from=function(c){if(typeof c=="number")return p.fromNumber(c);if(m.isString(c)){if(!m.Long)return p.fromNumber(parseInt(c,10));c=m.Long.fromString(c)}return c.low||c.high?new p(c.low>>>0,c.high>>>0):h},p.prototype.toNumber=function(c){if(!c&&this.hi>>>31){var a=1+~this.lo>>>0,o=~this.hi>>>0;return a||(o=o+1>>>0),-(a+4294967296*o)}return this.lo+4294967296*this.hi},p.prototype.toLong=function(c){return m.Long?new m.Long(0|this.lo,0|this.hi,!!c):{low:0|this.lo,high:0|this.hi,unsigned:!!c}};var u=String.prototype.charCodeAt;p.fromHash=function(c){return c===d?h:new p((u.call(c,0)|u.call(c,1)<<8|u.call(c,2)<<16|u.call(c,3)<<24)>>>0,(u.call(c,4)|u.call(c,5)<<8|u.call(c,6)<<16|u.call(c,7)<<24)>>>0)},p.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},p.prototype.zzEncode=function(){var c=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^c)>>>0,this.lo=(this.lo<<1^c)>>>0,this},p.prototype.zzDecode=function(){var c=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^c)>>>0,this.hi=(this.hi>>>1^c)>>>0,this},p.prototype.length=function(){var c=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,o=this.hi>>>24;return o===0?a===0?c<16384?c<128?1:2:c<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:o<128?9:10}},9693:function(R,l,b){var m=l;function p(d,u,c){for(var a=Object.keys(u),o=0;o<a.length;++o)d[a[o]]!==void 0&&c||(d[a[o]]=u[a[o]]);return d}function h(d){function u(c,a){if(!(this instanceof u))return new u(c,a);Object.defineProperty(this,"message",{get:function(){return c}}),Error.captureStackTrace?Error.captureStackTrace(this,u):Object.defineProperty(this,"stack",{value:new Error().stack||""}),a&&p(this,a)}return u.prototype=Object.create(Error.prototype,{constructor:{value:u,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return d},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),u}m.asPromise=b(4537),m.base64=b(7419),m.EventEmitter=b(9211),m.float=b(945),m.inquire=b(7199),m.utf8=b(4997),m.pool=b(6662),m.LongBits=b(1945),m.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),m.global=m.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||this,m.emptyArray=Object.freeze?Object.freeze([]):[],m.emptyObject=Object.freeze?Object.freeze({}):{},m.isInteger=Number.isInteger||function(d){return typeof d=="number"&&isFinite(d)&&Math.floor(d)===d},m.isString=function(d){return typeof d=="string"||d instanceof String},m.isObject=function(d){return d&&typeof d=="object"},m.isset=m.isSet=function(d,u){var c=d[u];return!(c==null||!d.hasOwnProperty(u))&&(typeof c!="object"||(Array.isArray(c)?c.length:Object.keys(c).length)>0)},m.Buffer=function(){try{var d=m.inquire("buffer").Buffer;return d.prototype.utf8Write?d:null}catch{return null}}(),m._Buffer_from=null,m._Buffer_allocUnsafe=null,m.newBuffer=function(d){return typeof d=="number"?m.Buffer?m._Buffer_allocUnsafe(d):new m.Array(d):m.Buffer?m._Buffer_from(d):typeof Uint8Array>"u"?d:new Uint8Array(d)},m.Array=typeof Uint8Array<"u"?Uint8Array:Array,m.Long=m.global.dcodeIO&&m.global.dcodeIO.Long||m.global.Long||m.inquire("long"),m.key2Re=/^true|false|0|1$/,m.key32Re=/^-?(?:0|[1-9][0-9]*)$/,m.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,m.longToHash=function(d){return d?m.LongBits.from(d).toHash():m.LongBits.zeroHash},m.longFromHash=function(d,u){var c=m.LongBits.fromHash(d);return m.Long?m.Long.fromBits(c.lo,c.hi,u):c.toNumber(!!u)},m.merge=p,m.lcFirst=function(d){return d.charAt(0).toLowerCase()+d.substring(1)},m.newError=h,m.ProtocolError=h("ProtocolError"),m.oneOfGetter=function(d){for(var u={},c=0;c<d.length;++c)u[d[c]]=1;return function(){for(var a=Object.keys(this),o=a.length-1;o>-1;--o)if(u[a[o]]===1&&this[a[o]]!==void 0&&this[a[o]]!==null)return a[o]}},m.oneOfSetter=function(d){return function(u){for(var c=0;c<d.length;++c)d[c]!==u&&delete this[d[c]]}},m.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},m._configure=function(){var d=m.Buffer;d?(m._Buffer_from=d.from!==Uint8Array.from&&d.from||function(u,c){return new d(u,c)},m._Buffer_allocUnsafe=d.allocUnsafe||function(u){return new d(u)}):m._Buffer_from=m._Buffer_allocUnsafe=null}},1173:(R,l,b)=>{R.exports=n;var m,p=b(9693),h=p.LongBits,d=p.base64,u=p.utf8;function c(g,y,v){this.fn=g,this.len=y,this.next=void 0,this.val=v}function a(){}function o(g){this.head=g.head,this.tail=g.tail,this.len=g.len,this.next=g.states}function n(){this.len=0,this.head=new c(a,0,0),this.tail=this.head,this.states=null}var t=function(){return p.Buffer?function(){return(n.create=function(){return new m})()}:function(){return new n}};function e(g,y,v){y[v]=255&g}function r(g,y){this.len=g,this.next=void 0,this.val=y}function i(g,y,v){for(;g.hi;)y[v++]=127&g.lo|128,g.lo=(g.lo>>>7|g.hi<<25)>>>0,g.hi>>>=7;for(;g.lo>127;)y[v++]=127&g.lo|128,g.lo=g.lo>>>7;y[v++]=g.lo}function s(g,y,v){y[v]=255&g,y[v+1]=g>>>8&255,y[v+2]=g>>>16&255,y[v+3]=g>>>24}n.create=t(),n.alloc=function(g){return new p.Array(g)},p.Array!==Array&&(n.alloc=p.pool(n.alloc,p.Array.prototype.subarray)),n.prototype._push=function(g,y,v){return this.tail=this.tail.next=new c(g,y,v),this.len+=y,this},r.prototype=Object.create(c.prototype),r.prototype.fn=function(g,y,v){for(;g>127;)y[v++]=127&g|128,g>>>=7;y[v]=g},n.prototype.uint32=function(g){return this.len+=(this.tail=this.tail.next=new r((g>>>=0)<128?1:g<16384?2:g<2097152?3:g<268435456?4:5,g)).len,this},n.prototype.int32=function(g){return g<0?this._push(i,10,h.fromNumber(g)):this.uint32(g)},n.prototype.sint32=function(g){return this.uint32((g<<1^g>>31)>>>0)},n.prototype.uint64=function(g){var y=h.from(g);return this._push(i,y.length(),y)},n.prototype.int64=n.prototype.uint64,n.prototype.sint64=function(g){var y=h.from(g).zzEncode();return this._push(i,y.length(),y)},n.prototype.bool=function(g){return this._push(e,1,g?1:0)},n.prototype.fixed32=function(g){return this._push(s,4,g>>>0)},n.prototype.sfixed32=n.prototype.fixed32,n.prototype.fixed64=function(g){var y=h.from(g);return this._push(s,4,y.lo)._push(s,4,y.hi)},n.prototype.sfixed64=n.prototype.fixed64,n.prototype.float=function(g){return this._push(p.float.writeFloatLE,4,g)},n.prototype.double=function(g){return this._push(p.float.writeDoubleLE,8,g)};var f=p.Array.prototype.set?function(g,y,v){y.set(g,v)}:function(g,y,v){for(var w=0;w<g.length;++w)y[v+w]=g[w]};n.prototype.bytes=function(g){var y=g.length>>>0;if(!y)return this._push(e,1,0);if(p.isString(g)){var v=n.alloc(y=d.length(g));d.decode(g,v,0),g=v}return this.uint32(y)._push(f,y,g)},n.prototype.string=function(g){var y=u.length(g);return y?this.uint32(y)._push(u.write,y,g):this._push(e,1,0)},n.prototype.fork=function(){return this.states=new o(this),this.head=this.tail=new c(a,0,0),this.len=0,this},n.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new c(a,0,0),this.len=0),this},n.prototype.ldelim=function(){var g=this.head,y=this.tail,v=this.len;return this.reset().uint32(v),v&&(this.tail.next=g.next,this.tail=y,this.len+=v),this},n.prototype.finish=function(){for(var g=this.head.next,y=this.constructor.alloc(this.len),v=0;g;)g.fn(g.val,y,v),v+=g.len,g=g.next;return y},n._configure=function(g){m=g,n.create=t(),m._configure()}},3155:(R,l,b)=>{R.exports=h;var m=b(1173);(h.prototype=Object.create(m.prototype)).constructor=h;var p=b(9693);function h(){m.call(this)}function d(u,c,a){u.length<40?p.utf8.write(u,c,a):c.utf8Write?c.utf8Write(u,a):c.write(u,a)}h._configure=function(){h.alloc=p._Buffer_allocUnsafe,h.writeBytesBuffer=p.Buffer&&p.Buffer.prototype instanceof Uint8Array&&p.Buffer.prototype.set.name==="set"?function(u,c,a){c.set(u,a)}:function(u,c,a){if(u.copy)u.copy(c,a,0,u.length);else for(var o=0;o<u.length;)c[a++]=u[o++]}},h.prototype.bytes=function(u){p.isString(u)&&(u=p._Buffer_from(u,"base64"));var c=u.length>>>0;return this.uint32(c),c&&this._push(h.writeBytesBuffer,c,u),this},h.prototype.string=function(u){var c=p.Buffer.byteLength(u);return this.uint32(c),c&&this._push(d,c,u),this},h._configure()},4154:R=>{R.exports=`"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},685:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.resolveBackend=l.registerBackend=void 0;const b={},m=[];l.registerBackend=(p,h,d)=>{if(!h||typeof h.init!="function"||typeof h.createSessionHandler!="function")throw new TypeError("not a valid backend");{const u=b[p];if(u===void 0)b[p]={backend:h,priority:d};else{if(u.priority>d)return;if(u.priority===d&&u.backend!==h)throw new Error(`cannot register backend "${p}" using priority ${d}`)}if(d>=0){const c=m.indexOf(p);c!==-1&&m.splice(c,1);for(let a=0;a<m.length;a++)if(b[m[a]].priority<=d)return void m.splice(a,0,p);m.push(p)}}},l.resolveBackend=async p=>{const h=p.length===0?m:p,d=[];for(const u of h){const c=b[u];if(c){if(c.initialized)return c.backend;if(c.aborted)continue;const a=!!c.initPromise;try{return a||(c.initPromise=c.backend.init()),await c.initPromise,c.initialized=!0,c.backend}catch(o){a||d.push({name:u,err:o}),c.aborted=!0}finally{delete c.initPromise}}}throw new Error(`no available backend found. ERR: ${d.map(u=>`[${u.name}] ${u.err}`).join(", ")}`)}},4798:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.registerBackend=void 0;var m=b(685);Object.defineProperty(l,"registerBackend",{enumerable:!0,get:function(){return m.registerBackend}})},3121:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.env=void 0;const m=b(9104);let p="warning";l.env={wasm:{},webgl:{},webgpu:{},versions:{common:m.version},set logLevel(h){if(h!==void 0){if(typeof h!="string"||["verbose","info","warning","error","fatal"].indexOf(h)===-1)throw new Error(`Unsupported logging level: ${h}`);p=h}},get logLevel(){return p}},Object.defineProperty(l.env,"logLevel",{enumerable:!0})},2457:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.env=void 0;const m=b(3121);l.env=m.env},2235:function(R,l,b){var m=this&&this.__createBinding||(Object.create?function(h,d,u,c){c===void 0&&(c=u);var a=Object.getOwnPropertyDescriptor(d,u);a&&!("get"in a?!d.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return d[u]}}),Object.defineProperty(h,c,a)}:function(h,d,u,c){c===void 0&&(c=u),h[c]=d[u]}),p=this&&this.__exportStar||function(h,d){for(var u in h)u==="default"||Object.prototype.hasOwnProperty.call(d,u)||m(d,h,u)};Object.defineProperty(l,"__esModule",{value:!0}),p(b(4798),l),p(b(2457),l),p(b(3974),l),p(b(963),l),p(b(7852),l)},8036:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.InferenceSession=void 0;const m=b(685),p=b(963);class h{constructor(u){this.handler=u}async run(u,c,a){const o={};let n={};if(typeof u!="object"||u===null||u instanceof p.Tensor||Array.isArray(u))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let t=!0;if(typeof c=="object"){if(c===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(c instanceof p.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(c)){if(c.length===0)throw new TypeError("'fetches' cannot be an empty array.");t=!1;for(const i of c){if(typeof i!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(i)===-1)throw new RangeError(`'fetches' contains invalid output name: ${i}.`);o[i]=null}if(typeof a=="object"&&a!==null)n=a;else if(a!==void 0)throw new TypeError("'options' must be an object.")}else{let i=!1;const s=Object.getOwnPropertyNames(c);for(const f of this.outputNames)if(s.indexOf(f)!==-1){const g=c[f];(g===null||g instanceof p.Tensor)&&(i=!0,t=!1,o[f]=g)}if(i){if(typeof a=="object"&&a!==null)n=a;else if(a!==void 0)throw new TypeError("'options' must be an object.")}else n=c}}else if(c!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const i of this.inputNames)if(u[i]===void 0)throw new Error(`input '${i}' is missing in 'feeds'.`);if(t)for(const i of this.outputNames)o[i]=null;const e=await this.handler.run(u,o,n),r={};for(const i in e)Object.hasOwnProperty.call(e,i)&&(r[i]=new p.Tensor(e[i].type,e[i].data,e[i].dims));return r}async release(){return this.handler.dispose()}static async create(u,c,a,o){let n,t={};if(typeof u=="string"){if(n=u,typeof c=="object"&&c!==null)t=c;else if(c!==void 0)throw new TypeError("'options' must be an object.")}else if(u instanceof Uint8Array){if(n=u,typeof c=="object"&&c!==null)t=c;else if(c!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(u instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&u instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const s=u;let f=0,g=u.byteLength;if(typeof c=="object"&&c!==null)t=c;else if(typeof c=="number"){if(f=c,!Number.isSafeInteger(f))throw new RangeError("'byteOffset' must be an integer.");if(f<0||f>=s.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${s.byteLength}).`);if(g=u.byteLength-f,typeof a=="number"){if(g=a,!Number.isSafeInteger(g))throw new RangeError("'byteLength' must be an integer.");if(g<=0||f+g>s.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${s.byteLength-f}].`);if(typeof o=="object"&&o!==null)t=o;else if(o!==void 0)throw new TypeError("'options' must be an object.")}else if(a!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(c!==void 0)throw new TypeError("'options' must be an object.");n=new Uint8Array(s,f,g)}}const e=(t.executionProviders||[]).map(s=>typeof s=="string"?s:s.name),r=await(0,m.resolveBackend)(e),i=await r.createSessionHandler(n,t);return new h(i)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}l.InferenceSession=h},3974:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.InferenceSession=void 0;const m=b(8036);l.InferenceSession=m.InferenceSession},7852:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0})},2350:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.tensorToImageData=l.tensorToDataURL=void 0,l.tensorToDataURL=(b,m)=>{const p=document.createElement("canvas");p.width=b.dims[3],p.height=b.dims[2];const h=p.getContext("2d");if(h!=null){let d,u;(m==null?void 0:m.tensorLayout)!==void 0&&m.tensorLayout==="NHWC"?(d=b.dims[2],u=b.dims[3]):(d=b.dims[3],u=b.dims[2]);const c=(m==null?void 0:m.format)!==void 0?m.format:"RGB",a=m==null?void 0:m.norm;let o,n;a===void 0||a.mean===void 0?o=[255,255,255,255]:typeof a.mean=="number"?o=[a.mean,a.mean,a.mean,a.mean]:(o=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(o[3]=a.mean[3])),a===void 0||a.bias===void 0?n=[0,0,0,0]:typeof a.bias=="number"?n=[a.bias,a.bias,a.bias,a.bias]:(n=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(n[3]=a.bias[3]));const t=u*d;let e=0,r=t,i=2*t,s=-1;c==="RGBA"?(e=0,r=t,i=2*t,s=3*t):c==="RGB"?(e=0,r=t,i=2*t):c==="RBG"&&(e=0,i=t,r=2*t);for(let f=0;f<u;f++)for(let g=0;g<d;g++){const y=(b.data[e++]-n[0])*o[0],v=(b.data[r++]-n[1])*o[1],w=(b.data[i++]-n[2])*o[2],T=s===-1?255:(b.data[s++]-n[3])*o[3];h.fillStyle="rgba("+y+","+v+","+w+","+T+")",h.fillRect(g,f,1,1)}return p.toDataURL()}throw new Error("Can not access image data")},l.tensorToImageData=(b,m)=>{const p=document.createElement("canvas").getContext("2d");let h;if(p==null)throw new Error("Can not access image data");{let d,u,c;(m==null?void 0:m.tensorLayout)!==void 0&&m.tensorLayout==="NHWC"?(d=b.dims[2],u=b.dims[1],c=b.dims[3]):(d=b.dims[3],u=b.dims[2],c=b.dims[1]);const a=m!==void 0&&m.format!==void 0?m.format:"RGB",o=m==null?void 0:m.norm;let n,t;o===void 0||o.mean===void 0?n=[255,255,255,255]:typeof o.mean=="number"?n=[o.mean,o.mean,o.mean,o.mean]:(n=[o.mean[0],o.mean[1],o.mean[2],255],o.mean[3]!==void 0&&(n[3]=o.mean[3])),o===void 0||o.bias===void 0?t=[0,0,0,0]:typeof o.bias=="number"?t=[o.bias,o.bias,o.bias,o.bias]:(t=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(t[3]=o.bias[3]));const e=u*d;if(m!==void 0&&(m.format!==void 0&&c===4&&m.format!=="RGBA"||c===3&&m.format!=="RGB"&&m.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const r=4;let i=0,s=1,f=2,g=3,y=0,v=e,w=2*e,T=-1;a==="RGBA"?(y=0,v=e,w=2*e,T=3*e):a==="RGB"?(y=0,v=e,w=2*e):a==="RBG"&&(y=0,w=e,v=2*e),h=p.createImageData(d,u);for(let x=0;x<u*d;i+=r,s+=r,f+=r,g+=r,x++)h.data[i]=(b.data[y++]-t[0])*n[0],h.data[s]=(b.data[v++]-t[1])*n[1],h.data[f]=(b.data[w++]-t[2])*n[2],h.data[g]=T===-1?255:(b.data[T++]-t[3])*n[3]}return h}},4866:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.tensorFromImage=l.bufferToTensor=void 0;const m=b(963);l.bufferToTensor=(p,h)=>{if(p===void 0)throw new Error("Image buffer must be defined");if(h.height===void 0||h.width===void 0)throw new Error("Image height and width must be defined");if(h.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:d,width:u}=h,c=h.norm??{mean:255,bias:0};let a,o;a=typeof c.mean=="number"?[c.mean,c.mean,c.mean,c.mean]:[c.mean[0],c.mean[1],c.mean[2],c.mean[3]??255],o=typeof c.bias=="number"?[c.bias,c.bias,c.bias,c.bias]:[c.bias[0],c.bias[1],c.bias[2],c.bias[3]??0];const n=h.format!==void 0?h.format:"RGBA",t=h.tensorFormat!==void 0&&h.tensorFormat!==void 0?h.tensorFormat:"RGB",e=d*u,r=t==="RGBA"?new Float32Array(4*e):new Float32Array(3*e);let i=4,s=0,f=1,g=2,y=3,v=0,w=e,T=2*e,x=-1;n==="RGB"&&(i=3,s=0,f=1,g=2,y=-1),t==="RGBA"?x=3*e:t==="RBG"?(v=0,T=e,w=2*e):t==="BGR"&&(T=0,w=e,v=2*e);for(let A=0;A<e;A++,s+=i,g+=i,f+=i,y+=i)r[v++]=(p[s]+o[0])/a[0],r[w++]=(p[f]+o[1])/a[1],r[T++]=(p[g]+o[2])/a[2],x!==-1&&y!==-1&&(r[x++]=(p[y]+o[3])/a[3]);return t==="RGBA"?new m.Tensor("float32",r,[1,4,d,u]):new m.Tensor("float32",r,[1,3,d,u])},l.tensorFromImage=async(p,h)=>{const d=typeof HTMLImageElement<"u"&&p instanceof HTMLImageElement,u=typeof ImageData<"u"&&p instanceof ImageData,c=typeof ImageBitmap<"u"&&p instanceof ImageBitmap,a=typeof p=="string";let o,n=h??{};if(d){const t=document.createElement("canvas");t.width=p.width,t.height=p.height;const e=t.getContext("2d");if(e==null)throw new Error("Can not access image data");{let r=p.height,i=p.width;if(h!==void 0&&h.resizedHeight!==void 0&&h.resizedWidth!==void 0&&(r=h.resizedHeight,i=h.resizedWidth),h!==void 0){if(n=h,h.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=r,n.width=i}else n.tensorFormat="RGBA",n.height=r,n.width=i;e.drawImage(p,0,0),o=e.getImageData(0,0,i,r).data}}else{if(!u){if(c){if(h===void 0)throw new Error("Please provide image config with format for Imagebitmap");const t=document.createElement("canvas");t.width=p.width,t.height=p.height;const e=t.getContext("2d");if(e!=null){const r=p.height,i=p.width;return e.drawImage(p,0,0,i,r),o=e.getImageData(0,0,i,r).data,n.height=r,n.width=i,(0,l.bufferToTensor)(o,n)}throw new Error("Can not access image data")}if(a)return new Promise((t,e)=>{const r=document.createElement("canvas"),i=r.getContext("2d");if(!p||!i)return e();const s=new Image;s.crossOrigin="Anonymous",s.src=p,s.onload=()=>{r.width=s.width,r.height=s.height,i.drawImage(s,0,0,r.width,r.height);const f=i.getImageData(0,0,r.width,r.height);n.height=r.height,n.width=r.width,t((0,l.bufferToTensor)(f.data,n))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let t,e;if(h!==void 0&&h.resizedWidth!==void 0&&h.resizedHeight!==void 0?(t=h.resizedHeight,e=h.resizedWidth):(t=p.height,e=p.width),h!==void 0&&(n=h),n.format="RGBA",n.height=t,n.width=e,h!==void 0){const r=document.createElement("canvas");r.width=e,r.height=t;const i=r.getContext("2d");if(i==null)throw new Error("Can not access image data");i.putImageData(p,0,0),o=i.getImageData(0,0,e,t).data}else o=p.data}}if(o!==void 0)return(0,l.bufferToTensor)(o,n);throw new Error("Input data provided is not supported - aborted tensor creation")}},5957:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.Tensor=void 0;const m=b(2350),p=b(4866),h=b(106),d=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),u=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let c=!1;l.Tensor=class{constructor(a,o,n){let t,e,r;if((()=>{if(!c){c=!0;const s=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",f=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";s&&(d.set("int64",BigInt64Array),u.set(BigInt64Array,"int64")),f&&(d.set("uint64",BigUint64Array),u.set(BigUint64Array,"uint64"))}})(),typeof a=="string")if(t=a,r=n,a==="string"){if(!Array.isArray(o))throw new TypeError("A string tensor's data must be a string array.");e=o}else{const s=d.get(a);if(s===void 0)throw new TypeError(`Unsupported tensor type: ${a}.`);if(Array.isArray(o)){if(a==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e=a==="uint64"||a==="int64"?s.from(o,BigInt):s.from(o)}else{if(!(o instanceof s))throw new TypeError(`A ${t} tensor's data must be type of ${s}`);e=o}}else if(r=o,Array.isArray(a)){if(a.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const s=typeof a[0];if(s==="string")t="string",e=a;else{if(s!=="boolean")throw new TypeError(`Invalid element type of data array: ${s}.`);t="bool",e=Uint8Array.from(a)}}else{const s=u.get(a.constructor);if(s===void 0)throw new TypeError(`Unsupported type for tensor data: ${a.constructor}.`);t=s,e=a}if(r===void 0)r=[e.length];else if(!Array.isArray(r))throw new TypeError("A tensor's dims must be a number array");const i=(0,h.calculateSize)(r);if(i!==e.length)throw new Error(`Tensor's size(${i}) does not match data length(${e.length}).`);this.dims=r,this.type=t,this.data=e,this.size=i}static async fromImage(a,o){return(0,p.tensorFromImage)(a,o)}toDataURL(a){return(0,m.tensorToDataURL)(this,a)}toImageData(a){return(0,m.tensorToImageData)(this,a)}reshape(a){return(0,h.tensorReshape)(this,a)}}},106:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.tensorReshape=l.calculateSize=void 0;const m=b(963);l.calculateSize=p=>{let h=1;for(let d=0;d<p.length;d++){const u=p[d];if(typeof u!="number"||!Number.isSafeInteger(u))throw new TypeError(`dims[${d}] must be an integer, got: ${u}`);if(u<0)throw new RangeError(`dims[${d}] must be a non-negative integer, got: ${u}`);h*=u}return h},l.tensorReshape=(p,h)=>new m.Tensor(p.type,p.data,h)},963:(R,l,b)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.Tensor=void 0;const m=b(5957);l.Tensor=m.Tensor},9104:(R,l)=>{Object.defineProperty(l,"__esModule",{value:!0}),l.version=void 0,l.version="1.16.3"},1583:(R,l)=>{var b,m=function(p){Object.defineProperty(p,"__esModule",{value:!0}),p.default=void 0;var h=null;try{h=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function d(O,E,F){this.low=0|O,this.high=0|E,this.unsigned=!!F}function u(O){return(O&&O.__isLong__)===!0}function c(O){var E=Math.clz32(O&-O);return O?31-E:E}d.prototype.__isLong__,Object.defineProperty(d.prototype,"__isLong__",{value:!0}),d.isLong=u;var a={},o={};function n(O,E){var F,q,H;return E?(H=0<=(O>>>=0)&&O<256)&&(q=o[O])?q:(F=e(O,0,!0),H&&(o[O]=F),F):(H=-128<=(O|=0)&&O<128)&&(q=a[O])?q:(F=e(O,O<0?-1:0,!1),H&&(a[O]=F),F)}function t(O,E){if(isNaN(O))return E?T:w;if(E){if(O<0)return T;if(O>=g)return j}else{if(O<=-y)return M;if(O+1>=y)return $}return O<0?t(-O,E).neg():e(O%f|0,O/f|0,E)}function e(O,E,F){return new d(O,E,F)}d.fromInt=n,d.fromNumber=t,d.fromBits=e;var r=Math.pow;function i(O,E,F){if(O.length===0)throw Error("empty string");if(typeof E=="number"?(F=E,E=!1):E=!!E,O==="NaN"||O==="Infinity"||O==="+Infinity"||O==="-Infinity")return E?T:w;if((F=F||10)<2||36<F)throw RangeError("radix");var q;if((q=O.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return i(O.substring(1),E,F).neg();for(var H=t(r(F,8)),K=w,X=0;X<O.length;X+=8){var J=Math.min(8,O.length-X),tt=parseInt(O.substring(X,X+J),F);if(J<8){var nt=t(r(F,J));K=K.mul(nt).add(t(tt))}else K=(K=K.mul(H)).add(t(tt))}return K.unsigned=E,K}function s(O,E){return typeof O=="number"?t(O,E):typeof O=="string"?i(O,E):e(O.low,O.high,typeof E=="boolean"?E:O.unsigned)}d.fromString=i,d.fromValue=s;var f=4294967296,g=f*f,y=g/2,v=n(1<<24),w=n(0);d.ZERO=w;var T=n(0,!0);d.UZERO=T;var x=n(1);d.ONE=x;var A=n(1,!0);d.UONE=A;var D=n(-1);d.NEG_ONE=D;var $=e(-1,2147483647,!1);d.MAX_VALUE=$;var j=e(-1,-1,!0);d.MAX_UNSIGNED_VALUE=j;var M=e(0,-2147483648,!1);d.MIN_VALUE=M;var S=d.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},S.toString=function(O){if((O=O||10)<2||36<O)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(M)){var E=t(O),F=this.div(E),q=F.mul(E).sub(this);return F.toString(O)+q.toInt().toString(O)}return"-"+this.neg().toString(O)}for(var H=t(r(O,6),this.unsigned),K=this,X="";;){var J=K.div(H),tt=(K.sub(J.mul(H)).toInt()>>>0).toString(O);if((K=J).isZero())return tt+X;for(;tt.length<6;)tt="0"+tt;X=""+tt+X}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(M)?64:this.neg().getNumBitsAbs();for(var O=this.high!=0?this.high:this.low,E=31;E>0&&!(O&1<<E);E--);return this.high!=0?E+33:E+1},S.isZero=function(){return this.high===0&&this.low===0},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return(1&this.low)==1},S.isEven=function(){return(1&this.low)==0},S.equals=function(O){return u(O)||(O=s(O)),(this.unsigned===O.unsigned||this.high>>>31!=1||O.high>>>31!=1)&&this.high===O.high&&this.low===O.low},S.eq=S.equals,S.notEquals=function(O){return!this.eq(O)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(O){return this.comp(O)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(O){return this.comp(O)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(O){return this.comp(O)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(O){return this.comp(O)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(O){if(u(O)||(O=s(O)),this.eq(O))return 0;var E=this.isNegative(),F=O.isNegative();return E&&!F?-1:!E&&F?1:this.unsigned?O.high>>>0>this.high>>>0||O.high===this.high&&O.low>>>0>this.low>>>0?-1:1:this.sub(O).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(M)?M:this.not().add(x)},S.neg=S.negate,S.add=function(O){u(O)||(O=s(O));var E=this.high>>>16,F=65535&this.high,q=this.low>>>16,H=65535&this.low,K=O.high>>>16,X=65535&O.high,J=O.low>>>16,tt=0,nt=0,rt=0,it=0;return rt+=(it+=H+(65535&O.low))>>>16,nt+=(rt+=q+J)>>>16,tt+=(nt+=F+X)>>>16,tt+=E+K,e((rt&=65535)<<16|(it&=65535),(tt&=65535)<<16|(nt&=65535),this.unsigned)},S.subtract=function(O){return u(O)||(O=s(O)),this.add(O.neg())},S.sub=S.subtract,S.multiply=function(O){if(this.isZero())return this;if(u(O)||(O=s(O)),h)return e(h.mul(this.low,this.high,O.low,O.high),h.get_high(),this.unsigned);if(O.isZero())return this.unsigned?T:w;if(this.eq(M))return O.isOdd()?M:w;if(O.eq(M))return this.isOdd()?M:w;if(this.isNegative())return O.isNegative()?this.neg().mul(O.neg()):this.neg().mul(O).neg();if(O.isNegative())return this.mul(O.neg()).neg();if(this.lt(v)&&O.lt(v))return t(this.toNumber()*O.toNumber(),this.unsigned);var E=this.high>>>16,F=65535&this.high,q=this.low>>>16,H=65535&this.low,K=O.high>>>16,X=65535&O.high,J=O.low>>>16,tt=65535&O.low,nt=0,rt=0,it=0,ut=0;return it+=(ut+=H*tt)>>>16,rt+=(it+=q*tt)>>>16,it&=65535,rt+=(it+=H*J)>>>16,nt+=(rt+=F*tt)>>>16,rt&=65535,nt+=(rt+=q*J)>>>16,rt&=65535,nt+=(rt+=H*X)>>>16,nt+=E*tt+F*J+q*X+H*K,e((it&=65535)<<16|(ut&=65535),(nt&=65535)<<16|(rt&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(O){if(u(O)||(O=s(O)),O.isZero())throw Error("division by zero");var E,F,q;if(h)return this.unsigned||this.high!==-2147483648||O.low!==-1||O.high!==-1?e((this.unsigned?h.div_u:h.div_s)(this.low,this.high,O.low,O.high),h.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?T:w;if(this.unsigned){if(O.unsigned||(O=O.toUnsigned()),O.gt(this))return T;if(O.gt(this.shru(1)))return A;q=T}else{if(this.eq(M))return O.eq(x)||O.eq(D)?M:O.eq(M)?x:(E=this.shr(1).div(O).shl(1)).eq(w)?O.isNegative()?x:D:(F=this.sub(O.mul(E)),q=E.add(F.div(O)));if(O.eq(M))return this.unsigned?T:w;if(this.isNegative())return O.isNegative()?this.neg().div(O.neg()):this.neg().div(O).neg();if(O.isNegative())return this.div(O.neg()).neg();q=w}for(F=this;F.gte(O);){E=Math.max(1,Math.floor(F.toNumber()/O.toNumber()));for(var H=Math.ceil(Math.log(E)/Math.LN2),K=H<=48?1:r(2,H-48),X=t(E),J=X.mul(O);J.isNegative()||J.gt(F);)J=(X=t(E-=K,this.unsigned)).mul(O);X.isZero()&&(X=x),q=q.add(X),F=F.sub(J)}return q},S.div=S.divide,S.modulo=function(O){return u(O)||(O=s(O)),h?e((this.unsigned?h.rem_u:h.rem_s)(this.low,this.high,O.low,O.high),h.get_high(),this.unsigned):this.sub(this.div(O).mul(O))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return e(~this.low,~this.high,this.unsigned)},S.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},S.clz=S.countLeadingZeros,S.countTrailingZeros=function(){return this.low?c(this.low):c(this.high)+32},S.ctz=S.countTrailingZeros,S.and=function(O){return u(O)||(O=s(O)),e(this.low&O.low,this.high&O.high,this.unsigned)},S.or=function(O){return u(O)||(O=s(O)),e(this.low|O.low,this.high|O.high,this.unsigned)},S.xor=function(O){return u(O)||(O=s(O)),e(this.low^O.low,this.high^O.high,this.unsigned)},S.shiftLeft=function(O){return u(O)&&(O=O.toInt()),(O&=63)==0?this:O<32?e(this.low<<O,this.high<<O|this.low>>>32-O,this.unsigned):e(0,this.low<<O-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(O){return u(O)&&(O=O.toInt()),(O&=63)==0?this:O<32?e(this.low>>>O|this.high<<32-O,this.high>>O,this.unsigned):e(this.high>>O-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(O){return u(O)&&(O=O.toInt()),(O&=63)==0?this:O<32?e(this.low>>>O|this.high<<32-O,this.high>>>O,this.unsigned):e(O===32?this.high:this.high>>>O-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.rotateLeft=function(O){var E;return u(O)&&(O=O.toInt()),(O&=63)==0?this:O===32?e(this.high,this.low,this.unsigned):O<32?(E=32-O,e(this.low<<O|this.high>>>E,this.high<<O|this.low>>>E,this.unsigned)):(E=32-(O-=32),e(this.high<<O|this.low>>>E,this.low<<O|this.high>>>E,this.unsigned))},S.rotl=S.rotateLeft,S.rotateRight=function(O){var E;return u(O)&&(O=O.toInt()),(O&=63)==0?this:O===32?e(this.high,this.low,this.unsigned):O<32?(E=32-O,e(this.high<<E|this.low>>>O,this.low<<E|this.high>>>O,this.unsigned)):(E=32-(O-=32),e(this.low<<E|this.high>>>O,this.high<<E|this.low>>>O,this.unsigned))},S.rotr=S.rotateRight,S.toSigned=function(){return this.unsigned?e(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:e(this.low,this.high,!0)},S.toBytes=function(O){return O?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var O=this.high,E=this.low;return[255&E,E>>>8&255,E>>>16&255,E>>>24,255&O,O>>>8&255,O>>>16&255,O>>>24]},S.toBytesBE=function(){var O=this.high,E=this.low;return[O>>>24,O>>>16&255,O>>>8&255,255&O,E>>>24,E>>>16&255,E>>>8&255,255&E]},d.fromBytes=function(O,E,F){return F?d.fromBytesLE(O,E):d.fromBytesBE(O,E)},d.fromBytesLE=function(O,E){return new d(O[0]|O[1]<<8|O[2]<<16|O[3]<<24,O[4]|O[5]<<8|O[6]<<16|O[7]<<24,E)},d.fromBytesBE=function(O,E){return new d(O[4]<<24|O[5]<<16|O[6]<<8|O[7],O[0]<<24|O[1]<<16|O[2]<<8|O[3],E)};var U=d;return p.default=U,"default"in p?p.default:p}({});(b=(function(){return m}).apply(l,[]))===void 0||(R.exports=b)},5686:(R,l,b)=>{b.r(l),b.d(l,{flatbuffers:()=>m});var m={};m.Offset,m.Table,m.SIZEOF_SHORT=2,m.SIZEOF_INT=4,m.FILE_IDENTIFIER_LENGTH=4,m.SIZE_PREFIX_LENGTH=4,m.Encoding={UTF8_BYTES:1,UTF16_STRING:2},m.int32=new Int32Array(2),m.float32=new Float32Array(m.int32.buffer),m.float64=new Float64Array(m.int32.buffer),m.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,m.Long=function(p,h){this.low=0|p,this.high=0|h},m.Long.create=function(p,h){return p==0&&h==0?m.Long.ZERO:new m.Long(p,h)},m.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},m.Long.prototype.equals=function(p){return this.low==p.low&&this.high==p.high},m.Long.ZERO=new m.Long(0,0),m.Builder=function(p){if(p)h=p;else var h=1024;this.bb=m.ByteBuffer.allocate(h),this.space=h,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.forceDefaults=function(p){this.force_defaults=p},m.Builder.prototype.dataBuffer=function(){return this.bb},m.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},m.Builder.prototype.prep=function(p,h){p>this.minalign&&(this.minalign=p);for(var d=1+~(this.bb.capacity()-this.space+h)&p-1;this.space<d+p+h;){var u=this.bb.capacity();this.bb=m.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-u}this.pad(d)},m.Builder.prototype.pad=function(p){for(var h=0;h<p;h++)this.bb.writeInt8(--this.space,0)},m.Builder.prototype.writeInt8=function(p){this.bb.writeInt8(this.space-=1,p)},m.Builder.prototype.writeInt16=function(p){this.bb.writeInt16(this.space-=2,p)},m.Builder.prototype.writeInt32=function(p){this.bb.writeInt32(this.space-=4,p)},m.Builder.prototype.writeInt64=function(p){this.bb.writeInt64(this.space-=8,p)},m.Builder.prototype.writeFloat32=function(p){this.bb.writeFloat32(this.space-=4,p)},m.Builder.prototype.writeFloat64=function(p){this.bb.writeFloat64(this.space-=8,p)},m.Builder.prototype.addInt8=function(p){this.prep(1,0),this.writeInt8(p)},m.Builder.prototype.addInt16=function(p){this.prep(2,0),this.writeInt16(p)},m.Builder.prototype.addInt32=function(p){this.prep(4,0),this.writeInt32(p)},m.Builder.prototype.addInt64=function(p){this.prep(8,0),this.writeInt64(p)},m.Builder.prototype.addFloat32=function(p){this.prep(4,0),this.writeFloat32(p)},m.Builder.prototype.addFloat64=function(p){this.prep(8,0),this.writeFloat64(p)},m.Builder.prototype.addFieldInt8=function(p,h,d){(this.force_defaults||h!=d)&&(this.addInt8(h),this.slot(p))},m.Builder.prototype.addFieldInt16=function(p,h,d){(this.force_defaults||h!=d)&&(this.addInt16(h),this.slot(p))},m.Builder.prototype.addFieldInt32=function(p,h,d){(this.force_defaults||h!=d)&&(this.addInt32(h),this.slot(p))},m.Builder.prototype.addFieldInt64=function(p,h,d){!this.force_defaults&&h.equals(d)||(this.addInt64(h),this.slot(p))},m.Builder.prototype.addFieldFloat32=function(p,h,d){(this.force_defaults||h!=d)&&(this.addFloat32(h),this.slot(p))},m.Builder.prototype.addFieldFloat64=function(p,h,d){(this.force_defaults||h!=d)&&(this.addFloat64(h),this.slot(p))},m.Builder.prototype.addFieldOffset=function(p,h,d){(this.force_defaults||h!=d)&&(this.addOffset(h),this.slot(p))},m.Builder.prototype.addFieldStruct=function(p,h,d){h!=d&&(this.nested(h),this.slot(p))},m.Builder.prototype.nested=function(p){if(p!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},m.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},m.Builder.prototype.slot=function(p){this.vtable[p]=this.offset()},m.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},m.Builder.growByteBuffer=function(p){var h=p.capacity();if(3221225472&h)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var d=h<<1,u=m.ByteBuffer.allocate(d);return u.setPosition(d-h),u.bytes().set(p.bytes(),d-h),u},m.Builder.prototype.addOffset=function(p){this.prep(m.SIZEOF_INT,0),this.writeInt32(this.offset()-p+m.SIZEOF_INT)},m.Builder.prototype.startObject=function(p){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=p;for(var h=0;h<p;h++)this.vtable[h]=0;this.isNested=!0,this.object_start=this.offset()},m.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var p=this.offset(),h=this.vtable_in_use-1;h>=0&&this.vtable[h]==0;h--);for(var d=h+1;h>=0;h--)this.addInt16(this.vtable[h]!=0?p-this.vtable[h]:0);this.addInt16(p-this.object_start);var u=(d+2)*m.SIZEOF_SHORT;this.addInt16(u);var c=0,a=this.space;t:for(h=0;h<this.vtables.length;h++){var o=this.bb.capacity()-this.vtables[h];if(u==this.bb.readInt16(o)){for(var n=m.SIZEOF_SHORT;n<u;n+=m.SIZEOF_SHORT)if(this.bb.readInt16(a+n)!=this.bb.readInt16(o+n))continue t;c=this.vtables[h];break}}return c?(this.space=this.bb.capacity()-p,this.bb.writeInt32(this.space,c-p)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-p,this.offset()-p)),this.isNested=!1,p},m.Builder.prototype.finish=function(p,h,d){var u=d?m.SIZE_PREFIX_LENGTH:0;if(h){var c=h;if(this.prep(this.minalign,m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH+u),c.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var a=m.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(c.charCodeAt(a))}this.prep(this.minalign,m.SIZEOF_INT+u),this.addOffset(p),u&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},m.Builder.prototype.finishSizePrefixed=function(p,h){this.finish(p,h,!0)},m.Builder.prototype.requiredField=function(p,h){var d=this.bb.capacity()-p,u=d-this.bb.readInt32(d);if(this.bb.readInt16(u+h)==0)throw new Error("FlatBuffers: field "+h+" must be set")},m.Builder.prototype.startVector=function(p,h,d){this.notNested(),this.vector_num_elems=h,this.prep(m.SIZEOF_INT,p*h),this.prep(d,p*h)},m.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},m.Builder.prototype.createString=function(p){if(p instanceof Uint8Array)var h=p;else{h=[];for(var d=0;d<p.length;){var u,c=p.charCodeAt(d++);(u=c<55296||c>=56320?c:(c<<10)+p.charCodeAt(d++)+-56613888)<128?h.push(u):(u<2048?h.push(u>>6&31|192):(u<65536?h.push(u>>12&15|224):h.push(u>>18&7|240,u>>12&63|128),h.push(u>>6&63|128)),h.push(63&u|128))}}this.addInt8(0),this.startVector(1,h.length,1),this.bb.setPosition(this.space-=h.length),d=0;for(var a=this.space,o=this.bb.bytes();d<h.length;d++)o[a++]=h[d];return this.endVector()},m.Builder.prototype.createLong=function(p,h){return m.Long.create(p,h)},m.ByteBuffer=function(p){this.bytes_=p,this.position_=0},m.ByteBuffer.allocate=function(p){return new m.ByteBuffer(new Uint8Array(p))},m.ByteBuffer.prototype.clear=function(){this.position_=0},m.ByteBuffer.prototype.bytes=function(){return this.bytes_},m.ByteBuffer.prototype.position=function(){return this.position_},m.ByteBuffer.prototype.setPosition=function(p){this.position_=p},m.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},m.ByteBuffer.prototype.readInt8=function(p){return this.readUint8(p)<<24>>24},m.ByteBuffer.prototype.readUint8=function(p){return this.bytes_[p]},m.ByteBuffer.prototype.readInt16=function(p){return this.readUint16(p)<<16>>16},m.ByteBuffer.prototype.readUint16=function(p){return this.bytes_[p]|this.bytes_[p+1]<<8},m.ByteBuffer.prototype.readInt32=function(p){return this.bytes_[p]|this.bytes_[p+1]<<8|this.bytes_[p+2]<<16|this.bytes_[p+3]<<24},m.ByteBuffer.prototype.readUint32=function(p){return this.readInt32(p)>>>0},m.ByteBuffer.prototype.readInt64=function(p){return new m.Long(this.readInt32(p),this.readInt32(p+4))},m.ByteBuffer.prototype.readUint64=function(p){return new m.Long(this.readUint32(p),this.readUint32(p+4))},m.ByteBuffer.prototype.readFloat32=function(p){return m.int32[0]=this.readInt32(p),m.float32[0]},m.ByteBuffer.prototype.readFloat64=function(p){return m.int32[m.isLittleEndian?0:1]=this.readInt32(p),m.int32[m.isLittleEndian?1:0]=this.readInt32(p+4),m.float64[0]},m.ByteBuffer.prototype.writeInt8=function(p,h){this.bytes_[p]=h},m.ByteBuffer.prototype.writeUint8=function(p,h){this.bytes_[p]=h},m.ByteBuffer.prototype.writeInt16=function(p,h){this.bytes_[p]=h,this.bytes_[p+1]=h>>8},m.ByteBuffer.prototype.writeUint16=function(p,h){this.bytes_[p]=h,this.bytes_[p+1]=h>>8},m.ByteBuffer.prototype.writeInt32=function(p,h){this.bytes_[p]=h,this.bytes_[p+1]=h>>8,this.bytes_[p+2]=h>>16,this.bytes_[p+3]=h>>24},m.ByteBuffer.prototype.writeUint32=function(p,h){this.bytes_[p]=h,this.bytes_[p+1]=h>>8,this.bytes_[p+2]=h>>16,this.bytes_[p+3]=h>>24},m.ByteBuffer.prototype.writeInt64=function(p,h){this.writeInt32(p,h.low),this.writeInt32(p+4,h.high)},m.ByteBuffer.prototype.writeUint64=function(p,h){this.writeUint32(p,h.low),this.writeUint32(p+4,h.high)},m.ByteBuffer.prototype.writeFloat32=function(p,h){m.float32[0]=h,this.writeInt32(p,m.int32[0])},m.ByteBuffer.prototype.writeFloat64=function(p,h){m.float64[0]=h,this.writeInt32(p,m.int32[m.isLittleEndian?0:1]),this.writeInt32(p+4,m.int32[m.isLittleEndian?1:0])},m.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var p="",h=0;h<m.FILE_IDENTIFIER_LENGTH;h++)p+=String.fromCharCode(this.readInt8(this.position_+m.SIZEOF_INT+h));return p},m.ByteBuffer.prototype.__offset=function(p,h){var d=p-this.readInt32(p);return h<this.readInt16(d)?this.readInt16(d+h):0},m.ByteBuffer.prototype.__union=function(p,h){return p.bb_pos=h+this.readInt32(h),p.bb=this,p},m.ByteBuffer.prototype.__string=function(p,h){p+=this.readInt32(p);var d=this.readInt32(p),u="",c=0;if(p+=m.SIZEOF_INT,h===m.Encoding.UTF8_BYTES)return this.bytes_.subarray(p,p+d);for(;c<d;){var a,o=this.readUint8(p+c++);if(o<192)a=o;else{var n=this.readUint8(p+c++);if(o<224)a=(31&o)<<6|63&n;else{var t=this.readUint8(p+c++);a=o<240?(15&o)<<12|(63&n)<<6|63&t:(7&o)<<18|(63&n)<<12|(63&t)<<6|63&this.readUint8(p+c++)}}a<65536?u+=String.fromCharCode(a):(a-=65536,u+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return u},m.ByteBuffer.prototype.__indirect=function(p){return p+this.readInt32(p)},m.ByteBuffer.prototype.__vector=function(p){return p+this.readInt32(p)+m.SIZEOF_INT},m.ByteBuffer.prototype.__vector_len=function(p){return this.readInt32(p+this.readInt32(p))},m.ByteBuffer.prototype.__has_identifier=function(p){if(p.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var h=0;h<m.FILE_IDENTIFIER_LENGTH;h++)if(p.charCodeAt(h)!=this.readInt8(this.position_+m.SIZEOF_INT+h))return!1;return!0},m.ByteBuffer.prototype.createLong=function(p,h){return m.Long.create(p,h)}}},__webpack_module_cache__={};function __webpack_require__(R){var l=__webpack_module_cache__[R];if(l!==void 0)return l.exports;var b=__webpack_module_cache__[R]={exports:{}};return __webpack_modules__[R].call(b.exports,b,b.exports,__webpack_require__),b.exports}__webpack_require__.n=R=>{var l=R&&R.__esModule?()=>R.default:()=>R;return __webpack_require__.d(l,{a:l}),l},__webpack_require__.d=(R,l)=>{for(var b in l)__webpack_require__.o(l,b)&&!__webpack_require__.o(R,b)&&Object.defineProperty(R,b,{enumerable:!0,get:l[b]})},__webpack_require__.o=(R,l)=>Object.prototype.hasOwnProperty.call(R,l),__webpack_require__.r=R=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(R,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(R,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())})(ort_min);var ort_minExports=ort_min.exports;const PACKAGE_NAME="modern-rembg",SUPPORT_URL="URL"in globalThis,SUPPORT_FETCH="fetch"in globalThis,SUPPORT_BLOB="Blob"in globalThis,SUPPORT_NAVIGATOR="navigator"in globalThis,consoleDebug=(...R)=>console.debug(`[${PACKAGE_NAME}][${new Date().toLocaleTimeString()}]`,...R);class ImageTensor{constructor(l,b){this.data=l,this.dims=b}static async from(l){if(SUPPORT_URL&&l instanceof URL&&(l=l.href),SUPPORT_FETCH&&typeof l=="string"&&(l=await fetch(l).then(b=>b.blob())),SUPPORT_BLOB&&((l instanceof ArrayBuffer||ArrayBuffer.isView(l))&&(l=new Blob([l])),l instanceof Blob)){const b=await createImageBitmap(l),m=new OffscreenCanvas(b.width,b.height),p=m.getContext("2d");p.drawImage(b,0,0);const h=p.getImageData(0,0,m.width,m.height);return new ImageTensor(new Float32Array(h.data),[b.height,b.width,4])}throw new TypeError("Not supported image source")}resize(l,b){const[m,p,h]=this.dims,d=p/l,u=m/b,c=new Uint8Array(h*l*b);for(let a=0;a<b;a++)for(let o=0;o<l;o++)for(let n=0;n<h;n++){const t=o*d,e=a*u,r=Math.floor(t),i=Math.ceil(t),s=Math.floor(e),f=Math.ceil(e),g=t-r,y=e-s,v=this.data[s*p*h+r*h+n],w=this.data[s*p*h+i*h+n],T=this.data[f*p*h+r*h+n],x=this.data[f*p*h+i*h+n],A=(1-g)*(1-y)*v+g*(1-y)*w+(1-g)*y*T+g*y*x;c[a*l*h+o*h+n]=Math.round(A)}return new ImageTensor(new Float32Array(c),[b,l,h])}toBchwImageTensor(l=[128,128,128],b=[256,256,256]){const{data:m,dims:p}=this,[h,d,u]=p,c=h*d,a=new Float32Array(3*c);for(let o=0,n=0;o<m.length;o+=u,n+=1)a[n]=(m[o]-l[0])/b[0],a[n+c]=(m[o+1]-l[1])/b[1],a[n+c+c]=(m[o+2]-l[2])/b[2];return new ImageTensor(a,[1,3,h,d])}toBlob(l=.8,b="image/png"){const{data:m,dims:p}=this,[h,d]=p;switch(b){case"image/x-rgba8":return new Blob([m],{type:"image/x-rgba8"});case"image/png":case"image/jpeg":case"image/webp":{const u=new ImageData(new Uint8ClampedArray(m),d,h),c=new OffscreenCanvas(u.width,u.height);return c.getContext("2d").putImageData(u,0,0),c.convertToBlob({quality:l,type:b})}default:throw new Error(`Invalid format: ${b}`)}}toTensor(){return new ort_minExports.Tensor("float32",this.data,this.dims)}}class Model{constructor(l,b){this._data=l,this._options=b}static async from(l){let b;if(typeof l=="string"||SUPPORT_URL&&l instanceof URL)b=await fetch(l).then(m=>m.arrayBuffer());else if(ArrayBuffer.isView(l))b=l.buffer;else if(l instanceof ArrayBuffer)b=l;else throw new TypeError("Not supported model source");return new Model(b)}async load(){return this._session=await ort_minExports.InferenceSession.create(this._data,{executionProviders:["wasm"],graphOptimizationLevel:"all",executionMode:"parallel",enableCpuMemArena:!0,...this._options}),this}async release(){var l;return await((l=this._session)==null?void 0:l.release()),this}async run(l,b){this._session||await this.load();const m={};return this._session.inputNames.forEach((h,d)=>{m[h]=l[d]}),(await this._session.run(m,b))[this._session.outputNames[0]]}}class Assets{static async createObjectURL(l){let b,m;switch(l){case"u2netp.onnx":b=await __vitePreload(()=>import("../chunks/u2netp.CxiniucO.js"),__vite__mapDeps([]),import.meta.url),m="application/octet-steam";break;case"ort-wasm.wasm":b=await __vitePreload(()=>import("../chunks/ort-wasm.BxvEb7z-.js"),__vite__mapDeps([]),import.meta.url),m="application/wasm";break;case"ort-wasm-threaded.wasm":b=await __vitePreload(()=>import("../chunks/ort-wasm-threaded.CNuba3vz.js"),__vite__mapDeps([]),import.meta.url),m="application/wasm";break;case"ort-wasm-simd.wasm":b=await __vitePreload(()=>import("../chunks/ort-wasm-simd.CFQe7hOo.js"),__vite__mapDeps([]),import.meta.url),m="application/wasm";break;case"ort-wasm-simd-threaded.wasm":b=await __vitePreload(()=>import("../chunks/ort-wasm-simd-threaded.5ZyesEds.js"),__vite__mapDeps([]),import.meta.url),m="application/wasm";break;default:throw new Error(`Not supported asset ${l}`)}return URL.createObjectURL(new Blob([b.default],{type:m}))}static async getObjectUrl(l){return this.objectUrls.has(l)||this.objectUrls.set(l,await this.createObjectURL(l)),this.objectUrls.get(l)}static release(){this.objectUrls.forEach(l=>{URL.revokeObjectURL(l)}),this.objectUrls.clear()}}Assets.objectUrls=new Map;class Onnx{static get capabilities(){return this._capabilities||(this._capabilities={simd:WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])),threads:(()=>{try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}})(),webgpu:SUPPORT_NAVIGATOR?navigator.gpu!==void 0:!1,numThreads:SUPPORT_NAVIGATOR?navigator.hardwareConcurrency??4:4}),this._capabilities}static async init(l={}){const b=this.capabilities;l.debug&&(consoleDebug("Capabilities:",b),ort_minExports.env.debug=!0,ort_minExports.env.logLevel="verbose"),ort_minExports.env.wasm.numThreads=b.numThreads,ort_minExports.env.wasm.simd=b.simd,ort_minExports.env.wasm.proxy=l.proxy;const m=async p=>l.wasmPaths&&p in l.wasmPaths?l.wasmPaths[p]:await Assets.getObjectUrl(p);ort_minExports.env.wasm.wasmPaths={"ort-wasm-simd-threaded.wasm":b.simd&&b.threads?await m("ort-wasm-simd-threaded.wasm"):void 0,"ort-wasm-simd.wasm":b.simd&&!b.threads?await m("ort-wasm-simd.wasm"):void 0,"ort-wasm-threaded.wasm":!b.simd&&b.threads?await m("ort-wasm-threaded.wasm"):void 0,"ort-wasm.wasm":!b.simd&&!b.threads?await m("ort-wasm.wasm"):void 0}}}Onnx.wasmPaths={};async function removeBackground(R,l){const{debug:b,resolution:m=320,model:p=await Assets.getObjectUrl("u2netp.onnx")}=l;b&&consoleDebug("Loading onnx runtime..."),await Onnx.init(l);const h=await ImageTensor.from(R);let d=h.resize(m,m);b&&consoleDebug("Loading model...");const u=await Model.from(p);await u.load(),b&&consoleDebug("Processing...");const c=await u.run([d.toBchwImageTensor().toTensor()]);u.release(),b&&consoleDebug("Completion",c);const a=m*m;switch(l.output??"foreground"){case"mask":d=new ImageTensor(new Float32Array(4*a),[m,m,4]);for(let o=0;o<4*a;o+=4){const n=o/4,t=c.data[n];d.data[o+3]=t*255}break;case"foreground":for(let o=0;o<4*a;o+=4){const n=o/4,t=c.data[n];d.data[o+3]=t*255}break;case"background":for(let o=0;o<4*a;o+=4){const n=o/4,t=c.data[n];d.data[o+3]=(1-t)*255}break}return await d.resize(h.dims[1],h.dims[0]).toBlob()}function create_fragment(R){let l,b,m,p,h,d="Image background remover",u,c,a,o,n,t="Remove background",e,r,i='<div id="source-image" class="preview-card space-y-4"><h2 class="text-xl text-center">Source image</h2></div> <div id="output-image" class="preview-card space-y-4"><h2 class="text-xl text-center">Output image</h2></div>',s,f;return{c(){l=element("section"),b=element("div"),m=space(),p=element("div"),h=element("h1"),h.textContent=d,u=space(),c=element("form"),a=element("input"),o=space(),n=element("button"),n.textContent=t,e=space(),r=element("div"),r.innerHTML=i,this.h()},l(g){l=claim_element(g,"SECTION",{class:!0});var y=children(l);b=claim_element(y,"DIV",{class:!0}),children(b).forEach(detach),m=claim_space(y),p=claim_element(y,"DIV",{class:!0});var v=children(p);h=claim_element(v,"H1",{class:!0,"data-svelte-h":!0}),get_svelte_dataset(h)!=="svelte-er8t4x"&&(h.textContent=d),u=claim_space(v),c=claim_element(v,"FORM",{method:!0,class:!0,enctype:!0});var w=children(c);a=claim_element(w,"INPUT",{type:!0,name:!0}),o=claim_space(w),n=claim_element(w,"BUTTON",{"data-svelte-h":!0}),get_svelte_dataset(n)!=="svelte-1ug3ftq"&&(n.textContent=t),w.forEach(detach),e=claim_space(v),r=claim_element(v,"DIV",{class:!0,"data-svelte-h":!0}),get_svelte_dataset(r)!=="svelte-1wr6lza"&&(r.innerHTML=i),v.forEach(detach),y.forEach(detach),this.h()},h(){attr(b,"class","md:w-[7rem]"),attr(h,"class","w-full font-zenless-title text-4xl md:text-5xl dark:bg-slate-900 py-2"),attr(a,"type","file"),attr(a,"name","image_source"),attr(c,"method","POST"),attr(c,"class",""),attr(c,"enctype","multipart/form-data"),attr(r,"class","preview w-full grid grid-cols-2 gap-4"),attr(p,"class","section-content flex-grow px-4 md:p-20 space-y-10"),attr(l,"class","min-h-[100vh] md:flex px-4 py-6 pt-[9rem] md:p-0 md:pb-56 bg-white dark:text-white dark:bg-slate-900")},m(g,y){insert_hydration(g,l,y),append_hydration(l,b),append_hydration(l,m),append_hydration(l,p),append_hydration(p,h),append_hydration(p,u),append_hydration(p,c),append_hydration(c,a),append_hydration(c,o),append_hydration(c,n),append_hydration(p,e),append_hydration(p,r),s||(f=[listen(a,"input",showImage),action_destroyer(enhance.call(null,c,R[1]))],s=!0)},p:noop,i:noop,o:noop,d(g){g&&detach(l),s=!1,run_all(f)}}}function showImage({target:R}){var l;if(R instanceof HTMLInputElement){const b=(l=R.files)==null?void 0:l[0];if(b){const m="w-full h-96 object-contain object-center",p=document.querySelector("#source-image"),h=URL.createObjectURL(b),d=document.createElement("img");d.src=h,d.classList.add(...m.split(" ")),p==null||p.append(d)}}}function instance(R){async function l(m,p){const h={debug:!0,model:"/python/ai/models/isnet-anime.onnx",output:"foreground",resolution:320},d="w-full h-96 object-contain object-center",u=await removeBackground(m,Object.assign(h,p)),c=document.querySelector("#output-image"),a=URL.createObjectURL(u);console.log("output: ",a);const o=document.createElement("img");o.classList.add(...d.split(" ")),c==null||c.append(o)}return[l,({formData:m})=>l(m.get("image_source")??"")]}class Page extends SvelteComponent{constructor(l){super(),init(this,l,instance,create_fragment,safe_not_equal,{})}}export{Page as component};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
