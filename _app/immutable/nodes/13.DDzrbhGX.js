import{S as Ae,i as Ge,s as Qe,_ as he,Z as Xe,a5 as lt,L as z,t as M,a as C,a6 as ct,M as I,N as D,O as A,a0 as Se,w as Ie,a1 as Je,c as Ke,d as F,u as $e,g as et,b as tt,f as V,m as $,r as ee,j as ht,k as ft,l as dt,q as ut,n as mt}from"../chunks/xk3pEXYh.js";import"../chunks/IHki7fMi.js";import{T as q,a as it,b as pt,f as ot,H as gt,w as Ee,C as wt}from"../chunks/BE0wAo_P.js";import{ap as yt,H as Ye,P as _t,V as p,C as ke,O as De,Q as U,aq as Pt,J as nt,A as bt,ar as O,as as j,U as He,at as Oe,X as f,au as we,Z as se,av as fe,aw as vt,ax as St,l as st,ak as at,a0 as xt,ay as Mt,az as Ct,G as Et}from"../chunks/BWs5EcuF.js";import{g as je,a as Ze}from"../chunks/CgU5AtxT.js";import{w as ye,d as kt}from"../chunks/py_jMq1I.js";import{u as Tt,P as zt,O as It}from"../chunks/D63ksOik.js";const Dt=Number.parseInt(yt.replace("dev","")),At=`
  varying vec3 localPosition;
  varying vec4 worldPosition;

  uniform vec3 worldCamProjPosition;
	uniform vec3 worldPlanePosition;
	uniform float fadeDistance;
	uniform bool infiniteGrid;
	uniform bool followCamera;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	void main() {
		localPosition = vec3(
		  position[coord0],
			position[coord1],
			position[coord2]
		);

		if (infiniteGrid) {
		  localPosition *= 1.0 + fadeDistance;
		}

		worldPosition = modelMatrix * vec4(localPosition, 1.0);
		if (followCamera) {
		  worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
      localPosition = (inverse(modelMatrix) * worldPosition).xyz;
		}

		gl_Position = projectionMatrix * viewMatrix * worldPosition;
	}
`,Gt=`
  #define PI 3.141592653589793

	varying vec3 localPosition;
	varying vec4 worldPosition;

	uniform vec3 worldCamProjPosition;
	uniform float cellSize;
	uniform float sectionSize;
	uniform vec3 cellColor;
	uniform vec3 sectionColor;
	uniform float fadeDistance;
	uniform float fadeStrength;
	uniform float cellThickness;
	uniform float sectionThickness;
	uniform vec3 backgroundColor;
	uniform float backgroundOpacity;

	uniform bool infiniteGrid;

	uniform int coord0;
	uniform int coord1;
	uniform int coord2;

	// 0 - default; 1 - lines; 2 - circles; 3 - polar
	uniform int gridType;

  // lineGrid coord for lines
	uniform int lineGridCoord;

	// circlegrid max radius
	uniform float circleGridMaxRadius;

	// polar grid dividers
	uniform float polarCellDividers;
	uniform float polarSectionDividers;

	float getSquareGrid(float size, float thickness, vec3 localPos) {
		vec2 coord = localPos.xy / size;

		vec2 grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord);
		float line = min(grid.x, grid.y) + 1.0 - thickness;

		return 1.0 - min(line, 1.0);
	}

	float getLinesGrid(float size, float thickness, vec3 localPos) {
		float coord = localPos[lineGridCoord] / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		return 1.0 - min(line, 1.0);
	}

	float getCirclesGrid(float size, float thickness, vec3 localPos) {
		float coord = length(localPos.xy) / size;
		float line = abs(fract(coord - 0.5) - 0.5) / fwidth(coord) - thickness * 0.2;

		if (!infiniteGrid && circleGridMaxRadius > 0. && coord > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	float getPolarGrid(float size, float thickness, float polarDividers, vec3 localPos) {
		float rad = length(localPos.xy) / size;
		vec2 coord = vec2(rad, atan(localPos.x, localPos.y) * polarDividers / PI) ;

		vec2 wrapped = vec2(coord.x, fract(coord.y / (2.0 * polarDividers)) * (2.0 * polarDividers));
		vec2 coordWidth = fwidth(coord);
		vec2 wrappedWidth = fwidth(wrapped);
		vec2 width = (coord.y < -polarDividers * 0.5 || coord.y > polarDividers * 0.5 ? wrappedWidth : coordWidth) * (1.+thickness*0.25);

		// Compute anti-aliased world-space grid lines
		vec2 grid = abs(fract(coord - 0.5) - 0.5) / width;
		float line = min(grid.x, grid.y);

if (!infiniteGrid && circleGridMaxRadius > 0.0 && rad > circleGridMaxRadius + thickness * 0.05) {
		  discard;
		}

		return 1.0 - min(line, 1.0);
	}

	void main() {
		float g1 = 0.0;
		float g2 = 0.0;

		vec3 localPos = vec3(localPosition[coord0], localPosition[coord1], localPosition[coord2]);

		if (gridType == 0) {
			g1 = getSquareGrid(cellSize, cellThickness, localPos);
			g2 = getSquareGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 1) {
			g1 = getLinesGrid(cellSize, cellThickness, localPos);
			g2 = getLinesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 2) {
			g1 = getCirclesGrid(cellSize, cellThickness, localPos);
			g2 = getCirclesGrid(sectionSize, sectionThickness, localPos);

		} else if (gridType == 3) {
			g1 = getPolarGrid(cellSize, cellThickness, polarCellDividers, localPos);
			g2 = getPolarGrid(sectionSize, sectionThickness, polarSectionDividers, localPos);
		}

		float dist = distance(worldCamProjPosition, worldPosition.xyz);
		float d = 1.0 - min(dist / fadeDistance, 1.0);
		float fadeFactor = pow(d, fadeStrength) * 0.95;

		vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

		if (backgroundOpacity > 0.0) {
			float linesAlpha = clamp((g1 + g2) * fadeFactor, 0.0,1.0);
			vec3 finalColor = mix(backgroundColor, color, linesAlpha);
			float blendedAlpha = max(linesAlpha, backgroundOpacity * fadeFactor);
			gl_FragColor = vec4(finalColor, blendedAlpha);

		} else {
			gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
			gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
		}

		if (gl_FragColor.a <= 0.0) {
		  discard;
		}

		#include <tonemapping_fragment>
		#include <${Dt<154?"encodings_fragment":"colorspace_fragment"}>
	}
`,Qt=a=>({ref:a[0]&1}),Re=a=>({ref:a[0]});function Xt(a){let e,i;return e=new q.PlaneGeometry({props:{args:typeof a[1]=="number"?[a[1],a[1]]:a[1]}}),{c(){A(e.$$.fragment)},l(o){D(e.$$.fragment,o)},m(o,s){I(e,o,s),i=!0},p(o,s){const r={};s[0]&2&&(r.args=typeof o[1]=="number"?[o[1],o[1]]:o[1]),e.$set(r)},i(o){i||(C(e.$$.fragment,o),i=!0)},o(o){M(e.$$.fragment,o),i=!1},d(o){z(e,o)}}}function Yt(a){let e,i,o;e=new q.ShaderMaterial({props:{fragmentShader:Gt,vertexShader:At,uniforms:a[3],transparent:!0,side:a[2]}});const s=a[25].default,r=Ke(s,a,a[28],Re),t=r||Xt(a);return{c(){A(e.$$.fragment),i=ee(),t&&t.c()},l(n){D(e.$$.fragment,n),i=$(n),t&&t.l(n)},m(n,c){I(e,n,c),V(n,i,c),t&&t.m(n,c),o=!0},p(n,c){const m={};c[0]&8&&(m.uniforms=n[3]),c[0]&4&&(m.side=n[2]),e.$set(m),r?r.p&&(!o||c[0]&268435457)&&$e(r,s,n,n[28],o?tt(s,n[28],c,Qt):et(n[28]),Re):t&&t.p&&(!o||c[0]&2)&&t.p(n,o?c:[-1,-1])},i(n){o||(C(e.$$.fragment,n),C(t,n),o=!0)},o(n){M(e.$$.fragment,n),M(t,n),o=!1},d(n){n&&F(i),z(e,n),t&&t.d(n)}}}function jt(a){let e,i,o;const s=[{frustumCulled:!1},a[6]];function r(n){a[27](n)}let t={$$slots:{default:[Yt,({ref:n})=>({0:n}),({ref:n})=>[n?1:0]]},$$scope:{ctx:a}};for(let n=0;n<s.length;n+=1)t=he(t,s[n]);return a[0]!==void 0&&(t.ref=a[0]),e=new q.Mesh({props:t}),a[26](e),Xe.push(()=>lt(e,"ref",r)),{c(){A(e.$$.fragment)},l(n){D(e.$$.fragment,n)},m(n,c){I(e,n,c),o=!0},p(n,c){const m=c[0]&64?je(s,[s[0],Ze(n[6])]):{};c[0]&268435471&&(m.$$scope={dirty:c,ctx:n}),!i&&c[0]&1&&(i=!0,m.ref=n[0],ct(()=>i=!1)),e.$set(m)},i(n){o||(C(e.$$.fragment,n),o=!0)},o(n){M(e.$$.fragment,n),o=!1},d(n){a[26](null),z(e,n)}}}function Zt(a,e,i){const o=["cellColor","sectionColor","cellSize","backgroundColor","backgroundOpacity","sectionSize","plane","gridSize","followCamera","infiniteGrid","fadeDistance","fadeStrength","cellThickness","sectionThickness","side","type","axis","maxRadius","cellDividers","sectionDividers","ref"];let s=Se(e,o),r,{$$slots:t={},$$scope:n}=e,{cellColor:c="#000000"}=e,{sectionColor:m="#0000ee"}=e,{cellSize:y=1}=e,{backgroundColor:v="#dadada"}=e,{backgroundOpacity:G=0}=e,{sectionSize:l=10}=e,{plane:g="xz"}=e,{gridSize:E=[20,20]}=e,{followCamera:k=!1}=e,{infiniteGrid:S=!1}=e,{fadeDistance:_=100}=e,{fadeStrength:T=1}=e,{cellThickness:Z=1}=e,{sectionThickness:H=2}=e,{side:re=Ye}=e,{type:J="grid"}=e,{axis:W="x"}=e,{maxRadius:K=0}=e,{cellDividers:te=6}=e,{sectionDividers:L=2}=e,{ref:Y}=e;const{invalidate:ie,camera:R}=it(),Q=new _t,oe=new p(0,1,0),d=new p(0,0,0),b={x:0,y:1,z:2},x={xz:"xzy",xy:"xyz",zy:"zyx"},N={grid:0,lines:1,circular:2,polar:3},u={cellSize:{value:y},sectionSize:{value:l},cellColor:{value:new ke(c)},sectionColor:{value:new ke(m)},backgroundColor:{value:new ke(v)},backgroundOpacity:{value:G},fadeDistance:{value:_},fadeStrength:{value:T},cellThickness:{value:Z},sectionThickness:{value:H},infiniteGrid:{value:S},followCamera:{value:k},coord0:{value:0},coord1:{value:2},coord2:{value:1},gridType:{value:N.grid},lineGridCoord:{value:b[W]},circleGridMaxRadius:{value:K},polarCellDividers:{value:te},polarSectionDividers:{value:L},worldCamProjPosition:{value:new p},worldPlanePosition:{value:new p}};pt(()=>{if(!Y)return;Q.setFromNormalAndCoplanarPoint(oe,d).applyMatrix4(Y.matrixWorld);const h=Y.material,Me=h.uniforms.worldCamProjPosition,Ce=h.uniforms.worldPlanePosition;Q.projectPoint(R.current.position,Me.value),Ce.value.set(0,0,0).applyMatrix4(Y.matrixWorld),ie()});const ne=ot();Ie(a,ne,h=>i(4,r=h));function xe(h){Xe[h?"unshift":"push"](()=>{r=h,ne.set(r)})}function ge(h){Y=h,i(0,Y)}return a.$$set=h=>{e=he(he({},e),Je(h)),i(6,s=Se(e,o)),"cellColor"in h&&i(7,c=h.cellColor),"sectionColor"in h&&i(8,m=h.sectionColor),"cellSize"in h&&i(9,y=h.cellSize),"backgroundColor"in h&&i(10,v=h.backgroundColor),"backgroundOpacity"in h&&i(11,G=h.backgroundOpacity),"sectionSize"in h&&i(12,l=h.sectionSize),"plane"in h&&i(13,g=h.plane),"gridSize"in h&&i(1,E=h.gridSize),"followCamera"in h&&i(14,k=h.followCamera),"infiniteGrid"in h&&i(15,S=h.infiniteGrid),"fadeDistance"in h&&i(16,_=h.fadeDistance),"fadeStrength"in h&&i(17,T=h.fadeStrength),"cellThickness"in h&&i(18,Z=h.cellThickness),"sectionThickness"in h&&i(19,H=h.sectionThickness),"side"in h&&i(2,re=h.side),"type"in h&&i(20,J=h.type),"axis"in h&&i(21,W=h.axis),"maxRadius"in h&&i(22,K=h.maxRadius),"cellDividers"in h&&i(23,te=h.cellDividers),"sectionDividers"in h&&i(24,L=h.sectionDividers),"ref"in h&&i(0,Y=h.ref),"$$scope"in h&&i(28,n=h.$$scope)},a.$$.update=()=>{if(a.$$.dirty[0]&8192){const h=x[g],Me=h.charAt(0),Ce=h.charAt(1),rt=h.charAt(2);i(3,u.coord0.value=b[Me],u),i(3,u.coord1.value=b[Ce],u),i(3,u.coord2.value=b[rt],u)}if(a.$$.dirty[0]&512&&i(3,u.cellSize.value=y,u),a.$$.dirty[0]&4096&&i(3,u.sectionSize.value=l,u),a.$$.dirty[0]&2048&&i(3,u.backgroundOpacity.value=G,u),a.$$.dirty[0]&65536&&i(3,u.fadeDistance.value=_,u),a.$$.dirty[0]&131072&&i(3,u.fadeStrength.value=T,u),a.$$.dirty[0]&262144&&i(3,u.cellThickness.value=Z,u),a.$$.dirty[0]&524288&&i(3,u.sectionThickness.value=H,u),a.$$.dirty[0]&16384&&i(3,u.followCamera.value=k,u),a.$$.dirty[0]&32768&&i(3,u.infiniteGrid.value=S,u),a.$$.dirty[0]&32505856){switch(J){case"grid":{i(3,u.gridType.value=N.grid,u);break}case"lines":{i(3,u.gridType.value=N.lines,u),i(3,u.lineGridCoord.value=b[W],u);break}case"circular":{i(3,u.gridType.value=N.circular,u),i(3,u.circleGridMaxRadius.value=K,u);break}case"polar":{i(3,u.gridType.value=N.polar,u),i(3,u.circleGridMaxRadius.value=K,u),i(3,u.polarCellDividers.value=te,u),i(3,u.polarSectionDividers.value=L,u);break}}ie()}a.$$.dirty[0]&136&&u.cellColor.value.set(c),a.$$.dirty[0]&264&&u.sectionColor.value.set(m),a.$$.dirty[0]&1032&&u.backgroundColor.value.set(v)},[Y,E,re,u,r,ne,s,c,m,y,v,G,l,g,k,S,_,T,Z,H,J,W,K,te,L,t,xe,ge,n]}class Ht extends Ae{constructor(e){super(),Ge(this,e,Zt,jt,Qe,{cellColor:7,sectionColor:8,cellSize:9,backgroundColor:10,backgroundOpacity:11,sectionSize:12,plane:13,gridSize:1,followCamera:14,infiniteGrid:15,fadeDistance:16,fadeStrength:17,cellThickness:18,sectionThickness:19,side:2,type:20,axis:21,maxRadius:22,cellDividers:23,sectionDividers:24,ref:0},null,[-1,-1])}}const le=new Pt,X=new p,ae=new p,P=new U,qe={X:new p(1,0,0),Y:new p(0,1,0),Z:new p(0,0,1)},Te={type:"change"},Le={type:"mouseDown"},Fe={type:"mouseUp",mode:null},We={type:"objectChange"};class Ot extends De{constructor(e,i){super(),i===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),i=document),this.isTransformControls=!0,this.visible=!1,this.domElement=i,this.domElement.style.touchAction="none";const o=new Nt;this._gizmo=o,this.add(o);const s=new Bt;this._plane=s,this.add(s);const r=this;function t(_,T){let Z=T;Object.defineProperty(r,_,{get:function(){return Z!==void 0?Z:T},set:function(H){Z!==H&&(Z=H,s[_]=H,o[_]=H,r.dispatchEvent({type:_+"-changed",value:H}),r.dispatchEvent(Te))}}),r[_]=T,s[_]=T,o[_]=T}t("camera",e),t("object",void 0),t("enabled",!0),t("axis",null),t("mode","translate"),t("translationSnap",null),t("rotationSnap",null),t("scaleSnap",null),t("space","world"),t("size",1),t("dragging",!1),t("showX",!0),t("showY",!0),t("showZ",!0);const n=new p,c=new p,m=new U,y=new U,v=new p,G=new U,l=new p,g=new p,E=new p,k=0,S=new p;t("worldPosition",n),t("worldPositionStart",c),t("worldQuaternion",m),t("worldQuaternionStart",y),t("cameraPosition",v),t("cameraQuaternion",G),t("pointStart",l),t("pointEnd",g),t("rotationAxis",E),t("rotationAngle",k),t("eye",S),this._offset=new p,this._startNorm=new p,this._endNorm=new p,this._cameraScale=new p,this._parentPosition=new p,this._parentQuaternion=new U,this._parentQuaternionInv=new U,this._parentScale=new p,this._worldScaleStart=new p,this._worldQuaternionInv=new U,this._worldScale=new p,this._positionStart=new p,this._quaternionStart=new U,this._scaleStart=new p,this._getPointer=Rt.bind(this),this._onPointerDown=Lt.bind(this),this._onPointerHover=qt.bind(this),this._onPointerMove=Ft.bind(this),this._onPointerUp=Wt.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.camera.isOrthographicCamera?this.camera.getWorldDirection(this.eye).negate():this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(e){if(this.object===void 0||this.dragging===!0)return;le.setFromCamera(e,this.camera);const i=ze(this._gizmo.picker[this.mode],le);i?this.axis=i.object.name:this.axis=null}pointerDown(e){if(!(this.object===void 0||this.dragging===!0||e.button!==0)&&this.axis!==null){le.setFromCamera(e,this.camera);const i=ze(this._plane,le,!0);i&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(i.point).sub(this.worldPositionStart)),this.dragging=!0,Le.mode=this.mode,this.dispatchEvent(Le)}}pointerMove(e){const i=this.axis,o=this.mode,s=this.object;let r=this.space;if(o==="scale"?r="local":(i==="E"||i==="XYZE"||i==="XYZ")&&(r="world"),s===void 0||i===null||this.dragging===!1||e.button!==-1)return;le.setFromCamera(e,this.camera);const t=ze(this._plane,le,!0);if(t){if(this.pointEnd.copy(t.point).sub(this.worldPositionStart),o==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),r==="local"&&i!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),i.indexOf("X")===-1&&(this._offset.x=0),i.indexOf("Y")===-1&&(this._offset.y=0),i.indexOf("Z")===-1&&(this._offset.z=0),r==="local"&&i!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),s.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(r==="local"&&(s.position.applyQuaternion(P.copy(this._quaternionStart).invert()),i.search("X")!==-1&&(s.position.x=Math.round(s.position.x/this.translationSnap)*this.translationSnap),i.search("Y")!==-1&&(s.position.y=Math.round(s.position.y/this.translationSnap)*this.translationSnap),i.search("Z")!==-1&&(s.position.z=Math.round(s.position.z/this.translationSnap)*this.translationSnap),s.position.applyQuaternion(this._quaternionStart)),r==="world"&&(s.parent&&s.position.add(X.setFromMatrixPosition(s.parent.matrixWorld)),i.search("X")!==-1&&(s.position.x=Math.round(s.position.x/this.translationSnap)*this.translationSnap),i.search("Y")!==-1&&(s.position.y=Math.round(s.position.y/this.translationSnap)*this.translationSnap),i.search("Z")!==-1&&(s.position.z=Math.round(s.position.z/this.translationSnap)*this.translationSnap),s.parent&&s.position.sub(X.setFromMatrixPosition(s.parent.matrixWorld))));else if(o==="scale"){if(i.search("XYZ")!==-1){let n=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(n*=-1),ae.set(n,n,n)}else X.copy(this.pointStart),ae.copy(this.pointEnd),X.applyQuaternion(this._worldQuaternionInv),ae.applyQuaternion(this._worldQuaternionInv),ae.divide(X),i.search("X")===-1&&(ae.x=1),i.search("Y")===-1&&(ae.y=1),i.search("Z")===-1&&(ae.z=1);s.scale.copy(this._scaleStart).multiply(ae),this.scaleSnap&&(i.search("X")!==-1&&(s.scale.x=Math.round(s.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),i.search("Y")!==-1&&(s.scale.y=Math.round(s.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),i.search("Z")!==-1&&(s.scale.z=Math.round(s.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(o==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const n=20/this.worldPosition.distanceTo(X.setFromMatrixPosition(this.camera.matrixWorld));let c=!1;i==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(X.copy(this.rotationAxis).cross(this.eye))*n):(i==="X"||i==="Y"||i==="Z")&&(this.rotationAxis.copy(qe[i]),X.copy(qe[i]),r==="local"&&X.applyQuaternion(this.worldQuaternion),X.cross(this.eye),X.length()===0?c=!0:this.rotationAngle=this._offset.dot(X.normalize())*n),(i==="E"||c)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),r==="local"&&i!=="E"&&i!=="XYZE"?(s.quaternion.copy(this._quaternionStart),s.quaternion.multiply(P.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),s.quaternion.copy(P.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),s.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(Te),this.dispatchEvent(We)}}pointerUp(e){e.button===0&&(this.dragging&&this.axis!==null&&(Fe.mode=this.mode,this.dispatchEvent(Fe)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()})}attach(e){return this.object=e,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(Te),this.dispatchEvent(We),this.pointStart.copy(this.pointEnd))}getRaycaster(){return le}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}}function Rt(a){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:a.button};{const e=this.domElement.getBoundingClientRect();return{x:(a.clientX-e.left)/e.width*2-1,y:-(a.clientY-e.top)/e.height*2+1,button:a.button}}}function qt(a){if(this.enabled)switch(a.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(a));break}}function Lt(a){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(a.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(a)),this.pointerDown(this._getPointer(a)))}function Ft(a){this.enabled&&this.pointerMove(this._getPointer(a))}function Wt(a){this.enabled&&(this.domElement.releasePointerCapture(a.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(a)))}function ze(a,e,i){const o=e.intersectObject(a,!0);for(let s=0;s<o.length;s++)if(o[s].object.visible||i)return o[s];return!1}const _e=new St,w=new p(0,1,0),Ne=new p(0,0,0),Be=new st,Pe=new U,ve=new U,B=new p,Ue=new st,me=new p(1,0,0),ce=new p(0,1,0),pe=new p(0,0,1),be=new p,de=new p,ue=new p;class Nt extends De{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const e=new nt({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),i=new bt({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),o=e.clone();o.opacity=.15;const s=i.clone();s.opacity=.5;const r=e.clone();r.color.setHex(16711680);const t=e.clone();t.color.setHex(65280);const n=e.clone();n.color.setHex(255);const c=e.clone();c.color.setHex(16711680),c.opacity=.5;const m=e.clone();m.color.setHex(65280),m.opacity=.5;const y=e.clone();y.color.setHex(255),y.opacity=.5;const v=e.clone();v.opacity=.25;const G=e.clone();G.color.setHex(16776960),G.opacity=.25,e.clone().color.setHex(16776960);const g=e.clone();g.color.setHex(7895160);const E=new O(0,.04,.1,12);E.translate(0,.05,0);const k=new j(.08,.08,.08);k.translate(0,.04,0);const S=new He;S.setAttribute("position",new Oe([0,0,0,1,0,0],3));const _=new O(.0075,.0075,.5,3);_.translate(0,.25,0);function T(Q,oe){const d=new fe(Q,.0075,3,64,oe*Math.PI*2);return d.rotateY(Math.PI/2),d.rotateX(Math.PI/2),d}function Z(){const Q=new He;return Q.setAttribute("position",new Oe([0,0,0,1,1,1],3)),Q}const H={X:[[new f(E,r),[.5,0,0],[0,0,-Math.PI/2]],[new f(E,r),[-.5,0,0],[0,0,Math.PI/2]],[new f(_,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new f(E,t),[0,.5,0]],[new f(E,t),[0,-.5,0],[Math.PI,0,0]],[new f(_,t)]],Z:[[new f(E,n),[0,0,.5],[Math.PI/2,0,0]],[new f(E,n),[0,0,-.5],[-Math.PI/2,0,0]],[new f(_,n),null,[Math.PI/2,0,0]]],XYZ:[[new f(new we(.1,0),v.clone()),[0,0,0]]],XY:[[new f(new j(.15,.15,.01),y.clone()),[.15,.15,0]]],YZ:[[new f(new j(.15,.15,.01),c.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.15,.15,.01),m.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},re={X:[[new f(new O(.2,0,.6,4),o),[.3,0,0],[0,0,-Math.PI/2]],[new f(new O(.2,0,.6,4),o),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new f(new O(.2,0,.6,4),o),[0,.3,0]],[new f(new O(.2,0,.6,4),o),[0,-.3,0],[0,0,Math.PI]]],Z:[[new f(new O(.2,0,.6,4),o),[0,0,.3],[Math.PI/2,0,0]],[new f(new O(.2,0,.6,4),o),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new f(new we(.2,0),o)]],XY:[[new f(new j(.2,.2,.01),o),[.15,.15,0]]],YZ:[[new f(new j(.2,.2,.01),o),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.2,.2,.01),o),[.15,0,.15],[-Math.PI/2,0,0]]]},J={START:[[new f(new we(.01,2),s),null,null,null,"helper"]],END:[[new f(new we(.01,2),s),null,null,null,"helper"]],DELTA:[[new se(Z(),s),null,null,null,"helper"]],X:[[new se(S,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new se(S,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new se(S,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},W={XYZE:[[new f(T(.5,1),g),null,[0,Math.PI/2,0]]],X:[[new f(T(.5,.5),r)]],Y:[[new f(T(.5,.5),t),null,[0,0,-Math.PI/2]]],Z:[[new f(T(.5,.5),n),null,[0,Math.PI/2,0]]],E:[[new f(T(.75,1),G),null,[0,Math.PI/2,0]]]},K={AXIS:[[new se(S,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},te={XYZE:[[new f(new vt(.25,10,8),o)]],X:[[new f(new fe(.5,.1,4,24),o),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new f(new fe(.5,.1,4,24),o),[0,0,0],[Math.PI/2,0,0]]],Z:[[new f(new fe(.5,.1,4,24),o),[0,0,0],[0,0,-Math.PI/2]]],E:[[new f(new fe(.75,.1,2,24),o)]]},L={X:[[new f(k,r),[.5,0,0],[0,0,-Math.PI/2]],[new f(_,r),[0,0,0],[0,0,-Math.PI/2]],[new f(k,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new f(k,t),[0,.5,0]],[new f(_,t)],[new f(k,t),[0,-.5,0],[0,0,Math.PI]]],Z:[[new f(k,n),[0,0,.5],[Math.PI/2,0,0]],[new f(_,n),[0,0,0],[Math.PI/2,0,0]],[new f(k,n),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new f(new j(.15,.15,.01),y),[.15,.15,0]]],YZ:[[new f(new j(.15,.15,.01),c),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.15,.15,.01),m),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new f(new j(.1,.1,.1),v.clone())]]},Y={X:[[new f(new O(.2,0,.6,4),o),[.3,0,0],[0,0,-Math.PI/2]],[new f(new O(.2,0,.6,4),o),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new f(new O(.2,0,.6,4),o),[0,.3,0]],[new f(new O(.2,0,.6,4),o),[0,-.3,0],[0,0,Math.PI]]],Z:[[new f(new O(.2,0,.6,4),o),[0,0,.3],[Math.PI/2,0,0]],[new f(new O(.2,0,.6,4),o),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new f(new j(.2,.2,.01),o),[.15,.15,0]]],YZ:[[new f(new j(.2,.2,.01),o),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new f(new j(.2,.2,.01),o),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new f(new j(.2,.2,.2),o),[0,0,0]]]},ie={X:[[new se(S,s.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new se(S,s.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new se(S,s.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function R(Q){const oe=new De;for(const d in Q)for(let b=Q[d].length;b--;){const x=Q[d][b][0].clone(),N=Q[d][b][1],u=Q[d][b][2],ne=Q[d][b][3],xe=Q[d][b][4];x.name=d,x.tag=xe,N&&x.position.set(N[0],N[1],N[2]),u&&x.rotation.set(u[0],u[1],u[2]),ne&&x.scale.set(ne[0],ne[1],ne[2]),x.updateMatrix();const ge=x.geometry.clone();ge.applyMatrix4(x.matrix),x.geometry=ge,x.renderOrder=1/0,x.position.set(0,0,0),x.rotation.set(0,0,0),x.scale.set(1,1,1),oe.add(x)}return oe}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=R(H)),this.add(this.gizmo.rotate=R(W)),this.add(this.gizmo.scale=R(L)),this.add(this.picker.translate=R(re)),this.add(this.picker.rotate=R(te)),this.add(this.picker.scale=R(Y)),this.add(this.helper.translate=R(J)),this.add(this.helper.rotate=R(K)),this.add(this.helper.scale=R(ie)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(e){const o=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:ve;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let s=[];s=s.concat(this.picker[this.mode].children),s=s.concat(this.gizmo[this.mode].children),s=s.concat(this.helper[this.mode].children);for(let r=0;r<s.length;r++){const t=s[r];t.visible=!0,t.rotation.set(0,0,0),t.position.copy(this.worldPosition);let n;if(this.camera.isOrthographicCamera?n=(this.camera.top-this.camera.bottom)/this.camera.zoom:n=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),t.scale.set(1,1,1).multiplyScalar(n*this.size/4),t.tag==="helper"){t.visible=!1,t.name==="AXIS"?(t.visible=!!this.axis,this.axis==="X"&&(P.setFromEuler(_e.set(0,0,0)),t.quaternion.copy(o).multiply(P),Math.abs(w.copy(me).applyQuaternion(o).dot(this.eye))>.9&&(t.visible=!1)),this.axis==="Y"&&(P.setFromEuler(_e.set(0,0,Math.PI/2)),t.quaternion.copy(o).multiply(P),Math.abs(w.copy(ce).applyQuaternion(o).dot(this.eye))>.9&&(t.visible=!1)),this.axis==="Z"&&(P.setFromEuler(_e.set(0,Math.PI/2,0)),t.quaternion.copy(o).multiply(P),Math.abs(w.copy(pe).applyQuaternion(o).dot(this.eye))>.9&&(t.visible=!1)),this.axis==="XYZE"&&(P.setFromEuler(_e.set(0,Math.PI/2,0)),w.copy(this.rotationAxis),t.quaternion.setFromRotationMatrix(Be.lookAt(Ne,w,ce)),t.quaternion.multiply(P),t.visible=this.dragging),this.axis==="E"&&(t.visible=!1)):t.name==="START"?(t.position.copy(this.worldPositionStart),t.visible=this.dragging):t.name==="END"?(t.position.copy(this.worldPosition),t.visible=this.dragging):t.name==="DELTA"?(t.position.copy(this.worldPositionStart),t.quaternion.copy(this.worldQuaternionStart),X.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),X.applyQuaternion(this.worldQuaternionStart.clone().invert()),t.scale.copy(X),t.visible=this.dragging):(t.quaternion.copy(o),this.dragging?t.position.copy(this.worldPositionStart):t.position.copy(this.worldPosition),this.axis&&(t.visible=this.axis.search(t.name)!==-1));continue}t.quaternion.copy(o),this.mode==="translate"||this.mode==="scale"?(t.name==="X"&&Math.abs(w.copy(me).applyQuaternion(o).dot(this.eye))>.99&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),t.name==="Y"&&Math.abs(w.copy(ce).applyQuaternion(o).dot(this.eye))>.99&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),t.name==="Z"&&Math.abs(w.copy(pe).applyQuaternion(o).dot(this.eye))>.99&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),t.name==="XY"&&Math.abs(w.copy(pe).applyQuaternion(o).dot(this.eye))<.2&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),t.name==="YZ"&&Math.abs(w.copy(me).applyQuaternion(o).dot(this.eye))<.2&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),t.name==="XZ"&&Math.abs(w.copy(ce).applyQuaternion(o).dot(this.eye))<.2&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1)):this.mode==="rotate"&&(Pe.copy(o),w.copy(this.eye).applyQuaternion(P.copy(o).invert()),t.name.search("E")!==-1&&t.quaternion.setFromRotationMatrix(Be.lookAt(this.eye,Ne,ce)),t.name==="X"&&(P.setFromAxisAngle(me,Math.atan2(-w.y,w.z)),P.multiplyQuaternions(Pe,P),t.quaternion.copy(P)),t.name==="Y"&&(P.setFromAxisAngle(ce,Math.atan2(w.x,w.z)),P.multiplyQuaternions(Pe,P),t.quaternion.copy(P)),t.name==="Z"&&(P.setFromAxisAngle(pe,Math.atan2(w.y,w.x)),P.multiplyQuaternions(Pe,P),t.quaternion.copy(P))),t.visible=t.visible&&(t.name.indexOf("X")===-1||this.showX),t.visible=t.visible&&(t.name.indexOf("Y")===-1||this.showY),t.visible=t.visible&&(t.name.indexOf("Z")===-1||this.showZ),t.visible=t.visible&&(t.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),t.material._color=t.material._color||t.material.color.clone(),t.material._opacity=t.material._opacity||t.material.opacity,t.material.color.copy(t.material._color),t.material.opacity=t.material._opacity,this.enabled&&this.axis&&(t.name===this.axis||this.axis.split("").some(function(c){return t.name===c}))&&(t.material.color.setHex(16776960),t.material.opacity=1)}super.updateMatrixWorld(e)}}class Bt extends f{constructor(){super(new at(1e5,1e5,2,2),new nt({visible:!1,wireframe:!0,side:Ye,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(e){let i=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(i="local"),be.copy(me).applyQuaternion(i==="local"?this.worldQuaternion:ve),de.copy(ce).applyQuaternion(i==="local"?this.worldQuaternion:ve),ue.copy(pe).applyQuaternion(i==="local"?this.worldQuaternion:ve),w.copy(de),this.mode){case"translate":case"scale":switch(this.axis){case"X":w.copy(this.eye).cross(be),B.copy(be).cross(w);break;case"Y":w.copy(this.eye).cross(de),B.copy(de).cross(w);break;case"Z":w.copy(this.eye).cross(ue),B.copy(ue).cross(w);break;case"XY":B.copy(ue);break;case"YZ":B.copy(be);break;case"XZ":w.copy(ue),B.copy(de);break;case"XYZ":case"E":B.set(0,0,0);break}break;case"rotate":default:B.set(0,0,0)}B.length()===0?this.quaternion.copy(this.cameraQuaternion):(Ue.lookAt(X.set(0,0,0),B,w),this.quaternion.setFromRotationMatrix(Ue)),super.updateMatrixWorld(e)}}const Ut=a=>({ref:a&536870912}),Ve=a=>({ref:a[29]});function Vt(a){let e,i;const o=[{is:a[1]},a[2]];let s={};for(let r=0;r<o.length;r+=1)s=he(s,o[r]);return e=new q({props:s}),a[15](e),e.$on("dragging-changed",a[7]),e.$on("change",a[5]),{c(){A(e.$$.fragment)},l(r){D(e.$$.fragment,r)},m(r,t){I(e,r,t),i=!0},p(r,t){const n=t&6?je(o,[t&2&&{is:r[1]},t&4&&Ze(r[2])]):{};e.$set(n)},i(r){i||(C(e.$$.fragment,r),i=!0)},o(r){M(e.$$.fragment,r),i=!1},d(r){a[15](null),z(e,r)}}}function Jt(a){let e;const i=a[14].default,o=Ke(i,a,a[18],Ve);return{c(){o&&o.c()},l(s){o&&o.l(s)},m(s,r){o&&o.m(s,r),e=!0},p(s,r){o&&o.p&&(!e||r&537133056)&&$e(o,i,s,s[18],e?tt(i,s[18],r,Ut):et(s[18]),Ve)},i(s){e||(C(o,s),e=!0)},o(s){M(o,s),e=!1},d(s){o&&o.d(s)}}}function Kt(a){let e,i,o,s;e=new gt({props:{onChildMount:a[16],onChildDestroy:a[17],$$slots:{default:[Vt]},$$scope:{ctx:a}}});const r=[{is:a[0]},a[3]];let t={$$slots:{default:[Jt,({ref:n})=>({29:n}),({ref:n})=>n?536870912:0]},$$scope:{ctx:a}};for(let n=0;n<r.length;n+=1)t=he(t,r[n]);return o=new q({props:t}),{c(){A(e.$$.fragment),i=ee(),A(o.$$.fragment)},l(n){D(e.$$.fragment,n),i=$(n),D(o.$$.fragment,n)},m(n,c){I(e,n,c),V(n,i,c),I(o,n,c),s=!0},p(n,[c]){const m={};c&262166&&(m.$$scope={dirty:c,ctx:n}),e.$set(m);const y=c&9?je(r,[c&1&&{is:n[0]},c&8&&Ze(n[3])]):{};c&537133056&&(y.$$scope={dirty:c,ctx:n}),o.$set(y)},i(n){s||(C(e.$$.fragment,n),C(o.$$.fragment,n),s=!0)},o(n){M(e.$$.fragment,n),M(o.$$.fragment,n),s=!1},d(n){n&&F(i),z(e,n),z(o,n)}}}function $t(a,e,i){const o=["autoPauseOrbitControls","autoPauseTrackballControls","object","group","controls"];let s=Se(e,o),r,t,{$$slots:n={},$$scope:c}=e,{autoPauseOrbitControls:m=!0}=e,{autoPauseTrackballControls:y=!0}=e,{object:v=void 0}=e;const{camera:G,renderer:l,invalidate:g,scene:E}=it(),{orbitControls:k,trackballControls:S}=Tt(),_=ye(!1),T=ye(m??!0),Z=ye(y??!0),H=d=>{_.set(d.value)};Ee([k,_,T],([d,b,x])=>{if(!(!d||!d.enabled&&b))return d.enabled=!(b&&x),()=>{d.enabled=!0}}),Ee([S,_,Z],([d,b,x])=>{if(!(!d||!d.enabled&&b))return d.enabled=!(b&&x),()=>{d.enabled=!0}});const re=new xt,J=kt(G,d=>new Ot(d,l.domElement));Ie(a,J,d=>i(1,r=d));let{controls:W=r}=e;const K=ye(v??re);Ee([J,K],([d,b])=>(d.attach(b),()=>{d.detach()}));const te=["enabled","axis","mode","translationSnap","rotationSnap","scaleSnap","space","size","showX","showY","showZ","visible"];let L={},Y={};const ie=ot();Ie(a,ie,d=>i(4,t=d));function R(d){Xe[d?"unshift":"push"](()=>{t=d,ie.set(t)})}const Q=d=>{E.add(d)},oe=d=>{E.remove(d)};return a.$$set=d=>{e=he(he({},e),Je(d)),i(28,s=Se(e,o)),"autoPauseOrbitControls"in d&&i(11,m=d.autoPauseOrbitControls),"autoPauseTrackballControls"in d&&i(12,y=d.autoPauseTrackballControls),"object"in d&&i(13,v=d.object),"controls"in d&&i(10,W=d.controls),"$$scope"in d&&i(18,c=d.$$scope)},a.$$.update=()=>{a.$$.dirty&2048&&T.set(m??!0),a.$$.dirty&4096&&Z.set(y??!0),a.$$.dirty&2&&i(10,W=r);{i(2,L={}),i(3,Y={});for(let[d,b]of Object.entries(s))te.includes(d)?i(2,L[d]=b,L):i(3,Y[d]=b,Y)}},[re,r,L,Y,t,g,E,H,J,ie,W,m,y,v,n,R,Q,oe,c]}class ei extends Ae{constructor(e){super(),Ge(this,e,$t,Kt,Qe,{autoPauseOrbitControls:11,autoPauseTrackballControls:12,object:13,group:0,controls:10})}get group(){return this.$$.ctx[0]}}const ti=Math.PI/180;function ii(a){let e,i;return e=new It({props:{enableDamping:!0,autoRotate:!0}}),{c(){A(e.$$.fragment)},l(o){D(e.$$.fragment,o)},m(o,s){I(e,o,s),i=!0},p:mt,i(o){i||(C(e.$$.fragment,o),i=!0)},o(o){M(e.$$.fragment,o),i=!1},d(o){z(e,o)}}}function oi(a){let e,i;return e=new q.DirectionalLightHelper({props:{args:[a[4],1,"white"]}}),{c(){A(e.$$.fragment)},l(o){D(e.$$.fragment,o)},m(o,s){I(e,o,s),i=!0},p(o,s){const r={};s&16&&(r.args=[o[4],1,"white"]),e.$set(r)},i(o){i||(C(e.$$.fragment,o),i=!0)},o(o){M(e.$$.fragment,o),i=!1},d(o){z(e,o)}}}function ni(a){let e,i,o,s,r,t;return e=new q.SphereGeometry({props:{args:[5,64,64]}}),o=new q.MeshStandardMaterial({props:{color:"white"}}),r=new ei({props:{object:a[4]}}),{c(){A(e.$$.fragment),i=ee(),A(o.$$.fragment),s=ee(),A(r.$$.fragment)},l(n){D(e.$$.fragment,n),i=$(n),D(o.$$.fragment,n),s=$(n),D(r.$$.fragment,n)},m(n,c){I(e,n,c),V(n,i,c),I(o,n,c),V(n,s,c),I(r,n,c),t=!0},p(n,c){const m={};c&16&&(m.object=n[4]),r.$set(m)},i(n){t||(C(e.$$.fragment,n),C(o.$$.fragment,n),C(r.$$.fragment,n),t=!0)},o(n){M(e.$$.fragment,n),M(o.$$.fragment,n),M(r.$$.fragment,n),t=!1},d(n){n&&(F(i),F(s)),z(e,n),z(o,n),z(r,n)}}}function si(a){let e,i,o,s,r,t,n,c,m,y,v,G;return e=new Ht({props:{cellColor:"#808080",sectionSize:0}}),o=new q.PerspectiveCamera({props:{makeDefault:!0,position:[20,20,20],fov:50,$$slots:{default:[ii,({ref:l})=>({4:l}),({ref:l})=>l?16:0]},$$scope:{ctx:a}}}),r=new q.AmbientLight({props:{color:"white",intensity:1}}),n=new q.DirectionalLight({props:{color:"white",intensity:10,position:[30,50,0],"shadow.camera.top":9,castShadow:!0,$$slots:{default:[oi,({ref:l})=>({4:l}),({ref:l})=>l?16:0]},$$scope:{ctx:a}}}),m=new q.Mesh({props:{position:a[0],receiveShadow:!0,castShadow:!0,$$slots:{default:[ni,({ref:l})=>({4:l}),({ref:l})=>l?16:0]},$$scope:{ctx:a}}}),v=new q.Mesh({props:{geometry:new at(20,20),material:new Et({color:"white",side:Ye}),rotation:[ti*90,0,0],receiveShadow:!0}}),{c(){A(e.$$.fragment),i=ee(),A(o.$$.fragment),s=ee(),A(r.$$.fragment),t=ee(),A(n.$$.fragment),c=ee(),A(m.$$.fragment),y=ee(),A(v.$$.fragment)},l(l){D(e.$$.fragment,l),i=$(l),D(o.$$.fragment,l),s=$(l),D(r.$$.fragment,l),t=$(l),D(n.$$.fragment,l),c=$(l),D(m.$$.fragment,l),y=$(l),D(v.$$.fragment,l)},m(l,g){I(e,l,g),V(l,i,g),I(o,l,g),V(l,s,g),I(r,l,g),V(l,t,g),I(n,l,g),V(l,c,g),I(m,l,g),V(l,y,g),I(v,l,g),G=!0},p(l,g){const E={};g&32&&(E.$$scope={dirty:g,ctx:l}),o.$set(E);const k={};g&48&&(k.$$scope={dirty:g,ctx:l}),n.$set(k);const S={};g&1&&(S.position=l[0]),g&48&&(S.$$scope={dirty:g,ctx:l}),m.$set(S)},i(l){G||(C(e.$$.fragment,l),C(o.$$.fragment,l),C(r.$$.fragment,l),C(n.$$.fragment,l),C(m.$$.fragment,l),C(v.$$.fragment,l),G=!0)},o(l){M(e.$$.fragment,l),M(o.$$.fragment,l),M(r.$$.fragment,l),M(n.$$.fragment,l),M(m.$$.fragment,l),M(v.$$.fragment,l),G=!1},d(l){l&&(F(i),F(s),F(t),F(c),F(y)),z(e,l),z(o,l),z(r,l),z(n,l),z(m,l),z(v,l)}}}function ai(a){let e,i,o;return i=new wt({props:{$$slots:{default:[si]},$$scope:{ctx:a}}}),{c(){e=ut("div"),A(i.$$.fragment),this.h()},l(s){e=ft(s,"DIV",{class:!0});var r=dt(e);D(i.$$.fragment,r),r.forEach(F),this.h()},h(){ht(e,"class","scene absolute w-full h-full inset-0 svelte-1g7yaxd")},m(s,r){V(s,e,r),I(i,e,null),o=!0},p(s,[r]){const t={};r&33&&(t.$$scope={dirty:r,ctx:s}),i.$set(t)},i(s){o||(C(i.$$.fragment,s),o=!0)},o(s){M(i.$$.fragment,s),o=!1},d(s){s&&F(e),z(i)}}}function ri(a={x:0,y:0,z:0}){return[...Object.values(a)]}function li(a,e,i){let o;new Mt(20,20),new Ct(10);const s={position:{x:0,y:5,z:0}};return new zt({title:"Scene"}).addFolder({title:"Sphere"}).addBinding(s,"position").on("change",({value:r})=>{i(1,s.position=r,s)}),a.$$.update=()=>{a.$$.dirty&2&&i(0,o=ri(s.position))},[o,s]}class gi extends Ae{constructor(e){super(),Ge(this,e,li,ai,Qe,{})}}export{gi as component};
